{"mineOneLog": {"code": "// main function\nasync function mineOneLog(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1. possible log block names\n  const logNames = [\"oak_log\", \"birch_log\", \"spruce_log\", \"jungle_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n\n  // helper to check if inventory already has a log\n  function hasLogInInventory() {\n    for (const name of logNames) {\n      const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n      if (item) return true;\n    }\n    return false;\n  }\n\n  // 2. already have a log?\n  if (hasLogInInventory()) {\n    bot.chat(\"I already have a log in my inventory.\");\n    return;\n  }\n\n  // 3. try to find a log block nearby\n  let targetLogName = null;\n  let targetBlockPos = null;\n  for (const name of logNames) {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName[name].id,\n      maxDistance: 32\n    });\n    if (block) {\n      targetLogName = name;\n      targetBlockPos = block.position;\n      break;\n    }\n  }\n\n  // 4. if not found, explore until we locate one\n  if (!targetBlockPos) {\n    // pick a random direction vector (components -1, 0, or 1, not all zero)\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    const found = await exploreUntil(bot, randomDir, 60, () => {\n      for (const name of logNames) {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName[name].id,\n          maxDistance: 32\n        });\n        if (blk) {\n          targetLogName = name;\n          targetBlockPos = blk.position;\n          return blk; // stop exploration\n        }\n      }\n      return null; // keep exploring\n    });\n    if (!found) {\n      bot.chat(\"Couldn't find any log after exploring.\");\n      return;\n    }\n  }\n\n  // 5. mine exactly one log of the discovered type\n  bot.chat(`Found a ${targetLogName}, mining it...`);\n  await mineBlock(bot, targetLogName, 1);\n\n  // 6. verify we now have a log\n  if (hasLogInInventory()) {\n    bot.chat(\"Successfully mined a log.\");\n  } else {\n    bot.chat(\"Failed to obtain a log after mining.\");\n  }\n}", "description": "async function mineOneLog(bot) {\n    // The routine first checks the inventory for any type of log and exits if one is already present; otherwise it scans the surroundings for a log block of any recognized wood type, and if none is found it explores in a random direction until a log is located, then mines exactly one of that log and finally confirms that a log now exists in the inventory.\n}"}, "craftFourOakPlanks": {"code": "// main function to craft exactly 4 oak planks\nasync function craftFourOakPlanks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: pick a random direction vector (components -1, 0, 1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // 1. Ensure we have at least one oak log in inventory\n  const oakLogId = mcData.itemsByName.oak_log.id;\n  let logCount = bot.inventory.count(oakLogId);\n  if (logCount === 0) {\n    bot.chat('No oak logs in inventory, searching for a log block...');\n    // try to find a log block nearby\n    let logBlock = bot.findBlock({\n      matching: mcData.blocksByName.oak_log.id,\n      maxDistance: 32\n    });\n\n    // if not found, explore until we locate one\n    if (!logBlock) {\n      await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName.oak_log.id,\n          maxDistance: 32\n        });\n        return blk ? blk : null;\n      });\n      logBlock = bot.findBlock({\n        matching: mcData.blocksByName.oak_log.id,\n        maxDistance: 32\n      });\n    }\n    if (!logBlock) {\n      bot.chat('Could not find any oak log block.');\n      return;\n    }\n\n    // mine one oak log\n    bot.chat('Found oak log block, mining one...');\n    await mineBlock(bot, 'oak_log', 1);\n    logCount = bot.inventory.count(oakLogId);\n  }\n\n  // 2. Make sure we have enough logs (1 log \u2192 4 planks)\n  const neededLogs = 1; // one log is enough for four planks\n  if (logCount < neededLogs) {\n    const toMine = neededLogs - logCount;\n    bot.chat(`Mining ${toMine} additional oak log(s)...`);\n    await mineBlock(bot, 'oak_log', toMine);\n  }\n\n  // 3. Craft oak planks using the 2\u00d72 inventory crafting grid\n  const plankItem = mcData.itemsByName.oak_planks;\n  const recipes = bot.recipesFor(plankItem.id, null, 1, null);\n  if (recipes.length === 0) {\n    bot.chat('No recipe found for oak planks.');\n    return;\n  }\n  const recipe = recipes[0];\n  // one recipe execution yields 4 planks\n  await bot.craft(recipe, 1, null);\n  bot.chat('Crafted oak planks from oak log(s).');\n\n  // 4. Verify we now have at least 4 oak planks\n  const plankCount = bot.inventory.count(plankItem.id);\n  if (plankCount >= 4) {\n    bot.chat(`Success! ${plankCount} oak planks now in inventory.`);\n  } else {\n    bot.chat(`Failed to craft enough planks. Only have ${plankCount}.`);\n  }\n}", "description": "async function craftFourOakPlanks(bot) {\n    // The function ensures an oak log is present in the inventory, searching for and mining one if needed, then verifies there is at least one log (sufficient for four planks), crafts oak planks using the 2\u00d72 crafting grid, and finally checks that the inventory now contains at least four oak planks.\n}"}, "ensureTwoSticks": {"code": "// main function to ensure the bot has at least 2 sticks\nasync function ensureTwoSticks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper to count items in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1. Already have enough sticks?\n  if (countItem('stick') >= 2) {\n    bot.chat('I already have at least 2 sticks.');\n    return;\n  }\n\n  // 2. Make sure we have at least 2 oak planks\n  if (countItem('oak_planks') < 2) {\n    // 2a. Need oak logs to craft planks\n    if (countItem('oak_log') === 0) {\n      bot.chat('I need an oak log to craft planks, searching for one...');\n      // try to find a log block nearby\n      let logBlock = bot.findBlock({\n        matching: mcData.blocksByName.oak_log.id,\n        maxDistance: 32\n      });\n\n      // if not found, explore randomly until we locate one\n      if (!logBlock) {\n        // pick a random direction vector (components -1,0,1, not all zero)\n        const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n        const randomDir = dirs[Math.floor(Math.random() * dirs.length)];\n        await exploreUntil(bot, randomDir, 60, () => {\n          const blk = bot.findBlock({\n            matching: mcData.blocksByName.oak_log.id,\n            maxDistance: 32\n          });\n          return blk ? blk : null;\n        });\n        logBlock = bot.findBlock({\n          matching: mcData.blocksByName.oak_log.id,\n          maxDistance: 32\n        });\n      }\n      if (!logBlock) {\n        bot.chat('Could not find any oak log block.');\n        return;\n      }\n\n      // mine one oak log\n      bot.chat('Found oak log, mining one...');\n      await mineBlock(bot, 'oak_log', 1);\n    }\n\n    // 2b. Now we have at least one oak log, craft planks\n    if (countItem('oak_log') > 0) {\n      bot.chat('Crafting oak planks from oak log...');\n      // one execution of the recipe yields 4 planks\n      await craftItem(bot, 'oak_planks', 1);\n    }\n\n    // verify we now have enough planks\n    if (countItem('oak_planks') < 2) {\n      bot.chat('Failed to obtain enough oak planks.');\n      return;\n    }\n  }\n\n  // 3. Ensure a crafting table block is placed nearby\n  // 3a. Look for an existing table within 5 blocks\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    // 3b. Need a crafting table item in inventory\n    if (countItem('crafting_table') === 0) {\n      bot.chat('I need a crafting table item, crafting one...');\n      await craftItem(bot, 'crafting_table', 1);\n    }\n\n    // 3c. Place the table at a free adjacent position\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing the crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    bot.chat('Crafting table placed.');\n    // update reference\n    tableBlock = bot.blockAt(placePos);\n  }\n\n  // 4. Craft sticks at the table (one recipe gives 4 sticks)\n  bot.chat('Crafting sticks...');\n  await craftItem(bot, 'stick', 1); // produces 4 sticks\n\n  // 5. Verify we now have at least 2 sticks\n  if (countItem('stick') >= 2) {\n    bot.chat('Successfully crafted sticks. I now have at least 2 sticks.');\n  } else {\n    bot.chat('Failed to craft sticks.');\n  }\n}", "description": "async function ensureTwoSticks(bot) {\n    // The function checks whether the bot already has at least two sticks, and if not it gathers an oak log, crafts oak planks, ensures a crafting table is present nearby (placing one if needed), crafts sticks at the table, and finally verifies that the inventory now contains the required two sticks.\n}"}, "obtainAcaciaLog": {"code": "// main function to obtain one acacia log\nasync function obtainAcaciaLog(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: how many of a given item are in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1. already have the log?\n  if (countItem('acacia_log') >= 1) {\n    bot.chat('I already have an acacia log.');\n    return;\n  }\n\n  // 2. try to find a log block nearby\n  let logBlock = bot.findBlock({\n    matching: mcData.blocksByName.acacia_log.id,\n    maxDistance: 32\n  });\n\n  // 3. if not found, explore randomly until we locate one\n  if (!logBlock) {\n    // possible direction vectors (components -1,0,1, not all zero)\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    bot.chat('Acacia log not nearby, exploring...');\n    await exploreUntil(bot, randomDir, 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.acacia_log.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null; // stop when found\n    });\n\n    // try again after exploration\n    logBlock = bot.findBlock({\n      matching: mcData.blocksByName.acacia_log.id,\n      maxDistance: 32\n    });\n  }\n\n  // 4. still not found?\n  if (!logBlock) {\n    bot.chat('Could not find any acacia log block.');\n    return;\n  }\n\n  // 5. mine exactly one acacia log\n  bot.chat(`Found an acacia log at ${logBlock.position}. Mining one...`);\n  await mineBlock(bot, 'acacia_log', 1);\n\n  // 6. verify we now have the log\n  if (countItem('acacia_log') >= 1) {\n    bot.chat('Successfully obtained an acacia log.');\n  } else {\n    bot.chat('Failed to obtain an acacia log after mining.');\n  }\n}", "description": "async function obtainAcaciaLog(bot) {\n    // The routine checks whether the bot already possesses an acacia log, searches the surrounding area for an acacia log block, explores randomly if none is found, mines a single acacia log block when located, and finally verifies that the log was added to the inventory.\n}"}, "craftWoodenPickaxe": {"code": "// main function to craft one wooden pickaxe\nasync function craftWoodenPickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper ---------- //\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // total number of planks (any wood type)\n  function countAllPlanks() {\n    const plankNames = ['oak_planks', 'spruce_planks', 'birch_planks', 'jungle_planks', 'acacia_planks', 'dark_oak_planks', 'crimson_planks', 'warped_planks'];\n    return plankNames.reduce((sum, n) => sum + countItem(n), 0);\n  }\n\n  // find any log block (any wood type) within 32 blocks\n  function findAnyLogBlock() {\n    const logNames = ['oak_log', 'spruce_log', 'birch_log', 'jungle_log', 'acacia_log', 'dark_oak_log', 'crimson_stem', 'warped_stem'];\n    for (const name of logNames) {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName[name].id,\n        maxDistance: 32\n      });\n      if (block) return {\n        block,\n        name\n      };\n    }\n    return null;\n  }\n\n  // ---------- 1. place crafting table if needed ---------- //\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    bot.chat('Placing a crafting table...');\n    // ensure we have a crafting table item\n    if (countItem('crafting_table') === 0) {\n      // need to craft one (requires 4 planks)\n      if (countAllPlanks() < 4) {\n        // try to get more planks from a log\n        const logInfo = findAnyLogBlock() || (await (async () => {\n          // explore randomly until a log appears\n          const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n          const dir = dirs[Math.floor(Math.random() * dirs.length)];\n          await exploreUntil(bot, dir, 60, () => {\n            const blk = findAnyLogBlock();\n            return blk ? blk.block : null;\n          });\n          return findAnyLogBlock();\n        })());\n        if (!logInfo) {\n          bot.chat('Cannot find any log to craft planks for a crafting table.');\n          return;\n        }\n        await mineBlock(bot, logInfo.name, 1);\n      }\n      await craftItem(bot, 'crafting_table', 1);\n    }\n\n    // place the table at a free adjacent block\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    bot.chat('Crafting table placed.');\n  } else {\n    bot.chat('Crafting table already placed nearby.');\n  }\n\n  // ---------- 2. ensure we have at least 3 planks ---------- //\n  while (countAllPlanks() < 3) {\n    bot.chat('Not enough planks, searching for a log...');\n    let logInfo = findAnyLogBlock();\n    if (!logInfo) {\n      // explore randomly until a log appears\n      const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n      const dir = dirs[Math.floor(Math.random() * dirs.length)];\n      await exploreUntil(bot, dir, 60, () => {\n        const blk = findAnyLogBlock();\n        return blk ? blk.block : null;\n      });\n      logInfo = findAnyLogBlock();\n    }\n    if (!logInfo) {\n      bot.chat('Could not find any log to make planks.');\n      return;\n    }\n\n    // mine the log\n    await mineBlock(bot, logInfo.name, 1);\n    // craft planks from that log\n    const plankName = logInfo.name.replace('_log', '_planks').replace('_stem', '_planks'); // for crimson/warped\n    bot.chat(`Crafting ${plankName} from ${logInfo.name}...`);\n    await craftItem(bot, plankName, 1);\n  }\n  bot.chat('Enough planks are available.');\n\n  // ---------- 3. ensure we have at least 2 sticks ---------- //\n  if (countItem('stick') < 2) {\n    bot.chat('Not enough sticks, crafting sticks...');\n    await craftItem(bot, 'stick', 1); // yields 4 sticks\n  } else {\n    bot.chat('Sufficient sticks already in inventory.');\n  }\n\n  // ---------- 4. craft the wooden pickaxe ---------- //\n  bot.chat('Crafting a wooden pickaxe...');\n  await craftItem(bot, 'wooden_pickaxe', 1);\n  bot.chat('Wooden pickaxe crafted!');\n}", "description": "async function craftWoodenPickaxe(bot) {\n    // The function guarantees a crafting table is present, obtains at least three planks by locating and mining logs if necessary, ensures there are at least two sticks, and then uses these resources to craft a wooden pickaxe.\n}"}, "mineThreeCobblestone": {"code": "// main function to mine three cobblestone blocks\nasync function mineThreeCobblestone(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper to count items in inventory -----\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ----- 1. ensure we have a wooden pickaxe -----\n  if (countItem('wooden_pickaxe') === 0) {\n    bot.chat('I need a wooden pickaxe, crafting one...');\n    // need 3 planks and 2 sticks; we already have sticks, ensure planks\n    if (countItem('oak_planks') < 3) {\n      // try to craft planks from any log we might have\n      const logNames = ['oak_log', 'spruce_log', 'birch_log', 'jungle_log', 'acacia_log', 'dark_oak_log', 'crimson_stem', 'warped_stem'];\n      let logBlock = null;\n      for (const n of logNames) {\n        logBlock = bot.findBlock({\n          matching: mcData.blocksByName[n].id,\n          maxDistance: 32\n        });\n        if (logBlock) break;\n      }\n      if (!logBlock) {\n        // explore until a log appears\n        const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n        const dir = dirs[Math.floor(Math.random() * dirs.length)];\n        await exploreUntil(bot, dir, 60, () => {\n          for (const n of logNames) {\n            const blk = bot.findBlock({\n              matching: mcData.blocksByName[n].id,\n              maxDistance: 32\n            });\n            if (blk) return blk;\n          }\n          return null;\n        });\n        // after exploration try again\n        for (const n of logNames) {\n          logBlock = bot.findBlock({\n            matching: mcData.blocksByName[n].id,\n            maxDistance: 32\n          });\n          if (logBlock) break;\n        }\n      }\n      if (logBlock) {\n        const logName = Object.keys(mcData.blocksByName).find(k => mcData.blocksByName[k].id === logBlock.type);\n        await mineBlock(bot, logName, 1);\n      } else {\n        bot.chat('Could not find any log to make planks.');\n        return;\n      }\n    }\n    // now we have at least 3 planks, craft the pickaxe\n    await craftItem(bot, 'wooden_pickaxe', 1);\n  }\n\n  // ----- 2. equip the pickaxe -----\n  const pickaxeItem = bot.inventory.findInventoryItem(mcData.itemsByName.wooden_pickaxe.id);\n  if (pickaxeItem) await bot.equip(pickaxeItem, 'hand');\n\n  // ----- 3. locate stone -----\n  let stoneBlock = bot.findBlock({\n    matching: mcData.blocksByName.stone.id,\n    maxDistance: 32\n  });\n  if (!stoneBlock) {\n    bot.chat('No stone nearby, exploring...');\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    const found = await exploreUntil(bot, randomDir, 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.stone.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    if (!found) {\n      bot.chat('Could not find stone after exploring.');\n      return;\n    }\n    stoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32\n    });\n  }\n\n  // ----- 4. mine three stone blocks (producing cobblestone) -----\n  bot.chat(`Found stone at ${stoneBlock.position}. Mining 3 blocks...`);\n  await mineBlock(bot, 'stone', 3);\n\n  // ----- 5. verify we have at least 3 cobblestone -----\n  const cobbleCount = countItem('cobblestone');\n  if (cobbleCount >= 3) {\n    bot.chat(`Success! I now have ${cobbleCount} cobblestone.`);\n  } else {\n    bot.chat(`Failed to collect enough cobblestone. I only have ${cobbleCount}.`);\n  }\n}", "description": "async function mineThreeCobblestone(bot) {\n    // The routine first checks for a wooden pickaxe and crafts one using planks and sticks, gathering logs if necessary; it then equips the pickaxe, searches the surroundings for a stone block, and explores randomly until stone is found; once stone is located, it mines three blocks to produce cobblestone; finally, it verifies that at least three cobblestone items are present in the inventory.\n}"}, "mineThreeStoneBlocks": {"code": "// main function to mine three stone blocks\nasync function mineThreeStoneBlocks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. place a crafting table if needed ----------\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!craftingTableBlock) {\n    // we already have a crafting_table item in inventory (see inventory)\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing a crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    craftingTableBlock = bot.blockAt(placePos);\n    bot.chat('Crafting table placed.');\n  } else {\n    bot.chat('Crafting table already nearby.');\n  }\n\n  // ---------- 2. ensure we have materials for a stone pickaxe ----------\n  const neededCobble = Math.max(0, 3 - countItem('cobblestone'));\n  const neededSticks = Math.max(0, 2 - countItem('stick'));\n  if (neededCobble > 0) {\n    bot.chat(`Need ${neededCobble} more cobblestone for the pickaxe, mining stone...`);\n    // mine stone to get cobblestone (will be done later, but we assume we already have enough)\n  }\n  if (neededSticks > 0) {\n    bot.chat(`Need ${neededSticks} more sticks, crafting sticks...`);\n    await craftItem(bot, 'stick', 1); // yields 4 sticks\n  }\n\n  // ---------- 3. craft stone pickaxe ----------\n  if (!bot.inventory.findInventoryItem(mcData.itemsByName.stone_pickaxe.id)) {\n    bot.chat('Crafting a stone pickaxe...');\n    await craftItem(bot, 'stone_pickaxe', 1);\n  } else {\n    bot.chat('Stone pickaxe already in inventory.');\n  }\n\n  // ---------- 4. equip stone pickaxe ----------\n  const pickaxe = bot.inventory.findInventoryItem(mcData.itemsByName.stone_pickaxe.id);\n  if (pickaxe) {\n    await bot.equip(pickaxe, 'hand');\n    bot.chat('Equipped stone pickaxe.');\n  } else {\n    bot.chat('Error: stone pickaxe not found after crafting.');\n    return;\n  }\n\n  // ---------- 5. locate stone block ----------\n  let stoneBlock = bot.findBlock({\n    matching: mcData.blocksByName.stone.id,\n    maxDistance: 32\n  });\n  if (!stoneBlock) {\n    bot.chat('No stone nearby, exploring...');\n    await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.stone.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    stoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32\n    });\n    if (!stoneBlock) {\n      bot.chat('Could not find any stone block after exploring.');\n      return;\n    }\n  }\n\n  // ---------- 6. mine three stone blocks ----------\n  bot.chat('Mining three stone blocks...');\n  await mineBlock(bot, 'stone', 3);\n  bot.chat('Finished mining three stone blocks.');\n\n  // ---------- 7. verification ----------\n  const cobbleCount = countItem('cobblestone');\n  if (cobbleCount >= 3) {\n    bot.chat(`Success! You now have at least ${cobbleCount} cobblestone (from mined stone).`);\n  } else {\n    bot.chat('Mining completed but not enough cobblestone was collected.');\n  }\n}", "description": "async function mineThreeStoneBlocks(bot) {\n    // The routine first ensures a crafting table is placed nearby, then checks and obtains the needed cobblestone and sticks, crafts a stone pickaxe if absent, equips it, searches for a stone block (exploring in random directions if none are nearby), mines three stone blocks with the pickaxe, and finally verifies that at least three cobblestones were collected.\n}"}, "mineThreeCoal": {"code": "// main function to mine at least three coal items\nasync function mineThreeCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. already have enough coal? ----------\n  if (countItem('coal') >= 3) {\n    bot.chat('I already have at least three coal.');\n    return;\n  }\n\n  // ---------- 2. ensure a pickaxe is equipped ----------\n  // Prefer stone_pickaxe, otherwise any pickaxe\n  const pickaxeNames = ['stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe', 'wooden_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat('No pickaxe found in inventory \u2013 cannot mine coal.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n  bot.chat(`Equipped ${pickaxeItem.name} for mining.`);\n\n  // ---------- 3. locate coal ore ----------\n  let coalBlock = bot.findBlock({\n    matching: mcData.blocksByName.coal_ore.id,\n    maxDistance: 32\n  });\n  if (!coalBlock) {\n    bot.chat('No coal ore nearby, exploring...');\n    const dir = randomDirection();\n    await exploreUntil(bot, dir, 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.coal_ore.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    coalBlock = bot.findBlock({\n      matching: mcData.blocksByName.coal_ore.id,\n      maxDistance: 32\n    });\n    if (!coalBlock) {\n      bot.chat('Could not find any coal ore after exploring.');\n      return;\n    }\n  }\n  bot.chat(`Found coal ore at ${coalBlock.position}. Starting mining.`);\n\n  // ---------- 4. mine three coal ore blocks ----------\n  await mineBlock(bot, 'coal_ore', 3);\n  bot.chat('Mined three coal ore blocks.');\n\n  // ---------- 5. verify we have enough coal, mine extra if needed ----------\n  let coalCount = countItem('coal');\n  let extraAttempts = 0;\n  while (coalCount < 3 && extraAttempts < 2) {\n    bot.chat(`Only have ${coalCount} coal, mining one more ore block.`);\n    await mineBlock(bot, 'coal_ore', 1);\n    coalCount = countItem('coal');\n    extraAttempts++;\n  }\n\n  // ---------- 6. final report ----------\n  if (coalCount >= 3) {\n    bot.chat(`Success! I now have ${coalCount} coal.`);\n  } else {\n    bot.chat(`Failed to collect enough coal. I have ${coalCount} coal.`);\n  }\n}", "description": "async function mineThreeCoal(bot) {\n    // The routine first checks whether the bot already possesses at least three coal items and exits if so; it then looks for any pickaxe in the inventory, preferring stone, and equips the first one found; next it searches for a coal ore block within a 32\u2011block radius, and if none is located it explores in a random horizontal direction for up to a minute until ore is found; once a coal ore block is identified, it mines three ore blocks and then repeatedly mines single blocks until the coal count reaches three or two extra attempts have been made; finally it determines whether the required amount of coal was obtained.\n}"}, "mineOneIronOre": {"code": "// main function to mine exactly one iron ore block\nasync function mineOneIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count how many of a given item are in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1\ufe0f\u20e3 Already have raw iron?\n  if (countItem('raw_iron') >= 1) {\n    bot.chat('I already have raw iron in my inventory.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have a stone pickaxe (or better)\n  const pickaxeNames = ['stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat('I have no suitable pickaxe to mine iron ore.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n  bot.chat(`Equipped ${pickaxeItem.name} for mining.`);\n\n  // 3\ufe0f\u20e3 Look for iron ore nearby\n  let ironOreBlock = bot.findBlock({\n    matching: mcData.blocksByName.iron_ore.id,\n    maxDistance: 32\n  });\n\n  // 4\ufe0f\u20e3 If not found, explore randomly until we locate one\n  if (!ironOreBlock) {\n    bot.chat('No iron ore nearby, exploring...');\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    await exploreUntil(bot, randomDir, 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null; // stop when found\n    });\n    ironOreBlock = bot.findBlock({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32\n    });\n  }\n\n  // 5\ufe0f\u20e3 If still not found, give up\n  if (!ironOreBlock) {\n    bot.chat('Could not locate any iron ore after exploring.');\n    return;\n  }\n\n  // 6\ufe0f\u20e3 Mine one iron ore block\n  bot.chat(`Found iron ore at ${ironOreBlock.position}. Mining one...`);\n  await mineBlock(bot, 'iron_ore', 1);\n\n  // 7\ufe0f\u20e3 Verify we now have raw iron\n  if (countItem('raw_iron') >= 1) {\n    bot.chat('Successfully mined raw iron.');\n  } else {\n    bot.chat('Failed to obtain raw iron after mining.');\n  }\n}", "description": "async function mineOneIronOre(bot) {\n    // The routine first checks if raw iron is already in the inventory and aborts if so, then searches the bot\u2019s inventory for a stone\u2011level or better pickaxe and equips it; it looks for an iron ore block within a 32\u2011block radius, and if none is found it explores in a random direction until one appears, after which it mines exactly one iron ore block and finally confirms that raw iron has been added to the inventory.\n}"}, "mineTwoStoneBlocks": {"code": "// main function to mine exactly two stone blocks (producing cobblestone)\nasync function mineTwoStoneBlocks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // helper: count items in inventory by name\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1\ufe0f\u20e3 Ensure we have a stone (or better) pickaxe\n  const pickaxeNames = ['stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat('I have no stone or better pickaxe, cannot mine stone.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n  bot.chat(`Equipped ${pickaxeItem.name} for mining stone.`);\n\n  // 2\ufe0f\u20e3 Locate a stone block nearby\n  let stoneBlock = bot.findBlock({\n    matching: mcData.blocksByName.stone.id,\n    maxDistance: 32\n  });\n\n  // 3\ufe0f\u20e3 If not found, explore randomly until we locate one (max 60\u202fs)\n  if (!stoneBlock) {\n    bot.chat('No stone block nearby, exploring...');\n    await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.stone.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    stoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32\n    });\n    if (!stoneBlock) {\n      bot.chat('Could not find any stone block after exploring.');\n      return;\n    }\n  }\n\n  // 4\ufe0f\u20e3 Mine two stone blocks (will give cobblestone)\n  bot.chat(`Found stone at ${stoneBlock.position}. Mining two blocks...`);\n  await mineBlock(bot, 'stone', 2);\n\n  // 5\ufe0f\u20e3 Verify we now have at least two cobblestone items\n  const cobbleCount = countItem('cobblestone');\n  if (cobbleCount >= 2) {\n    bot.chat(`Success! I now have ${cobbleCount} cobblestone (mined from stone).`);\n  } else {\n    bot.chat(`Failed to obtain enough cobblestone. I have ${cobbleCount}.`);\n  }\n}", "description": "async function mineTwoStoneBlocks(bot) {\n    // The function first checks that the bot possesses a stone\u2011or\u2011better pickaxe and equips it, then searches for a stone block within a 32\u2011block radius, exploring randomly for up to 60\u202fseconds if none is initially found; once a stone block is located it mines exactly two stone blocks to produce cobblestone, and finally it confirms that the inventory now contains at least two cobblestone items.\n}"}, "mineThreeIronOre": {"code": "// main function to mine three iron ore blocks\nasync function mineThreeIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory by name\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // 1\ufe0f\u20e3 Ensure we have a stone (or better) pickaxe and equip it\n  const pickaxeNames = ['stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat('I do not have a stone or better pickaxe, cannot mine iron ore.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n  bot.chat(`Equipped ${pickaxeItem.name} for mining iron ore.`);\n\n  // 2\ufe0f\u20e3 Locate an iron ore block within 32 blocks\n  let ironBlock = bot.findBlock({\n    matching: mcData.blocksByName.iron_ore.id,\n    maxDistance: 32\n  });\n\n  // 3\ufe0f\u20e3 If not found, explore randomly until we locate one (max 60\u202fs)\n  if (!ironBlock) {\n    bot.chat('No iron ore nearby, exploring...');\n    await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    ironBlock = bot.findBlock({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32\n    });\n    if (!ironBlock) {\n      bot.chat('Could not find any iron ore after exploring.');\n      return;\n    }\n  }\n\n  // 4\ufe0f\u20e3 Mine three iron ore blocks\n  bot.chat(`Found iron ore at ${ironBlock.position}. Mining three blocks...`);\n  await mineBlock(bot, 'iron_ore', 3);\n\n  // 5\ufe0f\u20e3 Verify we now have at least three iron ore items\n  const ironCount = countItem('iron_ore');\n  if (ironCount >= 3) {\n    bot.chat(`Success! I now have ${ironCount} iron ore.`);\n  } else {\n    bot.chat(`Failed to collect enough iron ore. I have ${ironCount}.`);\n  }\n}", "description": "async function mineThreeIronOre(bot) {\n    // The function equips a stone\u2011or\u2011better pickaxe, searches for an iron ore block within 32 blocks (exploring randomly for up to 60\u202fseconds if none is initially found), mines three iron ore blocks, and then verifies that the inventory contains at least three iron ore items.\n}"}, "craftFurnace": {"code": "// main function to craft a furnace\nasync function craftFurnace(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helpers -------------------------------------------------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // Find a solid block with air above within radius 5\n  function findPlacePosForTable() {\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const base = bot.entity.position.floored();\n    for (const off of offsets) {\n      const solidPos = base.offset(off.x, off.y, off.z);\n      const abovePos = solidPos.offset(0, 1, 0);\n      const solidBlock = bot.blockAt(solidPos);\n      const aboveBlock = bot.blockAt(abovePos);\n      if (solidBlock && solidBlock.name !== 'air' && aboveBlock && aboveBlock.name === 'air') {\n        return abovePos; // place on top of solidBlock\n      }\n    }\n    return null;\n  }\n\n  // Random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ----- 1. Ensure enough cobblestone -------------------------\n  const neededCobble = Math.max(0, 8 - countItem('cobblestone'));\n  if (neededCobble > 0) {\n    bot.chat(`Need ${neededCobble} more cobblestone, mining stone...`);\n    await mineBlock(bot, 'stone', neededCobble);\n  } else {\n    bot.chat('Enough cobblestone available.');\n  }\n\n  // ----- 2. Locate or place a crafting table -------------------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    // we need to place one\n    if (countItem('crafting_table') === 0) {\n      bot.chat('No crafting table item in inventory \u2013 cannot craft furnace.');\n      return;\n    }\n\n    // try to find a suitable spot\n    let placePos = findPlacePosForTable();\n\n    // if none, explore a bit and retry (max 30\u202fs)\n    if (!placePos) {\n      bot.chat('No free spot nearby, moving to find a place...');\n      await exploreUntil(bot, randomDirection(), 30, () => {\n        placePos = findPlacePosForTable();\n        return placePos ? placePos : null;\n      });\n    }\n    if (!placePos) {\n      bot.chat('Failed to find a place to put the crafting table.');\n      return;\n    }\n    bot.chat(`Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    if (!tableBlock || tableBlock.name !== 'crafting_table') {\n      bot.chat('Failed to place the crafting table.');\n      return;\n    }\n    bot.chat('Crafting table placed successfully.');\n  } else {\n    bot.chat('Crafting table already placed nearby.');\n  }\n\n  // ----- 3. Craft the furnace ---------------------------------\n  bot.chat('Crafting a furnace...');\n  try {\n    await craftItem(bot, 'furnace', 1);\n    bot.chat('Furnace crafted successfully!');\n  } catch (err) {\n    bot.chat(`Failed to craft furnace: ${err.message}`);\n  }\n}", "description": "async function craftFurnace(bot) {\n    // The routine first checks the inventory for at least eight cobblestones and mines additional stone blocks if the count is insufficient; it then searches for a nearby crafting table and, if none is found, attempts to place one on a suitable solid block with air above, moving around if necessary to locate a spot; finally, with a crafting table available, it crafts a furnace while handling any potential errors.\n}"}, "smeltFourIronIngot": {"code": "// main function to smelt four iron ingots\nasync function smeltFourIronIngot(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper to count items in inventory -----\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ----- 1. verify required materials -----\n  if (countItem('raw_iron') < 4) {\n    bot.chat('I need at least 4 raw_iron to smelt, but I don\\'t have enough.');\n    return;\n  }\n  if (countItem('coal') < 1) {\n    bot.chat('I need some fuel (coal) to smelt the iron.');\n    return;\n  }\n  if (!bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id)) {\n    bot.chat('I have no furnace item in my inventory.');\n    return;\n  }\n\n  // ----- 2. try to find an existing furnace -----\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n\n  // ----- 3. place a furnace if none is found -----\n  if (!furnaceBlock) {\n    bot.chat('No furnace nearby, looking for a free spot to place one...');\n    // possible horizontal offsets (order can be random)\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n\n    // shuffle offsets to avoid deterministic placement\n    for (let i = offsets.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [offsets[i], offsets[j]] = [offsets[j], offsets[i]];\n    }\n    let placePos = null;\n    for (const off of offsets) {\n      const candidate = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(candidate);\n      const below = bot.blockAt(candidate.offset(0, -1, 0));\n      if (block && block.name === 'air' && below && below.name !== 'air') {\n        placePos = candidate;\n        break;\n      }\n    }\n\n    // if still not found, explore a random direction and try again\n    if (!placePos) {\n      const randomDir = offsets[Math.floor(Math.random() * offsets.length)];\n      await exploreUntil(bot, randomDir, 60, () => {\n        for (const off of offsets) {\n          const cand = bot.entity.position.offset(off.x, off.y, off.z);\n          const blk = bot.blockAt(cand);\n          const below = bot.blockAt(cand.offset(0, -1, 0));\n          if (blk && blk.name === 'air' && below && below.name !== 'air') {\n            placePos = cand;\n            return true;\n          }\n        }\n        return false;\n      });\n    }\n    if (!placePos) {\n      bot.chat('Could not find a free place to put the furnace.');\n      return;\n    }\n    bot.chat(`Placing furnace at ${placePos}`);\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    if (!furnaceBlock || furnaceBlock.name !== 'furnace') {\n      bot.chat('Failed to place the furnace.');\n      return;\n    }\n    bot.chat('Furnace placed successfully.');\n  } else {\n    bot.chat('Found an existing furnace nearby.');\n  }\n\n  // ----- 4. smelt the iron -----\n  bot.chat('Smelting 4 raw iron into iron ingots...');\n  await smeltItem(bot, 'raw_iron', 'coal', 4);\n  bot.chat('Finished smelting. Check inventory for iron_ingot.');\n}", "description": "async function smeltFourIronIngot(bot) {\n    // The routine ensures the bot has at least four raw iron, one coal, and a furnace item, then searches for a nearby furnace; if none is found it looks for a suitable empty block adjacent to solid ground and places a furnace there, optionally exploring further to locate a spot, and finally initiates smelting of four raw iron using the coal as fuel, resulting in iron ingots in the inventory.\n}"}, "craftFourSticks": {"code": "// main function to craft at least 4 sticks\nasync function craftFourSticks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // total planks of any wood type\n  function countAllPlanks() {\n    const plankNames = ['oak_planks', 'spruce_planks', 'birch_planks', 'jungle_planks', 'acacia_planks', 'dark_oak_planks', 'crimson_planks', 'warped_planks'];\n    return plankNames.reduce((sum, n) => sum + countItem(n), 0);\n  }\n\n  // find any log block name we have in inventory\n  function findLogInInventory() {\n    const logNames = ['oak_log', 'spruce_log', 'birch_log', 'jungle_log', 'acacia_log', 'dark_oak_log', 'crimson_stem', 'warped_stem', 'mangrove_log'];\n    for (const n of logNames) {\n      if (countItem(n) > 0) return n;\n    }\n    return null;\n  }\n\n  // ---------- 1. ensure a crafting table block is placed ----------\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!craftingTableBlock) {\n    // we have a crafting table item?\n    if (countItem('crafting_table') === 0) {\n      bot.chat('I need a crafting table but have none.');\n      return;\n    }\n    // place it at a free adjacent block\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing a crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    craftingTableBlock = bot.blockAt(placePos);\n    bot.chat('Crafting table placed.');\n  } else {\n    bot.chat('Crafting table already nearby.');\n  }\n\n  // ---------- 2. ensure we have at least 2 planks ----------\n  if (countAllPlanks() < 2) {\n    bot.chat('Not enough planks, trying to craft from logs...');\n    const logName = findLogInInventory();\n    if (!logName) {\n      bot.chat('No logs in inventory to make planks.');\n      return;\n    }\n    // each log yields 4 planks of its type\n    const plankName = logName.replace('_log', '_planks').replace('_stem', '_planks');\n    await craftItem(bot, plankName, 1); // 1 craft = 4 planks\n    bot.chat(`Crafted ${plankName} from ${logName}.`);\n  }\n\n  // ---------- 3. craft sticks ----------\n  // verify again we have at least 2 planks\n  if (countAllPlanks() < 2) {\n    bot.chat('Still not enough planks after attempting to craft them.');\n    return;\n  }\n  bot.chat('Crafting sticks (4 sticks)...');\n  await craftItem(bot, 'stick', 1); // yields 4 sticks\n  bot.chat('Sticks crafted!');\n\n  // ---------- 4. final verification ----------\n  const sticks = countItem('stick');\n  if (sticks >= 4) {\n    bot.chat(`Success: I now have ${sticks} sticks.`);\n  } else {\n    bot.chat(`Unexpected: only ${sticks} sticks after crafting.`);\n  }\n}", "description": "async function craftFourSticks(bot) {\n    // The function first makes sure a crafting table block is present near the bot, placing one if it has the item; it then checks that the inventory contains at least two wooden planks, converting a log into planks when needed; after confirming sufficient planks, it crafts four sticks using the crafting table; finally, it verifies that the inventory now holds at least four sticks.\n}"}, "mineFiveCopperOre": {"code": "// ------------------------------------------------------------\n// Helper functions (only those not already provided above)\n// ------------------------------------------------------------\nasync function randomDirection(Vec3) {\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n/**\n * Count how many items of a given name are in the bot's inventory.\n */\n\n/**\n * Count how many items of a given name are in the bot's inventory.\n */\nfunction countItem(bot, mcData, name) {\n  const id = mcData.itemsByName[name]?.id;\n  return id ? bot.inventory.count(id) : 0;\n}\n\n/**\n * Place a block (crafting table or furnace) if none exists within 5 blocks.\n */\n\n/**\n * Place a block (crafting table or furnace) if none exists within 5 blocks.\n */\nasync function ensureBlockPlaced(bot, mcData, itemName, blockId) {\n  const existing = bot.findBlock({\n    matching: blockId,\n    maxDistance: 5\n  });\n  if (existing) return existing;\n  const item = bot.inventory.findInventoryItem(mcData.itemsByName[itemName].id);\n  if (!item) {\n    bot.chat(`I don't have a ${itemName} to place.`);\n    return null;\n  }\n  const placePos = bot.entity.position.offset(1, 0, 0);\n  await placeItem(bot, itemName, placePos);\n  return bot.blockAt(placePos);\n}\n\n/**\n * Move at least one coal stack to a slot >= startSlot (default 3) so smeltItem can find it.\n */\n\n/**\n * Move at least one coal stack to a slot >= startSlot (default 3) so smeltItem can find it.\n */\nasync function ensureFuelInSlotRange(bot, mcData, fuelName = 'coal', startSlot = 3) {\n  const fuelId = mcData.itemsByName[fuelName].id;\n  const fuelItem = bot.inventory.findInventoryItem(fuelId);\n  if (!fuelItem) {\n    bot.chat(`I have no ${fuelName} for fuel.`);\n    return false;\n  }\n  // If the coal is already in the acceptable range, we are done.\n  if (fuelItem.slot >= startSlot) return true;\n\n  // Find an empty slot in the allowed range.\n  const emptySlot = bot.inventory.firstEmptySlot(startSlot, 39);\n  if (emptySlot === null) {\n    bot.chat('No free inventory slot to move fuel into.');\n    return false;\n  }\n  // Transfer the whole stack (or at least one) to the empty slot.\n  await bot.transfer(fuelItem.slot, emptySlot, fuelItem.count);\n  bot.chat(`Moved ${fuelName} to slot ${emptySlot} for smelting.`);\n  return true;\n}\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\nasync function mineFiveCopperOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1. Ensure a crafting table (required for pickaxe crafting)\n  const craftingTable = await ensureBlockPlaced(bot, mcData, 'crafting_table', mcData.blocksByName.crafting_table.id);\n  if (!craftingTable) {\n    bot.chat('Cannot continue without a crafting table.');\n    return;\n  }\n\n  // 2. Ensure we have an iron pickaxe\n  if (!bot.inventory.findInventoryItem(mcData.itemsByName.iron_pickaxe.id)) {\n    // Need iron ingots and sticks\n    if (countItem(bot, mcData, 'iron_ingot') < 3) {\n      bot.chat('Not enough iron ingots to craft an iron pickaxe.');\n      return;\n    }\n    if (countItem(bot, mcData, 'stick') < 2) {\n      bot.chat('Not enough sticks to craft an iron pickaxe.');\n      return;\n    }\n    bot.chat('Crafting iron pickaxe...');\n    await craftItem(bot, 'iron_pickaxe', 1);\n  }\n\n  // 3. Equip the iron pickaxe\n  const ironPick = bot.inventory.findInventoryItem(mcData.itemsByName.iron_pickaxe.id);\n  if (ironPick) await bot.equip(ironPick, 'hand');\n\n  // 4. Ensure a furnace for smelting\n  const furnace = await ensureBlockPlaced(bot, mcData, 'furnace', mcData.blocksByName.furnace.id);\n  if (!furnace) {\n    bot.chat('Cannot continue without a furnace.');\n    return;\n  }\n\n  // 5. Make sure we have fuel in the correct slot range\n  const fuelReady = await ensureFuelInSlotRange(bot, mcData, 'coal', 3);\n  if (!fuelReady) return;\n\n  // 6. Locate copper ore blocks (need 5)\n  const copperId = mcData.blocksByName.copper_ore.id;\n  let copperBlocks = bot.findBlocks({\n    matching: copperId,\n    maxDistance: 32,\n    count: 5\n  });\n  if (copperBlocks.length < 5) {\n    bot.chat('Not enough copper ore nearby, exploring...');\n    const needed = 5 - copperBlocks.length;\n    const dir = await randomDirection(Vec3);\n    const found = await exploreUntil(bot, dir, 60, () => {\n      const foundBlocks = bot.findBlocks({\n        matching: copperId,\n        maxDistance: 32,\n        count: needed\n      });\n      return foundBlocks.length >= needed ? foundBlocks : null;\n    });\n    if (found) copperBlocks = found;\n  }\n  if (copperBlocks.length < 5) {\n    bot.chat('Could not locate 5 copper ore blocks.');\n    return;\n  }\n\n  // 7. Mine exactly 5 copper ore blocks\n  bot.chat(`Mining ${copperBlocks.length} copper ore blocks...`);\n  await mineBlock(bot, 'copper_ore', 5);\n\n  // 8. Smelt all raw copper we just obtained\n  const rawCopperCount = countItem(bot, mcData, 'raw_copper');\n  if (rawCopperCount === 0) {\n    bot.chat('No raw copper was obtained after mining.');\n    return;\n  }\n\n  // Ensure fuel is still available (smeltItem will consume it)\n  if (countItem(bot, mcData, 'coal') === 0) {\n    bot.chat('Ran out of coal before smelting.');\n    return;\n  }\n  bot.chat(`Smelting ${rawCopperCount} raw copper using coal...`);\n  await smeltItem(bot, 'raw_copper', 'coal', rawCopperCount);\n\n  // 9. Verify we have at least 5 copper ingots\n  const copperIngotCount = countItem(bot, mcData, 'copper_ingot');\n  if (copperIngotCount >= 5) {\n    bot.chat(`Success! I now have ${copperIngotCount} copper ingots.`);\n  } else {\n    bot.chat(`Failed to obtain enough copper ingots. I have only ${copperIngotCount}.`);\n  }\n}", "description": "async function mineFiveCopperOre(bot) {\n    // The routine first guarantees a nearby crafting table and furnace, then checks for an iron pickaxe and crafts one if necessary before equipping it; it makes sure coal fuel occupies a slot in the allowed range; it searches for five copper ore blocks within 32 blocks, exploring in a random direction until enough are found; it mines exactly five copper ore blocks, smelts all obtained raw copper using the coal fuel, and finally confirms that at least five copper ingots are present.\n}"}, "equipIronPickaxe": {"code": "// Main function to equip an iron pickaxe\nasync function equipIronPickaxe(bot) {\n  // Load Minecraft data for the bot's version\n  const mcData = require('minecraft-data')(bot.version);\n\n  // Helper to count items (optional, not strictly needed here)\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // Check if we have an iron pickaxe\n  if (countItem('iron_pickaxe') === 0) {\n    bot.chat('I do not have an iron pickaxe in my inventory.');\n    return;\n  }\n\n  // Find the iron pickaxe item object\n  const ironPickaxe = bot.inventory.findInventoryItem(mcData.itemsByName.iron_pickaxe.id);\n  if (!ironPickaxe) {\n    bot.chat('Could not locate the iron pickaxe item.');\n    return;\n  }\n\n  // Attempt to equip it to the hand\n  try {\n    await bot.equip(ironPickaxe, 'hand');\n    bot.chat('Iron pickaxe equipped!');\n  } catch (err) {\n    bot.chat(`Failed to equip iron pickaxe: ${err.message}`);\n  }\n}", "description": "async function equipIronPickaxe(bot) {\n    // It checks whether the bot's inventory contains an iron pickaxe, exits early if it is missing, retrieves the item when present, and then attempts to equip it to the hand while handling any errors that may occur during the equip operation.\n}"}, "craftOneCopperBlock": {"code": "// main function to craft one copper block\nasync function craftOneCopperBlock(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. ensure we have enough copper ingots ----------\n  if (countItem('copper_ingot') < 9) {\n    bot.chat('Not enough copper ingots, need to smelt raw copper.');\n    // ensure we have raw copper\n    if (countItem('raw_copper') === 0) {\n      bot.chat('No raw copper to smelt. Cannot continue.');\n      return;\n    }\n\n    // ---------- 1a. ensure a furnace block exists ----------\n    let furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      // we have a furnace item in inventory?\n      if (!bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id)) {\n        bot.chat('No furnace item to place.');\n        return;\n      }\n      // place furnace at a free spot\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      bot.chat('Placing furnace...');\n      await placeItem(bot, 'furnace', placePos);\n      furnaceBlock = bot.blockAt(placePos);\n      if (!furnaceBlock || furnaceBlock.name !== 'furnace') {\n        bot.chat('Failed to place furnace.');\n        return;\n      }\n    }\n\n    // ---------- 1b. smelt raw copper until we have 9 ingots ----------\n    const needed = 9 - countItem('copper_ingot');\n    const rawCount = countItem('raw_copper');\n    const toSmelt = Math.min(needed, rawCount);\n    if (toSmelt > 0) {\n      // ensure we have some fuel (oak_planks or coal)\n      const fuelName = countItem('oak_planks') > 0 ? 'oak_planks' : 'coal';\n      if (countItem(fuelName) === 0) {\n        bot.chat(`No fuel (${fuelName}) to smelt copper.`);\n        return;\n      }\n      bot.chat(`Smelting ${toSmelt} raw copper using ${fuelName} as fuel...`);\n      await smeltItem(bot, 'raw_copper', fuelName, toSmelt);\n    }\n  }\n\n  // ---------- 2. ensure a crafting table block exists ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    // we need a crafting table item\n    if (!bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id)) {\n      // craft one (needs 4 oak planks)\n      if (countItem('oak_planks') < 4) {\n        bot.chat('Not enough oak planks to craft a crafting table.');\n        return;\n      }\n      bot.chat('Crafting a crafting table...');\n      await craftItem(bot, 'crafting_table', 1);\n    }\n\n    // place the crafting table at a free adjacent block\n    let placePos = null;\n    for (let i = 0; i < 8; i++) {\n      const offset = randomDirection();\n      const candidate = bot.entity.position.offset(offset.x, offset.y, offset.z);\n      const block = bot.blockAt(candidate);\n      const below = bot.blockAt(candidate.offset(0, -1, 0));\n      if (block && block.name === 'air' && below && below.name !== 'air') {\n        placePos = candidate;\n        break;\n      }\n    }\n\n    // if still not found, explore a bit and try again\n    if (!placePos) {\n      await exploreUntil(bot, randomDirection(), 60, () => {\n        const offset = randomDirection();\n        const cand = bot.entity.position.offset(offset.x, offset.y, offset.z);\n        const blk = bot.blockAt(cand);\n        const below = bot.blockAt(cand.offset(0, -1, 0));\n        if (blk && blk.name === 'air' && below && below.name !== 'air') {\n          placePos = cand;\n          return true;\n        }\n        return false;\n      });\n    }\n    if (!placePos) {\n      bot.chat('Could not find a free spot to place a crafting table.');\n      return;\n    }\n    bot.chat(`Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    if (!tableBlock || tableBlock.name !== 'crafting_table') {\n      bot.chat('Failed to place crafting table.');\n      return;\n    }\n  }\n\n  // ---------- 3. craft the copper block ----------\n  if (countItem('copper_ingot') < 9) {\n    bot.chat('Still not enough copper ingots after smelting.');\n    return;\n  }\n  bot.chat('Crafting 1 copper block...');\n  await craftItem(bot, 'copper_block', 1);\n\n  // ---------- 4. verify ----------\n  if (countItem('copper_block') >= 1) {\n    bot.chat('Successfully crafted a copper block!');\n  } else {\n    bot.chat('Failed to craft the copper block.');\n  }\n}", "description": "async function craftOneCopperBlock(bot) {\n    // The routine first checks that at least nine copper ingots are available, smelting raw copper in a furnace if necessary and placing a furnace when none is found; it then ensures a crafting table is present, crafting and positioning one if needed; after confirming sufficient ingots, it crafts a copper block; finally it verifies that the copper block was successfully created.\n}"}, "killOneZombie": {"code": "// main function to kill one zombie\nasync function killOneZombie(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. equip a weapon ----------\n  let weaponItem = null;\n  const preferredWeapons = ['iron_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n  for (const w of preferredWeapons) {\n    if (countItem(w) > 0) {\n      weaponItem = bot.inventory.findInventoryItem(mcData.itemsByName[w].id);\n      break;\n    }\n  }\n  if (!weaponItem) {\n    bot.chat('I have no weapon to fight the zombie.');\n    return;\n  }\n  await bot.equip(weaponItem, 'hand');\n  bot.chat(`Equipped ${weaponItem.name} for combat.`);\n\n  // ---------- 2. locate a zombie ----------\n  bot.chat('Searching for a zombie...');\n  const zombie = await exploreUntil(bot, randomDirection(), 60, () => {\n    const entity = bot.nearestEntity(e => e.name === 'zombie' && e.position.distanceTo(bot.entity.position) < 32);\n    return entity || null;\n  });\n  if (!zombie) {\n    bot.chat('Could not find any zombie nearby.');\n    return;\n  }\n  bot.chat(`Zombie found at ${zombie.position}. Engaging...`);\n\n  // ---------- 3. kill the zombie ----------\n  await killMob(bot, 'zombie', 300);\n  bot.chat('Zombie has been killed.');\n}", "description": "async function killOneZombie(bot) {\n    // The routine equips the best available pickaxe as a weapon, explores in a random horizontal direction to locate a zombie within a short range, verifies the zombie\u2019s position, and then engages and defeats it using a combat helper.\n}"}, "killOnePig": {"code": "// main function to kill one pig\nasync function killOnePig(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1. Choose a pickaxe to use as a weapon\n  const pickaxePriority = ['iron_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n  let weapon = null;\n  for (const name of pickaxePriority) {\n    if (countItem(name) > 0) {\n      weapon = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n      break;\n    }\n  }\n  if (!weapon) {\n    bot.chat('I have no pickaxe to fight the pig.');\n    return;\n  }\n\n  // 2. Equip the weapon\n  await bot.equip(weapon, 'hand');\n  bot.chat(`Equipped ${weapon.name} for combat.`);\n\n  // 3. Try to locate a pig nearby\n  let pig = bot.nearestEntity(e => e.name === 'pig' && e.position.distanceTo(bot.entity.position) < 32);\n\n  // 4. If not found, explore until a pig appears\n  if (!pig) {\n    // pick a random horizontal direction (components -1,0,1, not all zero)\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    bot.chat('No pig nearby, exploring...');\n    pig = await exploreUntil(bot, randomDir, 60, () => {\n      const e = bot.nearestEntity(ent => ent.name === 'pig' && ent.position.distanceTo(bot.entity.position) < 32);\n      return e || null;\n    });\n  }\n\n  // 5. If still not found, abort\n  if (!pig) {\n    bot.chat('Could not find any pig to kill.');\n    return;\n  }\n\n  // 6. Kill the pig\n  bot.chat(`Pig found at ${pig.position}. Attacking...`);\n  await killMob(bot, 'pig', 300);\n  bot.chat('Pig has been killed.');\n}", "description": "async function killOnePig(bot) {\n    // Selects the best available pickaxe (iron, stone, or wooden) from the inventory and equips it as a weapon, then searches for a pig within 32 blocks; if none is found, it explores in a random horizontal direction for up to 60 seconds until a pig appears, aborting if still absent, and finally attacks the pig until it is killed.\n}"}, "cookOnePorkchop": {"code": "// main function to cook a single porkchop robustly\nasync function cookOnePorkchop(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (y = 0)\n  function randomHorizontalDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. raw porkchop ----------\n  if (countItem('porkchop') < 1) {\n    bot.chat('I have no raw porkchop to cook.');\n    return;\n  }\n\n  // ---------- 2. choose fuel ----------\n  let fuelName = null;\n  if (countItem('oak_planks') > 0) fuelName = 'oak_planks';else if (countItem('stick') > 0) fuelName = 'stick';else {\n    bot.chat('I have no fuel (oak planks or sticks) to smelt the porkchop.');\n    return;\n  }\n\n  // ---------- 3. find or place a furnace ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (furnaceBlock) {\n    bot.chat('Found an existing furnace nearby.');\n  } else {\n    // need a furnace item\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('I have no furnace item to place.');\n      return;\n    }\n\n    // try a few random positions\n    let placed = false;\n    for (let attempt = 0; attempt < 5 && !placed; attempt++) {\n      const dir = randomHorizontalDirection();\n      const candidatePos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const targetBlock = bot.blockAt(candidatePos);\n      const belowBlock = bot.blockAt(candidatePos.offset(0, -1, 0));\n\n      // need air to place into and a solid block below\n      if (targetBlock && targetBlock.name === 'air' && belowBlock && belowBlock.name !== 'air') {\n        bot.chat(`Attempting to place furnace at ${candidatePos}`);\n        try {\n          await placeItem(bot, 'furnace', candidatePos);\n          const placedBlock = bot.blockAt(candidatePos);\n          if (placedBlock && placedBlock.name === 'furnace') {\n            furnaceBlock = placedBlock;\n            placed = true;\n            bot.chat('Furnace placed successfully.');\n          } else {\n            bot.chat('Furnace placement reported success but block not found.');\n          }\n        } catch (err) {\n          bot.chat(`Failed to place furnace (attempt ${attempt + 1}): ${err.message}`);\n        }\n      } else {\n        // not a valid spot, try another direction\n        continue;\n      }\n    }\n    if (!placed) {\n      bot.chat('Could not place a furnace after several attempts.');\n      return;\n    }\n  }\n\n  // ---------- 4. smelt the porkchop ----------\n  bot.chat(`Smelting 1 porkchop using ${fuelName} as fuel...`);\n  await smeltItem(bot, 'porkchop', fuelName, 1);\n\n  // ---------- 5. verify result ----------\n  if (countItem('cooked_porkchop') >= 1) {\n    bot.chat('Successfully cooked a porkchop!');\n  } else {\n    bot.chat('Cooking failed \u2013 no cooked porkchop in inventory.');\n  }\n}", "description": "async function cookOnePorkchop(bot) {\n    // The routine first verifies that the inventory holds at least one raw porkchop and a suitable fuel (oak planks or sticks), aborting if either is missing. It then looks for a furnace within 32 blocks; if none is found it attempts to place a furnace item on a solid block beneath an air space, trying up to five random horizontal positions. Once a furnace is available, it smelts a single porkchop using the chosen fuel. After smelting, it checks the inventory to ensure a cooked porkchop was produced.\n}"}, "mineFiveCoal": {"code": "// main function to mine at least five coal ore blocks\nasync function mineFiveCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (components -1,0,1, not all zero)\n  function randomHorizontalDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. ensure we have a pickaxe ----------\n  const pickaxeNames = ['iron_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const id = mcData.itemsByName[name]?.id;\n    if (id && bot.inventory.count(id) > 0) {\n      pickaxeItem = bot.inventory.findInventoryItem(id);\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    bot.chat('I have no pickaxe, trying to craft a stone pickaxe...');\n    // need 3 cobblestone + 2 sticks\n    if (countItem('cobblestone') < 3 || countItem('stick') < 2) {\n      bot.chat('Not enough resources to craft a stone pickaxe.');\n      return;\n    }\n    await craftItem(bot, 'stone_pickaxe', 1);\n    const id = mcData.itemsByName.stone_pickaxe.id;\n    pickaxeItem = bot.inventory.findInventoryItem(id);\n    if (!pickaxeItem) {\n      bot.chat('Failed to craft a stone pickaxe.');\n      return;\n    }\n  }\n\n  // equip the pickaxe\n  await bot.equip(pickaxeItem, 'hand');\n  bot.chat(`Equipped ${pickaxeItem.name} for mining.`);\n\n  // ---------- 2. locate coal ore ----------\n  let coalBlock = bot.findBlock({\n    matching: mcData.blocksByName.coal_ore.id,\n    maxDistance: 32\n  });\n  if (!coalBlock) {\n    bot.chat('No coal ore nearby, exploring...');\n    coalBlock = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.coal_ore.id,\n        maxDistance: 32\n      });\n      return blk || null;\n    });\n  }\n  if (!coalBlock) {\n    bot.chat('Could not find any coal ore after exploring.');\n    return;\n  }\n  bot.chat('Coal ore found, starting mining...');\n\n  // ---------- 3. mine at least 5 coal ore blocks ----------\n  await mineBlock(bot, 'coal_ore', 5);\n\n  // ---------- 4. verify ----------\n  const coalCount = countItem('coal');\n  if (coalCount >= 5) {\n    bot.chat(`Success! I now have ${coalCount} coal.`);\n  } else {\n    bot.chat(`Mining finished but I only have ${coalCount} coal.`);\n  }\n}", "description": "async function mineFiveCoal(bot) {\n    // The function ensures the bot has a usable pickaxe, crafting a stone pickaxe if none is present and sufficient resources exist; it then equips the selected pickaxe, searches for a coal ore block within a 32\u2011block radius and, if none is found, explores in random horizontal directions until coal ore is discovered or a timeout occurs; once coal ore is located, it mines at least five coal ore blocks; after mining, it checks the inventory to confirm that at least five coal items were obtained; the overall process guarantees the bot acquires a minimum of five coal pieces.\n}"}, "eatCookedPorkchop": {"code": "// main function to eat a cooked porkchop\nasync function eatCookedPorkchop(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ---------- 1. check we have a cooked porkchop ----------\n  if (countItem('cooked_porkchop') < 1) {\n    bot.chat('I have no cooked porkchop to eat.');\n    return;\n  }\n\n  // ---------- 2. get the item and equip it ----------\n  const porkItem = bot.inventory.findInventoryItem(mcData.itemsByName.cooked_porkchop.id);\n  if (!porkItem) {\n    bot.chat('Strange, I could not locate the cooked porkchop in my inventory.');\n    return;\n  }\n  await bot.equip(porkItem, 'hand');\n  bot.chat('Cooked porkchop equipped, preparing to eat...');\n\n  // ---------- 3. eat it ----------\n  try {\n    await bot.consume(); // right\u2011click / use action\n    bot.chat(`Ate a cooked porkchop. Hunger is now ${bot.food}.`);\n  } catch (err) {\n    bot.chat(`Failed to eat the porkchop: ${err.message}`);\n  }\n}", "description": "async function eatCookedPorkchop(bot) {\n    // It checks if a cooked porkchop is in the inventory, retrieves and equips it in the hand, attempts to consume the item, handles any errors that occur, and updates the bot\u2019s hunger level accordingly.\n}"}, "craftIronSwordRobust": {"code": "// main function: craft one iron sword robustly\nasync function craftIronSwordRobust(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // pick a random horizontal direction (y = 0)\n  const randomHorizontalDirection = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n\n  // ensure a block of given name is placed nearby; returns the placed block or null\n  async function ensurePlacedBlock(blockName) {\n    // 1) already placed?\n    const existing = bot.findBlock({\n      matching: mcData.blocksByName[blockName].id,\n      maxDistance: 32\n    });\n    if (existing) {\n      bot.chat(`${blockName} already present.`);\n      return existing;\n    }\n\n    // 2) do we have the item?\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[blockName].id);\n    if (!item) {\n      bot.chat(`I have no ${blockName} item to place.`);\n      return null;\n    }\n\n    // 3) try to find a suitable spot (up to 10 attempts)\n    for (let attempt = 0; attempt < 10; attempt++) {\n      const dir = randomHorizontalDirection();\n      const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const target = bot.blockAt(pos);\n      const below = bot.blockAt(pos.offset(0, -1, 0));\n      if (target && target.name === 'air' && below && below.name !== 'air') {\n        try {\n          await placeItem(bot, blockName, pos);\n          const placed = bot.blockAt(pos);\n          if (placed && placed.name === blockName) {\n            bot.chat(`Placed ${blockName} at ${pos}`);\n            return placed;\n          }\n        } catch (e) {\n          // ignore and try another spot\n        }\n      }\n    }\n\n    // 4) if still not placed, explore a bit more\n    const foundPos = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n      const dir = randomHorizontalDirection();\n      const p = bot.entity.position.offset(dir.x, 0, dir.z);\n      const t = bot.blockAt(p);\n      const b = bot.blockAt(p.offset(0, -1, 0));\n      if (t && t.name === 'air' && b && b.name !== 'air') {\n        return p;\n      }\n      return null;\n    });\n    if (foundPos) {\n      try {\n        await placeItem(bot, blockName, foundPos);\n        const placed = bot.blockAt(foundPos);\n        if (placed && placed.name === blockName) {\n          bot.chat(`Placed ${blockName} at ${foundPos}`);\n          return placed;\n        }\n      } catch (e) {\n        // fall through\n      }\n    }\n    bot.chat(`Failed to place a ${blockName}.`);\n    return null;\n  }\n\n  // ---------- 1. Safety: kill nearby hostile mobs ----------\n  const hostile = bot.nearestEntity(e => e.type === 'mob' && (e.name === 'creeper' || e.name === 'zombie') && e.position.distanceTo(bot.entity.position) < 10);\n  if (hostile) {\n    bot.chat(`Hostile ${hostile.name} nearby, attacking.`);\n    // use best weapon we have (iron_pickaxe > stone_pickaxe > wooden_pickaxe)\n    const weaponPriority = ['iron_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n    let weapon = null;\n    for (const w of weaponPriority) {\n      const id = mcData.itemsByName[w]?.id;\n      if (id && bot.inventory.findInventoryItem(id)) {\n        weapon = bot.inventory.findInventoryItem(id);\n        break;\n      }\n    }\n    if (weapon) await bot.equip(weapon, 'hand');\n    await killMob(bot, hostile.name, 300);\n  }\n\n  // ---------- 2. Ensure we have 2 iron ingots ----------\n  let ironIngots = countItem('iron_ingot');\n  if (ironIngots < 2) {\n    const needed = 2 - ironIngots;\n    bot.chat(`Need ${needed} more iron ingot(s).`);\n\n    // 2a) Smelt raw iron if we have it\n    const rawIron = countItem('raw_iron');\n    if (rawIron > 0) {\n      const toSmelt = Math.min(needed, rawIron);\n      // ensure furnace\n      const furnaceBlock = await ensurePlacedBlock('furnace');\n      if (!furnaceBlock) return;\n      // use coal as fuel (we have at least 1)\n      const fuelName = countItem('coal') > 0 ? 'coal' : null;\n      if (!fuelName) {\n        bot.chat('No fuel (coal) to smelt raw iron.');\n        return;\n      }\n      bot.chat(`Smelting ${toSmelt} raw iron using ${fuelName}.`);\n      await smeltItem(bot, 'raw_iron', fuelName, toSmelt);\n      ironIngots = countItem('iron_ingot');\n    }\n\n    // 2b) If still not enough, mine iron ore (optional)\n    if (ironIngots < 2) {\n      const stillNeeded = 2 - ironIngots;\n      bot.chat(`Mining ${stillNeeded} iron ore.`);\n      const oreBlock = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.iron_ore.id,\n          maxDistance: 32\n        });\n      });\n      if (!oreBlock) {\n        bot.chat('Could not locate iron ore.');\n        return;\n      }\n      await mineBlock(bot, 'iron_ore', stillNeeded);\n      // ensure furnace again (might already exist)\n      const furnaceBlock = await ensurePlacedBlock('furnace');\n      if (!furnaceBlock) return;\n      const fuelName = countItem('coal') > 0 ? 'coal' : null;\n      if (!fuelName) {\n        bot.chat('No fuel (coal) to smelt iron ore.');\n        return;\n      }\n      await smeltItem(bot, 'iron_ore', fuelName, stillNeeded);\n      ironIngots = countItem('iron_ingot');\n    }\n  }\n  if (countItem('iron_ingot') < 2) {\n    bot.chat('Failed to obtain enough iron ingots.');\n    return;\n  }\n\n  // ---------- 3. Ensure we have a crafting table ----------\n  const tableBlock = await ensurePlacedBlock('crafting_table');\n  if (!tableBlock) return; // cannot continue without a table\n\n  // ---------- 4. Ensure we have a stick ----------\n  if (countItem('stick') < 1) {\n    bot.chat('I have no stick to craft the sword.');\n    return;\n  }\n\n  // ---------- 5. Craft the iron sword ----------\n  bot.chat('Crafting iron sword...');\n  await craftItem(bot, 'iron_sword', 1);\n\n  // ---------- 6. Report result ----------\n  if (countItem('iron_sword') >= 1) {\n    bot.chat('Successfully crafted an iron sword!');\n  } else {\n    bot.chat('Crafting failed \u2013 iron sword not found.');\n  }\n}", "description": "async function craftIronSwordRobust(bot) {\n    // The routine first eliminates nearby hostile mobs, then guarantees at least two iron ingots by smelting raw iron (using a furnace and coal) or mining iron ore and smelting it; it ensures a furnace and a crafting table are placed nearby, checks for a stick, and finally crafts an iron sword, verifying afterward that the sword was successfully created.\n}"}, "equipIronSword": {"code": "// Main function: equip an iron sword (crafting it if necessary)\nasync function equipIronSword(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ---------- 1. try to equip existing sword ----------\n  if (countItem('iron_sword') > 0) {\n    const sword = bot.inventory.findInventoryItem(mcData.itemsByName.iron_sword.id);\n    if (!sword) {\n      bot.chat('Iron sword found in inventory but could not locate the item object.');\n      return;\n    }\n    try {\n      await bot.equip(sword, 'hand');\n      bot.chat('Equipped iron sword.');\n    } catch (err) {\n      bot.chat(`Failed to equip iron sword: ${err.message}`);\n    }\n    return;\n  }\n\n  // ---------- 2. sword missing \u2013 try to craft ----------\n  bot.chat('Iron sword not in inventory, attempting to craft one.');\n\n  // check required materials\n  if (countItem('iron_ingot') < 2 || countItem('stick') < 1) {\n    bot.chat('Cannot craft iron sword: need 2 iron ingots and 1 stick.');\n    return;\n  }\n\n  // ensure a crafting table is reachable\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // we have a crafting table item?\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('No crafting table in inventory to place.');\n      return;\n    }\n\n    // find a free spot adjacent to the bot\n    let placePos = null;\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    for (const dir of directions) {\n      const candidate = bot.entity.position.offset(dir.x, 0, dir.z);\n      const block = bot.blockAt(candidate);\n      const below = bot.blockAt(candidate.offset(0, -1, 0));\n      if (block && block.name === 'air' && below && below.name !== 'air') {\n        placePos = candidate;\n        break;\n      }\n    }\n    if (!placePos) {\n      bot.chat('Could not find a suitable spot to place a crafting table.');\n      return;\n    }\n    try {\n      await placeItem(bot, 'crafting_table', placePos);\n      tableBlock = bot.blockAt(placePos);\n      if (!tableBlock || tableBlock.name !== 'crafting_table') {\n        bot.chat('Failed to place crafting table.');\n        return;\n      }\n      bot.chat('Placed crafting table for crafting.');\n    } catch (err) {\n      bot.chat(`Error placing crafting table: ${err.message}`);\n      return;\n    }\n  }\n\n  // craft the iron sword\n  try {\n    await craftItem(bot, 'iron_sword', 1);\n    bot.chat('Crafted iron sword.');\n  } catch (err) {\n    bot.chat(`Failed to craft iron sword: ${err.message}`);\n    return;\n  }\n\n  // equip the newly crafted sword\n  const newSword = bot.inventory.findInventoryItem(mcData.itemsByName.iron_sword.id);\n  if (!newSword) {\n    bot.chat('Iron sword was crafted but not found in inventory.');\n    return;\n  }\n  try {\n    await bot.equip(newSword, 'hand');\n    bot.chat('Equipped the newly crafted iron sword.');\n  } catch (err) {\n    bot.chat(`Failed to equip the iron sword: ${err.message}`);\n  }\n}", "description": "async function equipIronSword(bot) {\n    // The routine first checks if an iron sword is already in the inventory and equips it; if not, it verifies that at least two iron ingots and a stick are available, locates or places a crafting table nearby, crafts the iron sword, and finally equips the newly created sword.\n}"}, "craftLightningRod": {"code": "// main function to craft 1 lightning rod\nasync function craftLightningRod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (components -1,0,1, not all zero)\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. ensure enough copper ingots ----------\n  const neededIngot = 3;\n  if (countItem('copper_ingot') < neededIngot) {\n    const missing = neededIngot - countItem('copper_ingot');\n    bot.chat(`Need ${missing} more copper ingot(s). Trying to smelt raw copper.`);\n\n    // ensure we have raw copper\n    if (countItem('raw_copper') < missing) {\n      bot.chat('Not enough raw copper to smelt. Cannot craft lightning rod.');\n      return;\n    }\n\n    // ---------- 1a. ensure a furnace block exists ----------\n    let furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n      if (!furnaceItem) {\n        bot.chat('No furnace item to place.');\n        return;\n      }\n      // find a free spot to place the furnace\n      let placed = false;\n      for (let attempt = 0; attempt < 5 && !placed; attempt++) {\n        const dir = randomDirection();\n        const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n        const target = bot.blockAt(pos);\n        const below = bot.blockAt(pos.offset(0, -1, 0));\n        if (target && target.name === 'air' && below && below.name !== 'air') {\n          try {\n            await placeItem(bot, 'furnace', pos);\n            furnaceBlock = bot.blockAt(pos);\n            if (furnaceBlock && furnaceBlock.name === 'furnace') placed = true;\n          } catch (e) {\n            // ignore and try another spot\n          }\n        }\n      }\n      if (!placed) {\n        bot.chat('Failed to place a furnace.');\n        return;\n      }\n    }\n\n    // ---------- 1b. smelt raw copper ----------\n    const fuelName = countItem('coal') > 0 ? 'coal' : countItem('oak_planks') > 0 ? 'oak_planks' : null;\n    if (!fuelName) {\n      bot.chat('No fuel (coal or oak planks) to smelt copper.');\n      return;\n    }\n    await smeltItem(bot, 'raw_copper', fuelName, missing);\n    bot.chat(`Smelted ${missing} raw copper into copper ingots.`);\n  }\n\n  // ---------- 2. ensure a crafting table block exists ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('No crafting table item to place.');\n      return;\n    }\n    // find a free spot near the bot\n    let placed = false;\n    for (let attempt = 0; attempt < 5 && !placed; attempt++) {\n      const dir = randomDirection();\n      const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const target = bot.blockAt(pos);\n      const below = bot.blockAt(pos.offset(0, -1, 0));\n      if (target && target.name === 'air' && below && below.name !== 'air') {\n        try {\n          await placeItem(bot, 'crafting_table', pos);\n          tableBlock = bot.blockAt(pos);\n          if (tableBlock && tableBlock.name === 'crafting_table') placed = true;\n        } catch (e) {\n          // ignore and try another spot\n        }\n      }\n    }\n    if (!placed) {\n      bot.chat('Failed to place a crafting table.');\n      return;\n    }\n    bot.chat('Placed a crafting table.');\n  } else {\n    bot.chat('Found an existing crafting table.');\n  }\n\n  // ---------- 3. craft the lightning rod ----------\n  bot.chat('Crafting lightning rod...');\n  await craftItem(bot, 'lightning_rod', 1);\n\n  // ---------- 4. verify ----------\n  if (countItem('lightning_rod') >= 1) {\n    bot.chat('Successfully crafted a lightning rod!');\n  } else {\n    bot.chat('Crafting failed \u2013 no lightning rod in inventory.');\n  }\n}", "description": "async function craftLightningRod(bot) {\n    // The routine first checks whether the inventory contains at least three copper ingots and, if not, smelts the required amount of raw copper using a furnace, placing a furnace block nearby if none is found; it then ensures a crafting table is present, placing one in a free spot near the bot when necessary; after the necessary materials and stations are secured, it crafts a lightning rod; finally it verifies that the lightning rod now exists in the inventory.\n}"}, "collectFiveSugarCane": {"code": "// main function to collect at least 5 sugar cane\nasync function collectFiveSugarCane(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ----- helper: pick a random horizontal direction (y = 0) -----\n  function randomHorizontalDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ----- step 1: check current amount -----\n  const TARGET = 5;\n  let have = countItem('sugar_cane');\n  if (have >= TARGET) {\n    bot.chat(`I already have ${have} sugar cane.`);\n    return;\n  }\n  bot.chat(`I have ${have} sugar cane, need ${TARGET - have} more.`);\n\n  // ----- step 2: collect until we have enough -----\n  while (have < TARGET) {\n    // how many more we need\n    const needed = TARGET - have;\n\n    // try to find a sugar cane block nearby\n    const block = bot.findBlock({\n      matching: mcData.blocksByName.sugar_cane.id,\n      maxDistance: 32\n    });\n    if (block) {\n      // harvest up to the amount we still need (or all found blocks)\n      const toMine = Math.min(needed, 1); // mineBlock can handle count >1, but we limit to needed\n      bot.chat(`Found sugar cane at ${block.position}. Mining ${toMine} block(s).`);\n      await mineBlock(bot, 'sugar_cane', toMine);\n    } else {\n      // no block nearby \u2192 explore until we see one\n      bot.chat('No sugar cane nearby, exploring...');\n      const found = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n        const b = bot.findBlock({\n          matching: mcData.blocksByName.sugar_cane.id,\n          maxDistance: 32\n        });\n        return b || null;\n      });\n      if (!found) {\n        bot.chat('Exploration timed out without finding sugar cane. Stopping.');\n        break;\n      }\n      // loop will try again and now the block should be found\n      continue;\n    }\n\n    // re\u2011count after mining\n    have = countItem('sugar_cane');\n    bot.chat(`Now have ${have}/${TARGET} sugar cane.`);\n  }\n  if (have >= TARGET) {\n    bot.chat(`\u2705 Collected ${have} sugar cane (target ${TARGET}).`);\n  } else {\n    bot.chat(`\u274c Could not reach the target. I have ${have} sugar cane.`);\n  }\n}", "description": "async function collectFiveSugarCane(bot) {\n    // It checks the bot\u2019s inventory for sugar cane and, if fewer than five are present, repeatedly searches for nearby sugar cane blocks to mine the required amount, exploring in random horizontal directions when none are found and stopping when the target is reached or exploration times out.\n}"}, "craftOneShieldRobust": {"code": "// main function to craft one shield (robust version)\nasync function craftOneShieldRobust(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. ensure a crafting table ----------\n  async function ensureCraftingTable() {\n    let table = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (table) return table;\n    const ctItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!ctItem) {\n      bot.chat('\u274c No crafting table item in inventory.');\n      return null;\n    }\n    for (let attempt = 0; attempt < 8; attempt++) {\n      const dir = randomDirection();\n      const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const block = bot.blockAt(pos);\n      const below = bot.blockAt(pos.offset(0, -1, 0));\n      if (block && block.name === 'air' && below && below.name !== 'air') {\n        bot.chat(`Placing crafting table at ${pos}`);\n        await placeItem(bot, 'crafting_table', pos);\n        const placed = bot.blockAt(pos);\n        if (placed && placed.name === 'crafting_table') return placed;\n      }\n    }\n    bot.chat('\u274c Could not find a place for the crafting table.');\n    return null;\n  }\n\n  // ---------- 2. ensure enough planks of a specific type ----------\n  async function ensurePlanksOfType(plankName, needed) {\n    const current = countItem(plankName);\n    if (current >= needed) return true;\n    const missing = needed - current;\n\n    // Determine the corresponding log name (e.g., oak_planks -> oak_log)\n    const logName = plankName.replace('_planks', '_log');\n\n    // Each log gives 4 planks\n    const logsNeeded = Math.ceil(missing / 4);\n    bot.chat(`Need ${missing} more ${plankName}. Mining ${logsNeeded} ${logName}...`);\n\n    // Mine the required logs\n    await mineBlock(bot, logName, logsNeeded);\n\n    // Craft the planks from the mined logs\n    bot.chat(`Crafting ${logsNeeded} ${logName} \u2192 ${plankName}...`);\n    await craftItem(bot, plankName, logsNeeded);\n    return countItem(plankName) >= needed;\n  }\n\n  // ---------- 3. pick the plank type that we have the most ----------\n  function selectBestPlankType() {\n    const plankTypes = ['oak_planks', 'spruce_planks', 'birch_planks', 'jungle_planks', 'acacia_planks', 'dark_oak_planks'];\n    let best = null;\n    let bestCount = -1;\n    for (const p of plankTypes) {\n      const cnt = countItem(p);\n      if (cnt > bestCount) {\n        bestCount = cnt;\n        best = p;\n      }\n    }\n    return best;\n  }\n\n  // ---------- 4. ensure we have an iron ingot ----------\n  async function ensureIronIngot() {\n    if (countItem('iron_ingot') >= 1) return true;\n\n    // Try to find raw iron first\n    if (countItem('raw_iron') > 0) {\n      const furnace = await ensureFurnace();\n      if (!furnace) return false;\n      const fuel = countItem('coal') > 0 ? 'coal' : null;\n      if (!fuel) {\n        bot.chat('\u274c No coal for furnace fuel.');\n        return false;\n      }\n      await smeltItem(bot, 'raw_iron', fuel, 1);\n      return countItem('iron_ingot') >= 1;\n    }\n\n    // Search for iron ore\n    bot.chat('Searching for iron ore...');\n    const oreBlock = await exploreUntil(bot, randomDirection(), 60, () => {\n      return bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      }) || null;\n    });\n    if (!oreBlock) {\n      bot.chat('\u274c No iron ore found.');\n      return false;\n    }\n    bot.chat('Mining iron ore...');\n    await mineBlock(bot, 'iron_ore', 1);\n    const furnace = await ensureFurnace();\n    if (!furnace) return false;\n    const fuel = countItem('coal') > 0 ? 'coal' : null;\n    if (!fuel) {\n      bot.chat('\u274c No coal for furnace fuel.');\n      return false;\n    }\n    await smeltItem(bot, 'iron_ore', fuel, 1);\n    return countItem('iron_ingot') >= 1;\n  }\n\n  // ---------- 5. ensure a furnace (needed for smelting) ----------\n  async function ensureFurnace() {\n    let furnace = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (furnace) return furnace;\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c No furnace item in inventory.');\n      return null;\n    }\n    for (let attempt = 0; attempt < 8; attempt++) {\n      const dir = randomDirection();\n      const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const block = bot.blockAt(pos);\n      const below = bot.blockAt(pos.offset(0, -1, 0));\n      if (block && block.name === 'air' && below && below.name !== 'air') {\n        bot.chat(`Placing furnace at ${pos}`);\n        await placeItem(bot, 'furnace', pos);\n        const placed = bot.blockAt(pos);\n        if (placed && placed.name === 'furnace') return placed;\n      }\n    }\n    bot.chat('\u274c Could not place a furnace.');\n    return null;\n  }\n\n  // ---------- Main workflow ----------\n  bot.chat('\ud83d\udd27 Starting robust shield crafting process...');\n\n  // 1. Crafting table\n  const table = await ensureCraftingTable();\n  if (!table) return;\n\n  // 2. Choose plank type and ensure we have 6 of that type\n  const bestPlank = selectBestPlankType();\n  if (!bestPlank) {\n    bot.chat('\u274c No planks in inventory at all.');\n    return;\n  }\n  bot.chat(`Using ${bestPlank} for the shield recipe.`);\n  const havePlanks = await ensurePlanksOfType(bestPlank, 6);\n  if (!havePlanks) {\n    bot.chat('\u274c Could not obtain enough planks.');\n    return;\n  }\n\n  // 3. Ensure iron ingot\n  const haveIron = await ensureIronIngot();\n  if (!haveIron) {\n    bot.chat('\u274c Could not obtain an iron ingot.');\n    return;\n  }\n\n  // 4. Craft the shield\n  bot.chat('Crafting the shield...');\n  try {\n    await craftItem(bot, 'shield', 1);\n  } catch (err) {\n    bot.chat(`\u274c Failed to craft shield: ${err.message}`);\n    return;\n  }\n\n  // 5. Verify result\n  if (countItem('shield') >= 1) {\n    bot.chat('\u2705 Shield crafted successfully!');\n  } else {\n    bot.chat('\u274c Shield not found in inventory after crafting.');\n  }\n}", "description": "async function craftOneShieldRobust(bot) {\n    // The routine ensures a crafting table is present, selects the plank type with the most inventory, gathers enough planks by mining logs and crafting them if necessary, obtains an iron ingot by locating raw iron or ore and smelting it using a furnace (placing one if needed), then crafts a shield and verifies its presence in the inventory.\n}"}, "cookThreePorkchops": {"code": "// ------------------------------------------------------------\n// Helper functions (reuse when possible)\n// ------------------------------------------------------------\nasync function countItem(bot, mcData, name) {\n  const id = mcData.itemsByName[name]?.id;\n  return id ? bot.inventory.count(id) : 0;\n}\n\nfunction randomHorizontalDirection(Vec3) {\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n// ------------------------------------------------------------\n// 1) Ensure a furnace exists (place one if necessary)\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// 1) Ensure a furnace exists (place one if necessary)\n// ------------------------------------------------------------\nasync function ensureFurnace(bot, mcData, Vec3) {\n  // look for an existing furnace\n  let furnace = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (furnace) {\n    bot.chat('Found a furnace nearby.');\n    return furnace;\n  }\n\n  // need to place a furnace\n  const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n  if (!furnaceItem) {\n    bot.chat('I have no furnace item to place.');\n    return null;\n  }\n\n  // try adjacent positions for a valid placement spot\n  const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  let placePos = null;\n  for (const off of offsets) {\n    const cand = bot.entity.position.offset(off.x, off.y, off.z);\n    const target = bot.blockAt(cand);\n    const below = bot.blockAt(cand.offset(0, -1, 0));\n    if (target && target.name === 'air' && below && below.name !== 'air') {\n      placePos = cand;\n      break;\n    }\n  }\n\n  // if not found locally, explore a bit\n  if (!placePos) {\n    await exploreUntil(bot, randomHorizontalDirection(Vec3), 60, () => {\n      for (const off of offsets) {\n        const cand = bot.entity.position.offset(off.x, off.y, off.z);\n        const target = bot.blockAt(cand);\n        const below = bot.blockAt(cand.offset(0, -1, 0));\n        if (target && target.name === 'air' && below && below.name !== 'air') {\n          placePos = cand;\n          return true;\n        }\n      }\n      return false;\n    });\n  }\n  if (!placePos) {\n    bot.chat('Could not find a suitable spot to place a furnace.');\n    return null;\n  }\n  bot.chat(`Placing furnace at ${placePos}`);\n  await placeItem(bot, 'furnace', placePos);\n  // give the world a tick so the block state updates\n  await bot.waitForTicks(1);\n  furnace = bot.blockAt(placePos);\n  if (!furnace || furnace.name !== 'furnace') {\n    bot.chat('Failed to place the furnace.');\n    return null;\n  }\n  bot.chat('Furnace placed successfully.');\n  return furnace;\n}\n\n// ------------------------------------------------------------\n// 2) Ensure we have at least one fuel item\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// 2) Ensure we have at least one fuel item\n// ------------------------------------------------------------\nasync function ensureFuel(bot, mcData) {\n  const fuelPriority = ['coal', 'oak_planks', 'stick'];\n  // already have fuel?\n  if (fuelPriority.some(f => bot.inventory.findInventoryItem(mcData.itemsByName[f].id))) {\n    return true;\n  }\n\n  // try to craft planks from logs\n  if ((await countItem(bot, mcData, 'oak_log')) > 0) {\n    bot.chat('Crafting oak planks from oak logs for fuel.');\n    await craftItem(bot, 'oak_planks', 4); // 1 log \u2192 4 planks\n    // after crafting we should have planks\n    if (fuelPriority.some(f => bot.inventory.findInventoryItem(mcData.itemsByName[f].id))) {\n      return true;\n    }\n  }\n  bot.chat('No fuel available and cannot craft more.');\n  return false;\n}\n\n// ------------------------------------------------------------\n// 3) Obtain enough raw porkchops\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// 3) Obtain enough raw porkchops\n// ------------------------------------------------------------\nasync function obtainRawPorkchops(bot, mcData, Vec3, target) {\n  while ((await countItem(bot, mcData, 'porkchop')) < target) {\n    // find a pig nearby\n    let pig = bot.nearestEntity(e => e.name === 'pig' && e.position.distanceTo(bot.entity.position) < 32);\n    if (!pig) {\n      bot.chat('No pig nearby, exploring...');\n      pig = await exploreUntil(bot, randomHorizontalDirection(Vec3), 60, () => {\n        const p = bot.nearestEntity(e => e.name === 'pig' && e.position.distanceTo(bot.entity.position) < 32);\n        return p || null;\n      });\n    }\n    if (!pig) {\n      bot.chat('Could not find any pig to kill.');\n      return false;\n    }\n    bot.chat(`Found pig at ${pig.position}, attacking...`);\n    await killMob(bot, 'pig', 300);\n    // give a short pause for drops to be picked up\n    await bot.waitForTicks(20);\n  }\n  return true;\n}\n\n// ------------------------------------------------------------\n// Main function: cook three porkchops\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// Main function: cook three porkchops\n// ------------------------------------------------------------\nasync function cookThreePorkchops(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1) Make sure a furnace is available\n  const furnace = await ensureFurnace(bot, mcData, Vec3);\n  if (!furnace) return; // cannot continue without a furnace\n\n  // 2) Make sure we have fuel\n  if (!(await ensureFuel(bot, mcData))) return;\n\n  // 3) Ensure we have at least 3 raw porkchops\n  if (!(await obtainRawPorkchops(bot, mcData, Vec3, 3))) return;\n\n  // 4) Determine how many cooked porkchops are still needed\n  const cookedNow = await countItem(bot, mcData, 'cooked_porkchop');\n  const needed = Math.max(0, 3 - cookedNow);\n  if (needed === 0) {\n    bot.chat('Already have three cooked porkchops.');\n    return;\n  }\n  bot.chat(`Need to cook ${needed} porkchop(s).`);\n\n  // 5) Smelt the required amount, checking fuel each iteration\n  const fuelPriority = ['coal', 'oak_planks', 'stick'];\n  for (let i = 0; i < needed; i++) {\n    // re\u2011check fuel before each smelt\n    let fuelName = null;\n    for (const f of fuelPriority) {\n      if ((await countItem(bot, mcData, f)) > 0) {\n        fuelName = f;\n        break;\n      }\n    }\n    if (!fuelName) {\n      // try to craft more planks if possible\n      if (!(await ensureFuel(bot, mcData))) {\n        bot.chat('Ran out of fuel while cooking.');\n        return;\n      }\n      // re\u2011determine fuel after crafting\n      for (const f of fuelPriority) {\n        if ((await countItem(bot, mcData, f)) > 0) {\n          fuelName = f;\n          break;\n        }\n      }\n    }\n    bot.chat(`Smelting porkchop ${i + 1}/${needed} using ${fuelName}.`);\n    await smeltItem(bot, 'porkchop', fuelName, 1);\n  }\n\n  // 6) Final verification\n  if ((await countItem(bot, mcData, 'cooked_porkchop')) >= 3) {\n    bot.chat('Successfully cooked three porkchops!');\n  } else {\n    bot.chat('Failed to obtain three cooked porkchops.');\n  }\n}", "description": "async function cookThreePorkchops(bot) {\n    // The routine first ensures a furnace is available and that the bot has at least one fuel item, then gathers enough raw porkchops to reach a target of three. It checks how many cooked porkchops are already in the inventory, calculates the shortfall, and smelts the required number one by one, crafting additional fuel if necessary. Finally it verifies that the inventory now contains at least three cooked porkchops.\n}"}, "placeChestNearBot": {"code": "// main function to place a chest near the bot\nasync function placeChestNearBot(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- 1. check if a chest already exists ----------\n  const existingChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 32\n  });\n  if (existingChest) {\n    bot.chat('Chest already placed nearby, task complete.');\n    return;\n  }\n\n  // ---------- 2. ensure we have a chest item ----------\n  const chestItem = bot.inventory.findInventoryItem(mcData.itemsByName.chest.id);\n  if (!chestItem) {\n    bot.chat('I have no chest in my inventory, cannot place one.');\n    return;\n  }\n\n  // helper: pick a random horizontal direction (y = 0)\n  function randomHorizontalDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 3. try to find a suitable spot nearby ----------\n  let placePos = null;\n  for (let attempt = 0; attempt < 8 && !placePos; attempt++) {\n    const dir = randomHorizontalDirection();\n    const candidate = bot.entity.position.offset(dir.x, 0, dir.z);\n    const block = bot.blockAt(candidate);\n    const below = bot.blockAt(candidate.offset(0, -1, 0));\n    if (block && block.name === 'air' && below && below.name !== 'air') {\n      placePos = candidate;\n    }\n  }\n\n  // ---------- 4. if not found, explore until a spot appears ----------\n  if (!placePos) {\n    bot.chat('Looking for a free spot to place the chest...');\n    placePos = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n      const dir = randomHorizontalDirection();\n      const cand = bot.entity.position.offset(dir.x, 0, dir.z);\n      const blk = bot.blockAt(cand);\n      const below = bot.blockAt(cand.offset(0, -1, 0));\n      if (blk && blk.name === 'air' && below && below.name !== 'air') {\n        return cand; // stop exploration, return position\n      }\n      return null;\n    });\n    if (!placePos) {\n      bot.chat('Could not find a suitable place for the chest.');\n      return;\n    }\n  }\n\n  // ---------- 5. place the chest ----------\n  try {\n    bot.chat(`Placing chest at ${placePos}`);\n    await placeItem(bot, 'chest', placePos);\n  } catch (err) {\n    bot.chat(`Failed to place chest: ${err.message}`);\n    return;\n  }\n\n  // ---------- 6. verify ----------\n  const placedChest = bot.blockAt(placePos);\n  if (placedChest && placedChest.name === 'chest') {\n    bot.chat('Chest placed successfully! Task complete.');\n  } else {\n    bot.chat('Chest placement attempted but block not found.');\n  }\n}", "description": "async function placeChestNearBot(bot) {\n    // The function tries to place a chest close to the bot by first detecting any existing chest within a short distance, then verifying that the bot holds a chest item, then searching nearby air blocks with solid ground using random horizontal directions, and if none are found it explores until a suitable spot appears; once a position is identified it places the chest there and finally checks that the chest block was successfully created.\n}"}, "smeltEightRawIron": {"code": "// main function\nasync function smeltEightRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // pick a random horizontal direction (components -1,0,1, not all zero)\n  function randomHorizontalDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. ensure furnace ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // we have furnace items in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c No furnace item to place.');\n      return;\n    }\n    // place furnace one block ahead of the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing a furnace...');\n    try {\n      await placeItem(bot, 'furnace', placePos);\n      furnaceBlock = bot.blockAt(placePos);\n    } catch (err) {\n      bot.chat(`\u274c Failed to place furnace: ${err.message}`);\n      return;\n    }\n  }\n  bot.chat('\u2705 Furnace ready.');\n\n  // ---------- 2. check raw iron ----------\n  if (countItem('raw_iron') < 8) {\n    bot.chat('\u274c Not enough raw iron (need 8).');\n    return;\n  }\n\n  // ---------- 3. ensure enough coal ----------\n  const requiredCoal = 8;\n  let coalCount = countItem('coal');\n  if (coalCount < requiredCoal) {\n    const need = requiredCoal - coalCount;\n    bot.chat(`Need ${need} more coal. Mining coal ore...`);\n    // try to mine directly\n    await mineBlock(bot, 'coal_ore', need);\n    // re\u2011count\n    coalCount = countItem('coal');\n    if (coalCount < requiredCoal) {\n      // explore until we find more coal ore\n      const missing = requiredCoal - coalCount;\n      bot.chat(`Still missing ${missing} coal, exploring for more coal ore...`);\n      const found = await exploreUntil(bot, randomHorizontalDirection(), 60, () => {\n        const ore = bot.findBlock({\n          matching: mcData.blocksByName.coal_ore.id,\n          maxDistance: 32\n        });\n        return ore ? ore : null;\n      });\n      if (found) {\n        await mineBlock(bot, 'coal_ore', missing);\n        coalCount = countItem('coal');\n      }\n    }\n    if (coalCount < requiredCoal) {\n      bot.chat('\u274c Could not obtain enough coal.');\n      return;\n    }\n  }\n  bot.chat(`\u2705 Have ${coalCount} coal (need ${requiredCoal}).`);\n\n  // ---------- 4. smelt 8 raw iron ----------\n  bot.chat('Smelting 8 raw iron...');\n  await smeltItem(bot, 'raw_iron', 'coal', 8);\n\n  // ---------- 5. verification ----------\n  const ironIngotCount = countItem('iron_ingot');\n  if (ironIngotCount >= 8) {\n    bot.chat(`\u2705 Successfully smelted 8 iron ingots! (total iron ingots: ${ironIngotCount})`);\n  } else {\n    bot.chat('\u274c Smelting failed \u2013 not enough iron ingots in inventory.');\n  }\n}", "description": "async function smeltEightRawIron(bot) {\n    // The function ensures a furnace is present (placing one if missing), verifies the inventory contains at least eight raw iron, gathers enough coal by mining and, if necessary, exploring for more ore, smelts eight raw iron into iron ingots using the furnace, and finally confirms that at least eight iron ingots were produced.\n}"}, "craftOneIronChestplate": {"code": "// main function to craft one iron chestplate\nasync function craftOneIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helpers -----\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // random horizontal direction for exploration\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ----- 1. Ensure enough iron ingots -----\n  if (countItem('iron_ingot') < 5) {\n    const needed = 5 - countItem('iron_ingot');\n    bot.chat(`Need ${needed} more iron ingots, smelting raw iron...`);\n    // smelt raw iron using any fuel we have (coal or stick)\n    const fuel = countItem('coal') > 0 ? 'coal' : countItem('stick') > 0 ? 'stick' : null;\n    if (!fuel) {\n      bot.chat('No fuel available to smelt iron.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', fuel, needed);\n  }\n\n  // ----- 2. Ensure we have 4 wooden planks (any type) -----\n  const plankNames = ['oak_planks', 'spruce_planks', 'birch_planks', 'jungle_planks', 'acacia_planks', 'dark_oak_planks', 'crimson_planks', 'warped_planks'];\n  let totalPlanks = 0;\n  for (const name of plankNames) totalPlanks += countItem(name);\n  if (totalPlanks < 4) {\n    // need to obtain more logs and craft planks\n    bot.chat('Not enough planks, mining a log to craft more planks...');\n    // try to find any log block nearby\n    const logBlock = bot.findBlock({\n      matching: b => b.name.endsWith('_log'),\n      maxDistance: 32\n    });\n    if (!logBlock) {\n      // explore until a log is found\n      await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: b => b.name.endsWith('_log'),\n          maxDistance: 32\n        });\n        return blk ? blk : null;\n      });\n    }\n    // mine one log of any type\n    const logName = bot.findBlock({\n      matching: b => b.name.endsWith('_log'),\n      maxDistance: 32\n    })?.name;\n    if (logName) {\n      await mineBlock(bot, logName, 1);\n    } else {\n      bot.chat('Failed to locate a log to mine.');\n      return;\n    }\n    // craft planks (4 planks per log)\n    const anyPlank = plankNames.find(n => countItem(n) > 0) || 'oak_planks';\n    await craftItem(bot, anyPlank, 1); // this will give 4 planks\n  }\n\n  // ----- 3. Ensure we have a crafting table item -----\n  if (countItem('crafting_table') === 0) {\n    bot.chat('No crafting table in inventory, crafting one from 4 planks...');\n    // find any 4 planks in inventory\n    const plankId = plankNames.map(n => mcData.itemsByName[n]?.id).find(id => id && bot.inventory.count(id) >= 4);\n    if (!plankId) {\n      bot.chat('Unable to find 4 planks to craft a crafting table.');\n      return;\n    }\n    // Use the 2x2 inventory crafting grid (no table needed)\n    const craftingTableItem = mcData.itemsByName.crafting_table.id;\n    const recipe = bot.recipesFor(craftingTableItem, null, 1, null)[0];\n    if (!recipe) {\n      bot.chat('Could not find a recipe for crafting table.');\n      return;\n    }\n    await bot.craft(recipe, 1, null); // allowed for this special case\n    bot.chat('Crafted a crafting table.');\n  }\n\n  // ----- 4. Place the crafting table near the bot -----\n  const craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    // place it at a free air block adjacent to the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat(`Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n  } else {\n    bot.chat('Crafting table already placed nearby.');\n  }\n\n  // ----- 5. Craft the iron chestplate -----\n  bot.chat('Crafting iron chestplate...');\n  await craftItem(bot, 'iron_chestplate', 1);\n  if (countItem('iron_chestplate') >= 1) {\n    bot.chat('Successfully crafted an iron chestplate!');\n  } else {\n    bot.chat('Failed to craft the iron chestplate.');\n  }\n}", "description": "async function craftOneIronChestplate(bot) {\n    // The function ensures the bot has at least five iron ingots, smelting raw iron with available fuel if needed, then guarantees four wooden planks by mining a log and converting it when necessary, checks for a crafting table and crafts one from planks if missing, places a crafting table nearby if none is present, and finally crafts an iron chestplate and verifies its successful creation.\n}"}, "equipIronChestplate": {"code": "// main function to equip an iron chestplate\nasync function equipIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // Find or place a block (furnace or crafting table)\n  async function ensureBlock(name) {\n    const blockId = mcData.blocksByName[name].id;\n    let block = bot.findBlock({\n      matching: blockId,\n      maxDistance: 32\n    });\n    if (block) return block;\n\n    // need the item in inventory\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    if (!item) {\n      bot.chat(`I have no ${name} item to place.`);\n      return null;\n    }\n\n    // try a few adjacent positions\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    for (const dir of directions) {\n      const pos = bot.entity.position.offset(dir.x, 0, dir.z);\n      const below = bot.blockAt(pos.offset(0, -1, 0));\n      const target = bot.blockAt(pos);\n      if (target && target.name === 'air' && below && below.name !== 'air') {\n        try {\n          await placeItem(bot, name, pos);\n          const placed = bot.blockAt(pos);\n          if (placed && placed.name === name) return placed;\n        } catch (e) {\n          // ignore and try next spot\n        }\n      }\n    }\n    bot.chat(`Failed to place a ${name}.`);\n    return null;\n  }\n\n  // ---------- 1. try to equip if already have ----------\n  if (countItem('iron_chestplate') > 0) {\n    const chestplateItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_chestplate.id);\n    await bot.equip(chestplateItem, 'torso');\n    bot.chat('Equipped iron chestplate from inventory.');\n    return;\n  }\n\n  // ---------- 2. try to get from chest ----------\n  const chestPos = new Vec3(377, 43, 903);\n  bot.chat('Looking for iron chestplate in the nearby chest...');\n  await getItemFromChest(bot, chestPos, {\n    iron_chestplate: 1\n  });\n  if (countItem('iron_chestplate') > 0) {\n    const chestplateItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_chestplate.id);\n    await bot.equip(chestplateItem, 'torso');\n    bot.chat('Equipped iron chestplate after retrieving it from the chest.');\n    return;\n  }\n\n  // ---------- 3. need to craft the chestplate ----------\n  bot.chat('Iron chestplate not found, will craft one.');\n\n  // 3a. ensure we have at least 5 iron ingots\n  const neededIngot = 5;\n  let ingotCount = countItem('iron_ingot');\n  if (ingotCount < neededIngot) {\n    const toSmelt = neededIngot - ingotCount;\n    bot.chat(`Need ${toSmelt} more iron ingots, smelting raw iron...`);\n\n    // ensure a furnace exists\n    const furnaceBlock = await ensureBlock('furnace');\n    if (!furnaceBlock) {\n      bot.chat('Cannot continue without a furnace.');\n      return;\n    }\n\n    // smelt raw iron using coal as fuel\n    await smeltItem(bot, 'raw_iron', 'coal', toSmelt);\n    ingotCount = countItem('iron_ingot');\n    if (ingotCount < neededIngot) {\n      bot.chat('Failed to obtain enough iron ingots.');\n      return;\n    }\n  }\n\n  // 3b. ensure a crafting table exists\n  const tableBlock = await ensureBlock('crafting_table');\n  if (!tableBlock) {\n    bot.chat('Cannot continue without a crafting table.');\n    return;\n  }\n\n  // 3c. craft the chestplate\n  bot.chat('Crafting iron chestplate...');\n  await craftItem(bot, 'iron_chestplate', 1);\n\n  // ---------- 4. equip the newly crafted chestplate ----------\n  if (countItem('iron_chestplate') > 0) {\n    const chestplateItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_chestplate.id);\n    await bot.equip(chestplateItem, 'torso');\n    bot.chat('Successfully crafted and equipped iron chestplate.');\n  } else {\n    bot.chat('Failed to craft iron chestplate.');\n  }\n}", "description": "async function equipIronChestplate(bot) {\n    // The routine first checks the inventory for an iron chestplate and equips it if present; if not, it attempts to retrieve one from a specified chest location; should the chestplate still be missing, it ensures sufficient iron ingots by smelting raw iron using a furnace, creating the furnace if necessary; it also guarantees a crafting table is available before crafting the iron chestplate; finally, it equips the newly crafted chestplate; it aborts if essential blocks cannot be placed.\n}"}, "craftIronHelmet": {"code": "// main function to craft one iron helmet\nasync function craftIronHelmet(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ---------- 1. ensure a furnace is placed ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // need a furnace item in inventory\n    if (countItem('furnace') === 0) {\n      bot.chat('I have no furnace item to place.');\n      return;\n    }\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing a furnace...');\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    bot.chat('Furnace placed.');\n  } else {\n    bot.chat('Furnace already nearby.');\n  }\n\n  // ---------- 2. smelt raw iron into iron ingots ----------\n  const neededIngots = 5;\n  if (countItem('iron_ingot') < neededIngots) {\n    const rawIronCount = countItem('raw_iron');\n    const coalCount = countItem('coal');\n    const toSmelt = Math.min(neededIngots - countItem('iron_ingot'), rawIronCount);\n    if (toSmelt <= 0) {\n      bot.chat('Not enough raw iron to smelt.');\n      return;\n    }\n    if (coalCount < toSmelt) {\n      bot.chat('Not enough coal for smelting.');\n      return;\n    }\n    bot.chat(`Smelting ${toSmelt} raw iron into iron ingots...`);\n    await smeltItem(bot, 'raw_iron', 'coal', toSmelt);\n    bot.chat('Smelting completed.');\n  } else {\n    bot.chat('Enough iron ingots already in inventory.');\n  }\n\n  // ---------- 3. ensure a crafting table is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    if (countItem('crafting_table') === 0) {\n      bot.chat('I have no crafting table item to place.');\n      return;\n    }\n    const placePos = bot.entity.position.offset(2, 0, 0);\n    bot.chat('Placing a crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    bot.chat('Crafting table placed.');\n  } else {\n    bot.chat('Crafting table already nearby.');\n  }\n\n  // ---------- 4. craft the iron helmet ----------\n  if (countItem('iron_ingot') < neededIngots) {\n    bot.chat('Still not enough iron ingots after smelting.');\n    return;\n  }\n  bot.chat('Crafting an iron helmet...');\n  await craftItem(bot, 'iron_helmet', 1);\n  if (countItem('iron_helmet') >= 1) {\n    bot.chat('Successfully crafted an iron helmet!');\n  } else {\n    bot.chat('Failed to craft the iron helmet.');\n  }\n}", "description": "async function craftIronHelmet(bot) {\n    // The function first verifies that a furnace is nearby and places one if absent, then smelts raw iron with coal until at least five iron ingots are in the inventory, ensures a crafting table is present or places it, checks again for sufficient ingots, and finally crafts an iron helmet, reporting whether the crafting succeeded.\n}"}, "smeltElevenRawIron": {"code": "// main function to smelt exactly 11 raw iron\nasync function smeltElevenRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper utilities ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n  function randomDirection() {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  }\n\n  // ---------- 1. make sure a furnace block exists ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 5\n  });\n  if (!furnaceBlock) {\n    if (countItem('furnace') === 0) {\n      bot.chat('I have no furnace item to place.');\n      return;\n    }\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    bot.chat('Placing a furnace...');\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    bot.chat('Furnace placed.');\n  } else {\n    bot.chat('Furnace already placed nearby.');\n  }\n\n  // ---------- 2. ensure we have at least 11 fuel items ----------\n  const fuelNames = ['coal', 'stick', 'oak_log'];\n  function totalFuel() {\n    return fuelNames.reduce((sum, n) => sum + countItem(n), 0);\n  }\n  while (totalFuel() < 11) {\n    // try to craft sticks from planks or logs\n    if (countItem('oak_log') > 0) {\n      // craft planks first\n      bot.chat('Crafting oak planks from oak log...');\n      await craftItem(bot, 'oak_planks', 1); // 1 recipe = 4 planks\n    }\n    if (countItem('oak_planks') >= 2) {\n      bot.chat('Crafting sticks from oak planks...');\n      await craftItem(bot, 'stick', 1); // 1 recipe = 4 sticks\n    } else {\n      // no logs/planks left, cannot make more fuel\n      bot.chat('Not enough material to craft more fuel.');\n      break;\n    }\n  }\n  if (totalFuel() < 11) {\n    bot.chat(`Only have ${totalFuel()} fuel items, need 11. Aborting.`);\n    return;\n  }\n\n  // ---------- 3. smelt 11 raw iron ----------\n  const needed = 11;\n  let smelted = 0;\n  while (smelted < needed) {\n    if (countItem('raw_iron') === 0) {\n      bot.chat('Ran out of raw iron before finishing.');\n      break;\n    }\n\n    // pick a fuel that we still have\n    let fuelName = null;\n    for (const f of fuelNames) {\n      if (countItem(f) > 0) {\n        fuelName = f;\n        break;\n      }\n    }\n    if (!fuelName) {\n      bot.chat('Out of fuel while smelting.');\n      break;\n    }\n    bot.chat(`Smelting raw iron #${smelted + 1} using ${fuelName}...`);\n    await smeltItem(bot, 'raw_iron', fuelName, 1);\n    smelted++;\n  }\n\n  // ---------- 4. report result ----------\n  const ingotCount = countItem('iron_ingot');\n  if (ingotCount >= needed) {\n    bot.chat(`Successfully smelted ${needed} iron ingots (now have ${ingotCount}).`);\n  } else {\n    bot.chat(`Finished smelting loop but only have ${ingotCount} iron ingots.`);\n  }\n}", "description": "async function smeltElevenRawIron(bot) {\n    // The routine first checks for a nearby furnace and places one if none is found. It then guarantees that at least eleven fuel items are available, crafting sticks from logs or planks when necessary. After securing fuel, it repeatedly smelts raw iron one piece at a time until eleven ingots are produced or resources run out. Fuel selection prefers any available fuel type among coal, sticks, or oak logs. The loop stops if raw iron or fuel is exhausted. Finally, it verifies the number of iron ingots obtained and reports whether the target of eleven was reached.\n}"}, "craftIronLeggings": {"code": "// main function to craft iron leggings (ensuring enough iron ingots)\nasync function craftIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1\ufe0f\u20e3 Ensure we have at least 7 iron ingots\n  const REQUIRED_INGOTS = 7;\n  let ingotCount = countItem('iron_ingot');\n  if (ingotCount < REQUIRED_INGOTS) {\n    const need = REQUIRED_INGOTS - ingotCount;\n    bot.chat(`Need ${need} more iron ingot(s).`);\n\n    // 2\ufe0f\u20e3 Check we have enough raw iron\n    const rawIronCount = countItem('raw_iron');\n    if (rawIronCount < need) {\n      bot.chat(`Not enough raw iron (${rawIronCount}) to smelt ${need} ingot(s).`);\n      return;\n    }\n\n    // 3\ufe0f\u20e3 Choose fuel (coal preferred)\n    let fuelName = null;\n    if (countItem('coal') > 0) fuelName = 'coal';else if (countItem('stick') > 0) fuelName = 'stick';\n    if (!fuelName) {\n      bot.chat('No fuel (coal or stick) available. Cannot smelt iron.');\n      return;\n    }\n\n    // 4\ufe0f\u20e3 Ensure a furnace is placed nearby\n    let furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 5\n    });\n    if (!furnaceBlock) {\n      bot.chat('No furnace nearby, trying to place one.');\n      if (countItem('furnace') === 0) {\n        bot.chat('No furnace item in inventory, cannot place furnace.');\n        return;\n      }\n      // place furnace at a free adjacent block\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      await placeItem(bot, 'furnace', placePos);\n      furnaceBlock = bot.blockAt(placePos);\n      bot.chat('Furnace placed.');\n    } else {\n      bot.chat('Furnace already within reach.');\n    }\n\n    // 5\ufe0f\u20e3 Smelt the missing ingots\n    bot.chat(`Smelting ${need} raw iron using ${fuelName}...`);\n    await smeltItem(bot, 'raw_iron', fuelName, need);\n    ingotCount = countItem('iron_ingot');\n    bot.chat(`Now have ${ingotCount} iron ingot(s).`);\n    if (ingotCount < REQUIRED_INGOTS) {\n      bot.chat('Smelting did not produce enough ingots. Aborting.');\n      return;\n    }\n  } else {\n    bot.chat(`Already have ${ingotCount} iron ingot(s).`);\n  }\n\n  // 6\ufe0f\u20e3 Ensure a crafting table is nearby\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    bot.chat('No crafting table nearby, attempting to place one.');\n    if (countItem('crafting_table') === 0) {\n      bot.chat('No crafting table item in inventory. Cannot craft leggings.');\n      return;\n    }\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    bot.chat('Crafting table placed.');\n  } else {\n    bot.chat('Crafting table already within reach.');\n  }\n\n  // 7\ufe0f\u20e3 Craft the iron leggings\n  bot.chat('Crafting iron leggings...');\n  await craftItem(bot, 'iron_leggings', 1);\n  bot.chat('Crafting attempt finished.');\n\n  // 8\ufe0f\u20e3 Verify result\n  if (countItem('iron_leggings') >= 1) {\n    bot.chat('Successfully obtained iron leggings.');\n  } else {\n    bot.chat('Failed to craft iron leggings.');\n  }\n}", "description": "async function craftIronLeggings(bot) {\n    // The routine checks the inventory for at least seven iron ingots, smelts any missing raw iron using available fuel and a nearby furnace, ensures a crafting table is within reach (placing one if necessary), then crafts an iron leggings item, and finally verifies that the leggings were successfully created.\n}"}, "smeltFourRawIron": {"code": "// main function to smelt four raw iron\nasync function smeltFourRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // Find a suitable position (air with at least one solid neighbor) near the bot\n  const findPlacePosition = () => {\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n    const base = bot.entity.position.floored();\n    for (const off of offsets) {\n      const pos = base.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (!block || block.name !== 'air') continue; // need air to place into\n\n      // at least one adjacent solid block\n      const neighbor = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      for (const n of neighbor) {\n        const nb = bot.blockAt(pos.plus(n));\n        if (nb && nb.name !== 'air') return pos;\n      }\n    }\n    return null;\n  };\n\n  // ---------- 1. Check raw iron ----------\n  const neededIron = 4;\n  const haveRawIron = countItem('raw_iron');\n  if (haveRawIron < neededIron) {\n    bot.chat(`\u274c I only have ${haveRawIron} raw iron, need ${neededIron}.`);\n    return;\n  }\n\n  // ---------- 2. Check fuel ----------\n  let fuelName = null;\n  if (countItem('coal') > 0) fuelName = 'coal';else if (countItem('stick') > 0) fuelName = 'stick';else {\n    bot.chat('\u274c No fuel (coal or stick) available for smelting.');\n    return;\n  }\n\n  // ---------- 3. Ensure a furnace is placed ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // need to place a furnace from inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c I have no furnace item to place.');\n      return;\n    }\n    const placePos = findPlacePosition();\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot to place a furnace.');\n      return;\n    }\n    bot.chat(`\ud83d\udce6 Placing furnace at ${placePos}`);\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    if (!furnaceBlock || furnaceBlock.name !== 'furnace') {\n      bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n    bot.chat('\u2705 Furnace placed.');\n  } else {\n    bot.chat('\u2705 Furnace already nearby.');\n  }\n\n  // ---------- 4. Smelt the raw iron ----------\n  bot.chat(`\ud83d\udd25 Smelting ${neededIron} raw iron using ${fuelName}...`);\n  await smeltItem(bot, 'raw_iron', fuelName, neededIron);\n  bot.chat('\u2705 Smelting finished.');\n\n  // ---------- 5. Verify result ----------\n  const ironIngots = countItem('iron_ingot');\n  if (ironIngots >= neededIron) {\n    bot.chat(`\u2705 I now have ${ironIngots} iron ingot(s).`);\n  } else {\n    bot.chat(`\u26a0\ufe0f Smelting incomplete: only ${ironIngots} iron ingot(s) present.`);\n  }\n}", "description": "async function smeltFourRawIron(bot) {\n    // The routine first verifies the inventory contains at least four raw iron, then selects available fuel (coal or sticks); it searches for a nearby furnace and, if none is found, locates a suitable air block adjacent to a solid block to place a furnace from the inventory; after the furnace is ready, it initiates smelting of the four raw iron using the chosen fuel; once smelting completes, it checks the inventory for iron ingots and confirms that at least four have been produced; any missing resources cause the process to abort early.\n}"}, "equipIronHelmet": {"code": "// main function to equip an iron helmet\nasync function equipIronHelmet(bot) {\n  // Load Minecraft data for the current version\n  const mcData = require('minecraft-data')(bot.version);\n\n  // Find the iron helmet in the bot's inventory\n  const helmetItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_helmet.id);\n\n  // If we don't have one, inform the user and stop\n  if (!helmetItem) {\n    bot.chat('I do not have an iron helmet in my inventory.');\n    return;\n  }\n\n  // Equip the helmet to the head slot\n  bot.chat('Equipping iron helmet...');\n  await bot.equip(helmetItem, 'head');\n  bot.chat('Iron helmet equipped!');\n}", "description": "async function equipIronHelmet(bot) {\n    // The function loads the appropriate Minecraft data for the bot\u2019s version, searches the inventory for an iron helmet, aborts if the helmet is not present, and if found equips it to the head slot.\n}"}, "equipIronLeggings": {"code": "// Main function to equip iron leggings\nasync function equipIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // Helper to count items in inventory\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // 1\ufe0f\u20e3 Find iron leggings in inventory\n  let leggings = bot.inventory.findInventoryItem(mcData.itemsByName.iron_leggings.id);\n\n  // 2\ufe0f\u20e3 If we don't have leggings, craft them\n  if (!leggings) {\n    bot.chat('I have no iron leggings, preparing to craft them...');\n\n    // ---- a) Ensure we have at least 4 iron ingots ----\n    const neededIngots = Math.max(0, 4 - countItem('iron_ingot'));\n    if (neededIngots > 0) {\n      bot.chat(`Need ${neededIngots} iron ingots, smelting raw iron...`);\n      // Ensure we have enough raw iron\n      const rawNeeded = neededIngots; // 1 raw iron -> 1 ingot\n      if (countItem('raw_iron') < rawNeeded) {\n        bot.chat('Not enough raw iron to smelt.');\n        return;\n      }\n      // Ensure we have fuel (coal or stick)\n      if (countItem('coal') === 0 && countItem('stick') === 0) {\n        bot.chat('No fuel available for smelting.');\n        return;\n      }\n      const fuelName = countItem('coal') > 0 ? 'coal' : 'stick';\n      await smeltItem(bot, 'raw_iron', fuelName, neededIngots);\n    }\n\n    // ---- b) Ensure a crafting table is nearby ----\n    let craftingTableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 5\n    });\n    if (!craftingTableBlock) {\n      // Place a crafting table from inventory\n      const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n      if (!tableItem) {\n        bot.chat('I have no crafting table to place.');\n        return;\n      }\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      bot.chat('Placing a crafting table...');\n      await placeItem(bot, 'crafting_table', placePos);\n      craftingTableBlock = bot.blockAt(placePos);\n    }\n\n    // ---- c) Craft the leggings ----\n    bot.chat('Crafting iron leggings...');\n    await craftItem(bot, 'iron_leggings', 1);\n\n    // Re\u2011search for the crafted leggings\n    leggings = bot.inventory.findInventoryItem(mcData.itemsByName.iron_leggings.id);\n    if (!leggings) {\n      bot.chat('Failed to craft iron leggings.');\n      return;\n    }\n  }\n\n  // 3\ufe0f\u20e3 Equip the leggings\n  bot.chat('Equipping iron leggings...');\n  await bot.equip(leggings, 'legs');\n  bot.chat('Iron leggings equipped!');\n}", "description": "async function equipIronLeggings(bot) {\n    // The function checks the inventory for iron leggings, smelts raw iron into ingots when fewer than four are available, places a crafting table nearby if none is found, crafts the iron leggings, and finally equips them in the bot\u2019s leg armor slot.\n}"}, "craftOneIronBoots": {"code": "// main function to craft one iron boots\nasync function craftOneIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // Find an air block next to a solid block (within a 2\u2011block radius)\n  function findPlacePosition() {\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1), new Vec3(0, -1, 0), new Vec3(0, 1, 0)];\n    const base = bot.entity.position.floored();\n    for (const off of offsets) {\n      const pos = base.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (!block || block.name !== 'air') continue; // need air to place into\n\n      // check at least one neighbor is solid (not air)\n      const neighborVectors = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      for (const n of neighborVectors) {\n        const nb = bot.blockAt(pos.plus(n));\n        if (nb && nb.name !== 'air') return pos;\n      }\n    }\n    return null; // none found\n  }\n\n  // ---------- 1. Ensure we have 4 iron ingots ----------\n  const neededIngots = Math.max(0, 4 - countItem('iron_ingot'));\n  if (neededIngots > 0) {\n    bot.chat(`Need ${neededIngots} more iron ingot(s), attempting to smelt raw iron.`);\n    if (countItem('raw_iron') < neededIngots) {\n      bot.chat('Not enough raw iron to smelt the required ingots.');\n      return;\n    }\n    // choose fuel\n    let fuelName = null;\n    if (countItem('coal') > 0) fuelName = 'coal';else if (countItem('stick') > 0) fuelName = 'stick';else {\n      bot.chat('No fuel (coal or stick) available for smelting.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', fuelName, neededIngots);\n    bot.chat(`Smelted ${neededIngots} iron ingot(s).`);\n  } else {\n    bot.chat('Already have enough iron ingots.');\n  }\n\n  // ---------- 2. Ensure a crafting table is placed ----------\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('No crafting table item in inventory to place.');\n      return;\n    }\n    const placePos = findPlacePosition();\n    if (!placePos) {\n      bot.chat('Could not find a suitable spot to place the crafting table.');\n      return;\n    }\n    bot.chat(`Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    // verify placement\n    craftingTableBlock = bot.blockAt(placePos);\n    if (!craftingTableBlock || craftingTableBlock.name !== 'crafting_table') {\n      bot.chat('Failed to place the crafting table.');\n      return;\n    }\n    bot.chat('Crafting table placed successfully.');\n  } else {\n    bot.chat('Crafting table already nearby.');\n  }\n\n  // ---------- 3. Craft the iron boots ----------\n  if (countItem('iron_ingot') < 4) {\n    bot.chat('Not enough iron ingots after smelting. Aborting.');\n    return;\n  }\n  bot.chat('Crafting iron boots...');\n  await craftItem(bot, 'iron_boots', 1);\n  bot.chat('Crafting attempt finished.');\n\n  // ---------- 4. Verify result ----------\n  const boots = bot.inventory.findInventoryItem(mcData.itemsByName.iron_boots.id);\n  if (boots) {\n    bot.chat('Successfully crafted 1 iron boot(s)!');\n  } else {\n    bot.chat('Failed to craft iron boots.');\n  }\n}", "description": "async function craftOneIronBoots(bot) {\n    // The routine ensures the bot has at least four iron ingots, smelting raw iron with available fuel if needed, then locates or places a crafting table on a suitable nearby air block, crafts one set of iron boots using the ingots, and finally checks the inventory to confirm the boots were successfully created.\n}"}, "mineFiveRedstoneOre": {"code": "// -----------------------------------------------------------------------------\n// Main function: mine at least five redstone ore blocks (\u22655 redstone dust)\n// -----------------------------------------------------------------------------\nasync function mineFiveRedstoneOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // --------------------------- helpers ---------------------------------------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n  const getPickaxe = () => {\n    const order = ['netherite_pickaxe', 'diamond_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n    for (const n of order) {\n      const id = mcData.itemsByName[n]?.id;\n      if (!id) continue;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) return item;\n    }\n    return null;\n  };\n\n  // eat until hunger is decent (\u226514)\n  const eatIfHungry = async () => {\n    if (bot.food >= 14) return;\n    const foodPriority = ['cooked_porkchop', 'porkchop', 'cooked_beef', 'beef'];\n    for (const name of foodPriority) {\n      const item = bot.inventory.findInventoryItem(mcData.itemsByName[name]?.id);\n      if (item) {\n        await bot.equip(item, 'hand');\n        await bot.consume();\n        bot.chat(`\ud83c\udf56 Ate a ${name} (hunger ${bot.food}/20).`);\n        if (bot.food >= 14) break;\n      }\n    }\n  };\n\n  // pick a random horizontal direction (no vertical component)\n  const randomHorizontal = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n\n  // -------------------------------------------------------------------------\n  // 1. Prepare (food & tool)\n  // -------------------------------------------------------------------------\n  await eatIfHungry();\n  const pickaxe = getPickaxe();\n  if (!pickaxe) {\n    bot.chat('\u274c No pickaxe in inventory \u2013 cannot mine redstone.');\n    return;\n  }\n  // iron pickaxe or better is required\n  const ironId = mcData.itemsByName.iron_pickaxe?.id;\n  if (ironId && pickaxe.type < ironId) {\n    bot.chat('\u274c My best pickaxe is weaker than iron \u2013 cannot mine redstone.');\n    return;\n  }\n  await bot.equip(pickaxe, 'hand');\n  bot.chat(`\u2705 Equipped ${pickaxe.name} for mining.`);\n\n  // -------------------------------------------------------------------------\n  // 2. Descend to mining depth (Y \u2264 16) while looking for redstone ore\n  // -------------------------------------------------------------------------\n  const maxDescendSteps = 8; // each step moves ~5 blocks down\n  let redstoneBlock = null;\n  for (let step = 0; step < maxDescendSteps; step++) {\n    // Try to locate ore at current depth\n    redstoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.redstone_ore.id,\n      maxDistance: 32\n    });\n    if (redstoneBlock) break; // found!\n\n    // Not found \u2013 descend a bit\n    bot.chat(`\ud83d\udd0e No redstone ore at Y=${Math.floor(bot.entity.position.y)}. Descending...`);\n    const downDir = new Vec3(0, -1, 0);\n    // exploreUntil will move the bot in the given direction for up to 60\u202fs\n    await exploreUntil(bot, downDir, 60, () => null);\n    // safety: if we are already below Y=16, stop descending\n    if (bot.entity.position.y <= 16) break;\n  }\n\n  // Final check after descent\n  if (!redstoneBlock) {\n    // One last search after the final descent\n    redstoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.redstone_ore.id,\n      maxDistance: 32\n    });\n  }\n  if (!redstoneBlock) {\n    bot.chat('\u274c Could not locate any redstone ore after descending.');\n    return;\n  }\n  bot.chat(`\u2705 Found redstone ore at ${redstoneBlock.position}. Starting mining.`);\n\n  // -------------------------------------------------------------------------\n  // 3. Mine five redstone ore blocks\n  // -------------------------------------------------------------------------\n  await mineBlock(bot, 'redstone_ore', 5);\n  bot.chat('\u26cf\ufe0f Mined five redstone ore blocks.');\n\n  // -------------------------------------------------------------------------\n  // 4. Verify we have at least 5 redstone dust\n  // -------------------------------------------------------------------------\n  const dustCount = countItem('redstone');\n  if (dustCount >= 5) {\n    bot.chat(`\u2705 Success! I now have ${dustCount} redstone dust (\u22655).`);\n  } else {\n    bot.chat(`\u26a0\ufe0f I only have ${dustCount} redstone dust after mining.`);\n  }\n}", "description": "async function mineFiveRedstoneOre(bot) {\n    // The routine first ensures the bot is fed and holds an iron\u2011tier or better pickaxe, then it descends to a depth of Y\u202f\u2264\u202f16 while searching for redstone ore, mines at least five ore blocks once found, and finally checks that the inventory contains five or more redstone dust items.\n}"}, "mineThreeDiamondOre": {"code": "// ------------------------------------------------------------\n// Main function: mine three diamond ore blocks\n// ------------------------------------------------------------\nasync function mineThreeDiamondOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper: count items ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // ---------- helper: eat if hungry ----------\n  async function ensureFood() {\n    if (bot.food >= 14) return; // already fine\n    const foodPriority = ['cooked_porkchop', 'cooked_beef', 'porkchop', 'beef'];\n    for (const f of foodPriority) {\n      const item = bot.inventory.findInventoryItem(mcData.itemsByName[f]?.id);\n      if (item) {\n        await bot.equip(item, 'hand');\n        await bot.consume();\n        bot.chat(`\ud83c\udf56 Ate ${f} (hunger ${bot.food}/20).`);\n        if (bot.food >= 14) break;\n      }\n    }\n  }\n\n  // ---------- helper: best pickaxe ----------\n  function getBestPickaxe() {\n    const order = ['diamond_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n    for (const n of order) {\n      const id = mcData.itemsByName[n]?.id;\n      if (!id) continue;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) return item;\n    }\n    return null;\n  }\n\n  // ---------- helper: equip pickaxe ----------\n  async function equipPickaxe() {\n    const pick = getBestPickaxe();\n    if (!pick) {\n      bot.chat('\u274c No pickaxe available for mining diamonds.');\n      return false;\n    }\n    await bot.equip(pick, 'hand');\n    bot.chat(`\u2705 Equipped ${pick.name} for mining.`);\n    return true;\n  }\n\n  // ---------- helper: locate diamond ore ----------\n  async function locateDiamondOre() {\n    // try immediate detection\n    let ore = bot.findBlock({\n      matching: mcData.blocksByName.diamond_ore.id,\n      maxDistance: 32\n    });\n    if (ore) return ore;\n\n    // directions to explore (horizontal only)\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n    // try a few random explorations\n    for (let attempt = 0; attempt < 4; attempt++) {\n      const dir = dirs[Math.floor(Math.random() * dirs.length)];\n      bot.chat(`\ud83d\udd0e Exploring ${dir} for diamond ore (attempt ${attempt + 1})...`);\n      await exploreUntil(bot, dir, 60, () => {\n        const found = bot.findBlock({\n          matching: mcData.blocksByName.diamond_ore.id,\n          maxDistance: 32\n        });\n        return found ? found : null; // stop early if found\n      });\n      ore = bot.findBlock({\n        matching: mcData.blocksByName.diamond_ore.id,\n        maxDistance: 32\n      });\n      if (ore) break;\n    }\n    return ore;\n  }\n\n  // ------------------- main procedure -------------------\n  await ensureFood();\n  const canMine = await equipPickaxe();\n  if (!canMine) return; // abort if no pickaxe\n\n  const oreBlock = await locateDiamondOre();\n  if (!oreBlock) {\n    bot.chat('\u274c Could not locate any diamond ore after exploring.');\n    return;\n  }\n  bot.chat(`\u2705 Found diamond ore at ${oreBlock.position}. Starting mining of 3 blocks...`);\n\n  // Mine three diamond ore blocks (uses the generic helper)\n  await mineBlock(bot, 'diamond_ore', 3);\n  bot.chat('\u26cf\ufe0f Finished mining three diamond ore blocks.');\n\n  // Verify we have at least three diamonds\n  const diamonds = countItem('diamond');\n  if (diamonds >= 3) {\n    bot.chat(`\u2705 Success! I now have ${diamonds} diamond(s).`);\n  } else {\n    bot.chat(`\u26a0\ufe0f Mining done, but only ${diamonds} diamond(s) in inventory.`);\n  }\n}", "description": "async function mineThreeDiamondOre(bot) {\n    // The routine first ensures the bot is sufficiently fed, then selects and equips the strongest available pickaxe; it searches the surrounding area for diamond ore, exploring in random directions if necessary; upon locating ore it mines three diamond ore blocks; finally it counts the diamonds in the inventory to verify that at least three were obtained.\n}"}, "craftDiamondPickaxe": {"code": "// main function to craft one diamond pickaxe\nasync function craftDiamondPickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // 1\ufe0f\u20e3 Ensure we have the required materials\n  const neededDiamonds = 3;\n  const neededSticks = 2;\n  const haveDiamonds = countItem('diamond');\n  const haveSticks = countItem('stick');\n  if (haveDiamonds < neededDiamonds) {\n    bot.chat(`\u274c I only have ${haveDiamonds} diamond(s); need ${neededDiamonds} to craft a diamond pickaxe.`);\n    return;\n  }\n  if (haveSticks < neededSticks) {\n    bot.chat(`\u274c I only have ${haveSticks} stick(s); need ${neededSticks} to craft a diamond pickaxe.`);\n    return;\n  }\n  bot.chat(`\u2705 Materials check passed (diamonds: ${haveDiamonds}, sticks: ${haveSticks}).`);\n\n  // 2\ufe0f\u20e3 Ensure a crafting table is placed nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!craftingTableBlock) {\n    // we need to place one\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // find a suitable air block next to the bot\n    const basePos = bot.entity.position.floored();\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n    let placePos = null;\n    for (const off of offsets) {\n      const pos = basePos.plus(off);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        // ensure there is at least one solid neighbor to attach to\n        const neighborDirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n        for (const nd of neighborDirs) {\n          const nb = bot.blockAt(pos.plus(nd));\n          if (nb && nb.name !== 'air') {\n            placePos = pos;\n            break;\n          }\n        }\n        if (placePos) break;\n      }\n    }\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot to place a crafting table.');\n      return;\n    }\n    bot.chat(`\ud83d\udce6 Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    // re\u2011assign after placement\n    craftingTableBlock = bot.blockAt(placePos);\n    if (!craftingTableBlock || craftingTableBlock.name !== 'crafting_table') {\n      bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    bot.chat('\u2705 Crafting table placed.');\n  } else {\n    bot.chat('\u2705 Crafting table already nearby.');\n  }\n\n  // 3\ufe0f\u20e3 Craft the diamond pickaxe\n  bot.chat('\ud83d\udd28 Crafting diamond pickaxe...');\n  await craftItem(bot, 'diamond_pickaxe', 1);\n\n  // 4\ufe0f\u20e3 Verify the result\n  const pickaxe = bot.inventory.findInventoryItem(mcData.itemsByName.diamond_pickaxe.id);\n  if (pickaxe) {\n    bot.chat('\u2705 Successfully crafted a diamond pickaxe!');\n  } else {\n    bot.chat('\u26a0\ufe0f Crafting failed \u2013 diamond pickaxe not found in inventory.');\n  }\n}", "description": "async function craftDiamondPickaxe(bot) {\n    // The function first checks that the inventory contains at least three diamonds and two sticks, aborting if the requirement is not met. It then searches for a nearby crafting table within a 32\u2011block radius; if none is found, it locates a suitable air block adjacent to a solid block and places a crafting table there. After confirming a crafting table is available, it initiates the crafting recipe for one diamond pickaxe. Once the crafting operation completes, it looks for the newly created diamond pickaxe in the inventory to confirm success. If the pickaxe is absent, the process is considered failed.\n}"}, "craftOneCompass": {"code": "// main function to craft one compass\nasync function craftOneCompass(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper to count items in inventory -----\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // ----- 1. Ensure we have 4 iron ingots -----\n  const neededIron = Math.max(0, 4 - countItem('iron_ingot'));\n  if (neededIron > 0) {\n    bot.chat(`\ud83d\udd28 Need ${neededIron} more iron ingot(s). Attempting to smelt from raw iron.`);\n    // check we have enough raw iron\n    if (countItem('raw_iron') < neededIron) {\n      bot.chat('\u274c Not enough raw iron to smelt the required ingots.');\n      return;\n    }\n    // pick a fuel (coal > stick > none)\n    let fuelName = null;\n    if (countItem('coal') > 0) fuelName = 'coal';else if (countItem('stick') > 0) fuelName = 'stick';else {\n      bot.chat('\u274c No fuel (coal or stick) available for smelting.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', fuelName, neededIron);\n    bot.chat(`\u2705 Smelted ${neededIron} iron ingot(s).`);\n  } else {\n    bot.chat('\u2705 Already have enough iron ingots.');\n  }\n\n  // ----- 2. Ensure we have at least 1 redstone dust -----\n  if (countItem('redstone') < 1) {\n    bot.chat('\u274c No redstone dust in inventory \u2013 cannot craft a compass.');\n    return;\n  }\n\n  // ----- 3. Ensure a crafting table is placed nearby -----\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // need to place one\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // find a suitable air block adjacent to a solid block\n    const basePos = bot.entity.position.floored();\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1), new Vec3(0, 1, 0)];\n    let placePos = null;\n    for (const off of offsets) {\n      const pos = basePos.plus(off);\n      const block = bot.blockAt(pos);\n      if (!block || block.name !== 'air') continue;\n      // ensure at least one neighbor is solid\n      const neighborDirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      for (const nd of neighborDirs) {\n        const nb = bot.blockAt(pos.plus(nd));\n        if (nb && nb.name !== 'air') {\n          placePos = pos;\n          break;\n        }\n      }\n      if (placePos) break;\n    }\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot to place a crafting table.');\n      return;\n    }\n    bot.chat(`\ud83d\udce6 Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    if (!tableBlock || tableBlock.name !== 'crafting_table') {\n      bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    bot.chat('\u2705 Crafting table placed.');\n  } else {\n    bot.chat('\u2705 Crafting table already within reach.');\n  }\n\n  // ----- 4. Craft the compass -----\n  bot.chat('\ud83d\udd28 Crafting a compass...');\n  await craftItem(bot, 'compass', 1);\n  bot.chat('\u2705 Crafting attempt finished.');\n\n  // ----- 5. Verify result -----\n  const compass = bot.inventory.findInventoryItem(mcData.itemsByName.compass.id);\n  if (compass) {\n    bot.chat('\u2705 Successfully crafted a compass!');\n  } else {\n    bot.chat('\u26a0\ufe0f Crafting failed \u2013 compass not found in inventory.');\n  }\n}", "description": "async function craftOneCompass(bot) {\n    // The function guarantees the bot possesses four iron ingots, smelting raw iron with available fuel when needed; it then verifies there is at least one redstone dust; it ensures a crafting table is nearby, locating one or placing it in a suitable air block adjacent to a solid block; after meeting these prerequisites it crafts a compass; finally it checks the inventory to confirm the compass was successfully created.\n}"}, "mineThreeGoldOre": {"code": "// main function\nasync function mineThreeGoldOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- 1. Equip an iron\u2011or\u2011better pickaxe ----------\n  const diamondPick = bot.inventory.findInventoryItem(mcData.itemsByName.diamond_pickaxe?.id);\n  const ironPick = bot.inventory.findInventoryItem(mcData.itemsByName.iron_pickaxe?.id);\n  const pickaxe = diamondPick || ironPick;\n  if (!pickaxe) {\n    bot.chat('\u274c I have no iron or better pickaxe, cannot mine gold ore.');\n    return;\n  }\n  await bot.equip(pickaxe, 'hand');\n  bot.chat(`\u2705 Equipped ${pickaxe.name} for mining.`);\n\n  // ---------- 2. Helper: random horizontal direction ----------\n  const randomHorizontal = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n\n  // ---------- 3. Helper: locate gold ore ----------\n  const locateGoldOre = () => {\n    return bot.findBlock({\n      matching: mcData.blocksByName.gold_ore.id,\n      maxDistance: 32\n    });\n  };\n\n  // ---------- 4. Try to find gold ore nearby ----------\n  let goldBlock = locateGoldOre();\n  if (!goldBlock) {\n    bot.chat('\ud83d\udd0e No gold ore nearby \u2013 starting exploration.');\n    const direction = randomHorizontal();\n    await exploreUntil(bot, direction, 60, () => locateGoldOre());\n    goldBlock = locateGoldOre();\n  }\n  if (!goldBlock) {\n    bot.chat('\u274c Could not find any gold ore after exploration.');\n    return;\n  }\n\n  // ---------- 5. Mine three gold ore blocks ----------\n  bot.chat('\u26cf\ufe0f Mining 3 gold ore blocks...');\n  await mineBlock(bot, 'gold_ore', 3);\n  bot.chat('\u2705 Finished mining gold ore.');\n\n  // ---------- 6. Report collected nuggets ----------\n  const nugId = mcData.itemsByName.gold_nugget?.id;\n  const nugCount = nugId ? bot.inventory.count(nugId) : 0;\n  bot.chat(`\ud83d\udce6 I now have ${nugCount} gold nugget(s).`);\n}", "description": "async function mineThreeGoldOre(bot) {\n    // The function equips a diamond or iron pickaxe, searches for gold ore within a 32\u2011block radius and, if none is found, explores in a random horizontal direction until gold ore is located, then mines three gold ore blocks and finally counts the gold nuggets now present in the inventory.\n}"}, "smeltFiveRawIron": {"code": "// Main function: smelt 5 raw iron (including placing furnace and gathering fuel if needed)\nasync function smeltFiveRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // Ensure we have at least 5 raw iron\n  const rawIronCount = countItem('raw_iron');\n  if (rawIronCount < 5) {\n    bot.chat(`\u274c I only have ${rawIronCount} raw iron, need at least 5.`);\n    return;\n  }\n  bot.chat(`\u2705 I have ${rawIronCount} raw iron, proceeding to smelt 5.`);\n\n  // ---------- 1. Ensure a furnace is placed ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // Find a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n\n    // Find a suitable position (air block with a solid neighbor)\n    const basePos = bot.entity.position.floored();\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placePos = null;\n    for (const off of offsets) {\n      const pos = basePos.plus(off);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        // check for at least one solid neighbor\n        const neighborVectors = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n        for (const n of neighborVectors) {\n          const nb = bot.blockAt(pos.plus(n));\n          if (nb && nb.name !== 'air') {\n            placePos = pos;\n            break;\n          }\n        }\n      }\n      if (placePos) break;\n    }\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot to place a furnace.');\n      return;\n    }\n    bot.chat(`\ud83d\udd27 Placing furnace at ${placePos}`);\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    if (!furnaceBlock || furnaceBlock.name !== 'furnace') {\n      bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n    bot.chat('\u2705 Furnace placed successfully.');\n  } else {\n    bot.chat('\u2705 Furnace already nearby.');\n  }\n\n  // ---------- 2. Ensure we have enough fuel (coal) ----------\n  const coalNeeded = 5;\n  let coalCount = countItem('coal');\n  if (coalCount < coalNeeded) {\n    const missing = coalNeeded - coalCount;\n    bot.chat(`\ud83d\udd28 Need ${missing} more coal. Mining coal ore...`);\n    // Mine enough coal ore blocks to obtain the missing coal\n    await mineBlock(bot, 'coal_ore', missing);\n    // Update count after mining\n    coalCount = countItem('coal');\n    if (coalCount < coalNeeded) {\n      bot.chat(`\u274c Still only have ${coalCount} coal after mining. Cannot continue.`);\n      return;\n    }\n    bot.chat(`\u2705 Acquired ${coalCount} coal.`);\n  } else {\n    bot.chat(`\u2705 Sufficient coal (${coalCount}) available for smelting.`);\n  }\n\n  // ---------- 3. Smelt 5 raw iron ----------\n  bot.chat('\ud83d\udd25 Starting smelting of 5 raw iron...');\n  await smeltItem(bot, 'raw_iron', 'coal', 5);\n  bot.chat('\u2705 Smelting finished.');\n\n  // ---------- 4. Verify result ----------\n  const ironIngotCount = countItem('iron_ingot');\n  if (ironIngotCount >= 5) {\n    bot.chat(`\u2705 Success! I now have ${ironIngotCount} iron ingot(s).`);\n  } else {\n    bot.chat(`\u26a0\ufe0f Smelting completed but only ${ironIngotCount} iron ingot(s) in inventory.`);\n  }\n}", "description": "async function smeltFiveRawIron(bot) {\n    // The routine first checks that the inventory contains at least five raw iron, then ensures a furnace is present by locating one nearby or placing a furnace block at a suitable empty spot; it next verifies sufficient coal for fuel, mining additional coal ore if needed; after obtaining the required fuel, it smelts five raw iron using the furnace; finally, it confirms that at least five iron ingots have been produced.\n}"}, "placeChestNearby": {"code": "// ------------------------------------------------------------\n// Main function: place a chest near the bot if not already present\n// ------------------------------------------------------------\nasync function placeChestNearby(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3  Check if a chest block already exists nearby (within 5 blocks)\n  const existingChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 5\n  });\n  if (existingChest) {\n    bot.chat('\u2705 Chest is already placed nearby.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3  Ensure we have a chest item in inventory\n  const chestItem = bot.inventory.findInventoryItem(mcData.itemsByName.chest.id);\n  if (!chestItem) {\n    bot.chat('\u274c I have no chest in my inventory to place.');\n    return;\n  }\n\n  // Helper: find a suitable air block with at least one solid neighbour\n  function findPlacementPosition() {\n    const base = bot.entity.position.floored(); // integer block coordinates\n    // search a small cube around the bot (including one block above)\n    for (let dx = -2; dx <= 2; dx++) {\n      for (let dy = -1; dy <= 2; dy++) {\n        for (let dz = -2; dz <= 2; dz++) {\n          const pos = base.offset(dx, dy, dz);\n          const block = bot.blockAt(pos);\n          if (!block || block.name !== 'air') continue; // must be air\n\n          // check neighbours for a solid block (non\u2011air)\n          const neighbours = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n          for (const n of neighbours) {\n            const nb = bot.blockAt(pos.plus(n));\n            if (nb && nb.name !== 'air') return pos;\n          }\n        }\n      }\n    }\n    return null; // none found\n  }\n\n  // 3\ufe0f\u20e3  Try to locate a placement position\n  let placePos = findPlacementPosition();\n\n  // 4\ufe0f\u20e3  If not found, move a bit in a random horizontal direction and try again\n  if (!placePos) {\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    bot.chat('\ud83d\udd0e No suitable spot nearby, moving a bit to look for space...');\n    await exploreUntil(bot, randomDir, 60, () => null); // just walk a bit\n    placePos = findPlacementPosition();\n  }\n  if (!placePos) {\n    bot.chat('\u274c Could not find a place to put the chest.');\n    return;\n  }\n\n  // 5\ufe0f\u20e3  Place the chest\n  bot.chat(`\ud83d\udce6 Placing chest at ${placePos.x}, ${placePos.y}, ${placePos.z}...`);\n  try {\n    await placeItem(bot, 'chest', placePos);\n  } catch (err) {\n    bot.chat(`\u274c Failed to place chest: ${err.message}`);\n    return;\n  }\n\n  // 6\ufe0f\u20e3  Verify placement\n  const placedChest = bot.blockAt(placePos);\n  if (placedChest && placedChest.name === 'chest') {\n    bot.chat('\u2705 Chest placed successfully!');\n  } else {\n    bot.chat('\u26a0\ufe0f Chest placement attempted but block not detected.');\n  }\n}", "description": "async function placeChestNearby(bot) {\n    // It checks whether a chest block already exists within five blocks, ensures the bot has a chest item, searches a nearby area for an empty block that touches a solid block, moves a short distance in a random direction if no spot is found, places the chest at the identified location, and then verifies that the chest was successfully placed.\n}"}, "craftBucket": {"code": "// Main function to craft a bucket\nasync function craftBucket(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  function countItem(name) {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  }\n\n  // ----- 1. Ensure we have at least 3 iron ingots -----\n  let ironIngots = countItem('iron_ingot');\n  if (ironIngots < 3) {\n    const needed = 3 - ironIngots;\n    bot.chat(`Need ${needed} more iron ingot(s). Smelting raw iron...`);\n\n    // check we have enough raw iron\n    if (countItem('raw_iron') < needed) {\n      bot.chat('\u274c Not enough raw iron to smelt the required ingots.');\n      return;\n    }\n\n    // pick a fuel (coal preferred, otherwise stick)\n    const fuelName = countItem('coal') > 0 ? 'coal' : countItem('stick') > 0 ? 'stick' : null;\n    if (!fuelName) {\n      bot.chat('\u274c No fuel (coal or stick) available for smelting.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', fuelName, needed);\n    bot.chat(`\u2705 Smelted ${needed} iron ingot(s).`);\n    ironIngots = countItem('iron_ingot'); // update count\n  } else {\n    bot.chat('\u2705 Sufficient iron ingots already in inventory.');\n  }\n\n  // ----- 2. Ensure a crafting table is placed nearby -----\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!craftingTableBlock) {\n    bot.chat('\ud83d\udd28 No crafting table nearby, placing one...');\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // Find a suitable position (adjacent air block with a solid neighbor)\n    const basePos = bot.entity.position.floored();\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placePos = null;\n    for (const off of offsets) {\n      const pos = basePos.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        // ensure at least one neighbor is solid\n        const neighborDirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n        for (const nd of neighborDirs) {\n          const nb = bot.blockAt(pos.plus(nd));\n          if (nb && nb.name !== 'air') {\n            placePos = pos;\n            break;\n          }\n        }\n      }\n      if (placePos) break;\n    }\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot to place the crafting table.');\n      return;\n    }\n    await placeItem(bot, 'crafting_table', placePos);\n    craftingTableBlock = bot.blockAt(placePos);\n    if (!craftingTableBlock || craftingTableBlock.name !== 'crafting_table') {\n      bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    bot.chat('\u2705 Crafting table placed.');\n  } else {\n    bot.chat('\u2705 Crafting table already within reach.');\n  }\n\n  // ----- 3. Craft the bucket -----\n  // Check if we already have a bucket\n  if (bot.inventory.findInventoryItem(mcData.itemsByName.bucket.id)) {\n    bot.chat('\u2705 Bucket already in inventory.');\n    return;\n  }\n  bot.chat('\ud83d\udee0\ufe0f Crafting a bucket...');\n  await craftItem(bot, 'bucket', 1);\n  bot.chat('\u2705 Bucket crafted!');\n\n  // ----- 4. Verify -----\n  const bucket = bot.inventory.findInventoryItem(mcData.itemsByName.bucket.id);\n  if (bucket) {\n    bot.chat('\u2705 Verification passed: bucket is now in inventory.');\n  } else {\n    bot.chat('\u26a0\ufe0f Something went wrong: bucket not found after crafting.');\n  }\n}", "description": "async function craftBucket(bot) {\n    // The routine first checks that the inventory contains at least three iron ingots, smelting raw iron with coal or sticks if necessary; it then ensures a crafting table is within five blocks, placing one on a suitable adjacent air block when none is found; after confirming the table\u2019s presence, it verifies that a bucket is not already owned and proceeds to craft a bucket using the table; finally, it confirms that the newly crafted bucket appears in the inventory.\n}"}, "smeltFourRawGold": {"code": "// Main function: smelt 4 raw gold into gold ingots\nasync function smeltFourRawGold(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper to count items ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // ---------- 1. Check we have enough raw gold ----------\n  const rawGoldNeeded = 4;\n  if (countItem('raw_gold') < rawGoldNeeded) {\n    bot.chat(`\u274c I need ${rawGoldNeeded} raw gold but only have ${countItem('raw_gold')}.`);\n    return;\n  }\n\n  // ---------- 2. Check we have enough fuel (coal) ----------\n  const fuelName = 'coal';\n  if (countItem(fuelName) < rawGoldNeeded) {\n    bot.chat(`\u274c I need ${rawGoldNeeded} ${fuelName} for fuel but only have ${countItem(fuelName)}.`);\n    return;\n  }\n\n  // ---------- 3. Find or place a furnace ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // Need to place a furnace from inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n\n    // Find a suitable position next to the bot\n    const placePos = bot.entity.position.floored().offset(1, 0, 0);\n    bot.chat(`Placing furnace at ${placePos}`);\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    if (!furnaceBlock || furnaceBlock.name !== 'furnace') {\n      bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n  } else {\n    bot.chat('\u2705 Found a furnace nearby.');\n  }\n\n  // ---------- 4. Smelt the raw gold ----------\n  bot.chat(`\u26cf\ufe0f Smelting ${rawGoldNeeded} raw gold using ${fuelName}...`);\n  await smeltItem(bot, 'raw_gold', fuelName, rawGoldNeeded);\n  bot.chat('\u2705 Smelting complete! Check your inventory for gold ingots.');\n}", "description": "async function smeltFourRawGold(bot) {\n    // The routine verifies that at least four raw gold and an equal amount of coal are present, locates or places a furnace nearby, and then uses the furnace to smelt the raw gold into gold ingots.\n}"}, "equipIronBoots": {"code": "// ------------------------------------------------------------\n// Helper functions (used only inside the main function)\n// ------------------------------------------------------------\nasync function equipIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalPlaceBlock,\n    GoalLookAtBlock,\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- utility ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // ---------- ensure a furnace exists ----------\n  async function ensureFurnace() {\n    let furnace = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (furnace) return furnace;\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      bot.chat('\u274c No furnace item to place.');\n      return null;\n    }\n\n    // find a place next to the bot that has a solid neighbour\n    const base = bot.entity.position.floored();\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placePos = null;\n    for (const off of offsets) {\n      const pos = base.plus(off);\n      const block = bot.blockAt(pos);\n      if (!block || block.name !== 'air') continue;\n      // need at least one solid neighbour\n      const neigh = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      for (const n of neigh) {\n        const nb = bot.blockAt(pos.plus(n));\n        if (nb && nb.name !== 'air') {\n          placePos = pos;\n          break;\n        }\n      }\n      if (placePos) break;\n    }\n    if (!placePos) {\n      bot.chat('\u274c Could not find a suitable spot for the furnace.');\n      return null;\n    }\n    bot.chat(`\ud83d\udd27 Placing furnace at ${placePos}`);\n    await placeItem(bot, 'furnace', placePos);\n    return bot.blockAt(placePos);\n  }\n\n  // ---------- ensure we have at least one fuel item ----------\n  function getFuelName() {\n    if (countItem('coal') > 0) return 'coal';\n    if (countItem('stick') > 0) return 'stick';\n    return null;\n  }\n\n  // ---------- ensure enough iron ingots ----------\n  async function ensureIronIngots(target) {\n    const have = countItem('iron_ingot');\n    if (have >= target) return true;\n    const need = target - have;\n    // check raw iron\n    const rawCount = countItem('raw_iron');\n    if (rawCount < need) {\n      bot.chat(`\u274c Need ${need} raw iron but only have ${rawCount}.`);\n      return false;\n    }\n    const fuelName = getFuelName();\n    if (!fuelName) {\n      bot.chat('\u274c No fuel (coal or stick) to smelt iron.');\n      return false;\n    }\n    const furnace = await ensureFurnace();\n    if (!furnace) return false;\n    bot.chat(`\ud83d\udd25 Smelting ${need} iron ingot(s) using ${fuelName}.`);\n    await smeltItem(bot, 'raw_iron', fuelName, need);\n    return countItem('iron_ingot') >= target;\n  }\n\n  // ---------- obtain iron boots ----------\n  async function obtainBoots() {\n    // 1) already in inventory?\n    let boots = bot.inventory.findInventoryItem(mcData.itemsByName.iron_boots.id);\n    if (boots) return boots;\n\n    // 2) try to pull from nearest chest\n    const chestBlock = bot.findBlock({\n      matching: mcData.blocksByName.chest.id,\n      maxDistance: 32\n    });\n    if (chestBlock) {\n      bot.chat('\ud83d\udce6 Trying to get iron boots from a nearby chest.');\n      await getItemFromChest(bot, chestBlock.position, {\n        iron_boots: 1\n      });\n      boots = bot.inventory.findInventoryItem(mcData.itemsByName.iron_boots.id);\n      if (boots) return boots;\n    }\n\n    // 3) craft them\n    bot.chat('\ud83d\udd28 Crafting iron boots because none were found.');\n    // ensure 4 iron ingots\n    const okIngots = await ensureIronIngots(4);\n    if (!okIngots) {\n      bot.chat('\u274c Cannot craft boots \u2013 not enough iron ingots.');\n      return null;\n    }\n\n    // ensure crafting table\n    let table = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!table) {\n      const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n      if (!tableItem) {\n        bot.chat('\u274c No crafting table in inventory to place.');\n        return null;\n      }\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      bot.chat('Placing a crafting table for the recipe.');\n      await placeItem(bot, 'crafting_table', placePos);\n      table = bot.blockAt(placePos);\n    }\n\n    // craft\n    await craftItem(bot, 'iron_boots', 1);\n    return bot.inventory.findInventoryItem(mcData.itemsByName.iron_boots.id);\n  }\n\n  // ---------- main flow ----------\n  bot.chat('\ud83d\ude80 Starting iron boots equip routine.');\n  const bootsItem = await obtainBoots();\n  if (!bootsItem) {\n    bot.chat('\u274c Failed to obtain iron boots \u2013 cannot equip.');\n    return;\n  }\n  await bot.equip(bootsItem, 'feet');\n  bot.chat('\u2705 Iron boots equipped!');\n}", "description": "async function equipIronBoots(bot) {\n    // The routine ensures the bot has iron boots by first checking the inventory, then attempting to retrieve them from a nearby chest, and finally crafting them if necessary; it verifies that a furnace exists and places one if needed, then smelts raw iron using available fuel to obtain enough iron ingots; it also makes sure a crafting table is present, placing it when absent; after gathering the required materials, it crafts the iron boots and equips them on the feet slot.\n}"}, "eatOneCookedPorkchop": {"code": "// main function to eat one cooked porkchop\nasync function eatOneCookedPorkchop(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // Helper to count items in inventory\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // 1\ufe0f\u20e3 Find cooked porkchop in inventory\n  const porkId = mcData.itemsByName.cooked_porkchop?.id;\n  if (!porkId) {\n    bot.chat('\u274c No cooked porkchop item defined in this version.');\n    return;\n  }\n  let porkItem = bot.inventory.findInventoryItem(porkId);\n  // 2\ufe0f\u20e3 If not in inventory, try to get it from the nearest chest\n  if (!porkItem) {\n    bot.chat('\ud83d\udd0e No cooked porkchop in inventory, searching nearby chests...');\n    const chestBlock = bot.findBlock({\n      matching: mcData.blocksByName.chest.id,\n      maxDistance: 32\n    });\n    if (!chestBlock) {\n      bot.chat('\u274c No chest nearby to withdraw a cooked porkchop.');\n      return;\n    }\n    // Open chest, withdraw one porkchop, then close\n    const chest = await bot.openContainer(chestBlock);\n    const chestItem = chest.findContainerItem(porkId);\n    if (!chestItem) {\n      await chest.close();\n      bot.chat('\u274c Chest does not contain a cooked porkchop.');\n      return;\n    }\n    await chest.withdraw(chestItem.type, null, 1);\n    await chest.close();\n    // Refresh reference after withdrawal\n    porkItem = bot.inventory.findInventoryItem(porkId);\n    if (!porkItem) {\n      bot.chat('\u274c Failed to retrieve cooked porkchop from chest.');\n      return;\n    }\n    bot.chat('\u2705 Retrieved cooked porkchop from chest.');\n  }\n\n  // 3\ufe0f\u20e3 Equip the porkchop to the hand\n  try {\n    await bot.equip(porkItem, 'hand');\n  } catch (err) {\n    bot.chat(`\u274c Could not equip cooked porkchop: ${err.message}`);\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Eat it\n  try {\n    await bot.consume();\n    bot.chat(`\ud83c\udf56 Ate a cooked porkchop. Hunger is now ${bot.food}/20.`);\n  } catch (err) {\n    bot.chat(`\u274c Failed to eat cooked porkchop: ${err.message}`);\n  }\n}", "description": "async function eatOneCookedPorkchop(bot) {\n    // The routine ensures a cooked porkchop is present by first looking in the bot\u2019s inventory and, if absent, locating a nearby chest and withdrawing one; it then equips the porkchop in the hand and attempts to consume it, updating the bot\u2019s hunger level, while catching and handling any errors that occur during equipping or eating.\n}"}, "killOneSpider": {"code": "// ------------------------------------------------------------\n// Helper: pick a random horizontal direction (no vertical)\n// ------------------------------------------------------------\nfunction randomHorizontalDirection() {\n  const {\n    Vec3\n  } = require('vec3');\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n// ------------------------------------------------------------\n// Main function: kill exactly one spider\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// Main function: kill exactly one spider\n// ------------------------------------------------------------\nasync function killOneSpider(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1) Ensure we have a sword and equip it\n  const swordId = mcData.itemsByName.iron_sword?.id || mcData.itemsByName.diamond_sword?.id || mcData.itemsByName.stone_sword?.id || mcData.itemsByName.wooden_sword?.id;\n  if (!swordId) {\n    bot.chat('\u274c No sword in inventory \u2013 cannot kill a spider.');\n    return;\n  }\n  const swordItem = bot.inventory.findInventoryItem(swordId);\n  if (!swordItem) {\n    bot.chat('\u274c Sword not found in inventory.');\n    return;\n  }\n  await bot.equip(swordItem, 'hand');\n  bot.chat('\u2705 Sword equipped, ready to fight.');\n\n  // 2) Search for a spider\n  let spider = null;\n  const maxAttempts = 10; // avoid endless searching\n  for (let attempt = 0; attempt < maxAttempts && !spider; attempt++) {\n    // try to see if a spider is already nearby\n    spider = bot.nearestEntity(e => e.name === 'spider' && e.position.distanceTo(bot.entity.position) < 32);\n    if (spider) break;\n    const dir = randomHorizontalDirection();\n    bot.chat(`\ud83d\udd0e Searching for a spider (attempt ${attempt + 1})...`);\n    // exploreUntil will move the bot in the chosen direction; the callback\n    // stops as soon as a spider appears within 32 blocks.\n    await exploreUntil(bot, dir, 60, () => {\n      const found = bot.nearestEntity(ent => ent.name === 'spider' && ent.position.distanceTo(bot.entity.position) < 32);\n      if (found) {\n        spider = found; // store for later use\n        return found; // stop exploration\n      }\n      return null; // keep exploring\n    });\n  }\n  if (!spider) {\n    bot.chat('\u274c Could not locate any spider nearby.');\n    return;\n  }\n\n  // 3) Kill the spider\n  bot.chat(`\u2694\ufe0f Spider spotted at ${spider.position}. Engaging...`);\n  // killMob will handle pathfinding and attacking\n  await killMob(bot, 'spider', 300); // 300\u202fticks \u2248 15\u202fseconds timeout\n  bot.chat('\u2705 Spider has been killed.');\n}", "description": "async function killOneSpider(bot) {\n    // The routine first checks the inventory for any sword (iron, diamond, stone, or wooden) and equips it in the hand; it then performs up to ten searches, moving in random horizontal directions until a spider is detected within 32\u202fblocks; once a spider is found, the bot engages the target using pathfinding and combat logic with a timeout of about 15\u202fseconds; the process ends after successfully killing one spider or after failing to locate any spider after the attempts.\n}"}, "craftOneFishingRod": {"code": "// ---------------------------------------------------------------------------\n// Main function: craft one fishing rod (generic, reusable)\n// ---------------------------------------------------------------------------\nasync function craftOneFishingRod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalNear,\n    GoalPlaceBlock\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // get items from the nearest chest (max 32 blocks)\n  async function fetchFromChest(need) {\n    const chestBlock = bot.findBlock({\n      matching: mcData.blocksByName.chest.id,\n      maxDistance: 32\n    });\n    if (!chestBlock) {\n      bot.chat('\u274c No chest within 32 blocks.');\n      return false;\n    }\n    await bot.pathfinder.goto(new GoalNear(chestBlock.position.x, chestBlock.position.y, chestBlock.position.z, 1));\n    await getItemFromChest(bot, chestBlock.position, need);\n    return true;\n  }\n\n  // ---------- 1) ensure sticks ----------\n  const needSticks = Math.max(0, 3 - countItem('stick'));\n  if (needSticks > 0) {\n    bot.chat(`\ud83d\udd0e Need ${needSticks} stick(s).`);\n    if (!(await fetchFromChest({\n      stick: needSticks\n    }))) return;\n    bot.chat(`\u2705 Got sticks.`);\n  } else {\n    bot.chat('\u2705 Already have enough sticks.');\n  }\n\n  // ---------- 2) ensure strings ----------\n  const needStrings = Math.max(0, 2 - countItem('string'));\n  if (needStrings > 0) {\n    bot.chat(`\ud83d\udd0e Need ${needStrings} string(s).`);\n    if (!(await fetchFromChest({\n      string: needStrings\n    }))) return;\n    bot.chat(`\u2705 Got strings.`);\n  } else {\n    bot.chat('\u2705 Already have enough strings.');\n  }\n\n  // ---------- 3) locate or place a crafting table ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n\n  // helper: find a suitable placement position around the bot\n  function findPlacementPos() {\n    const base = bot.entity.position.floored(); // integer foot position\n    for (let dx = -2; dx <= 2; dx++) {\n      for (let dz = -2; dz <= 2; dz++) {\n        const pos = base.offset(dx, 1, dz); // one block above ground\n        const block = bot.blockAt(pos);\n        if (!block || block.name !== 'air') continue; // must be air\n        const below = bot.blockAt(pos.minus(new Vec3(0, 1, 0)));\n        if (below && below.name !== 'air') return pos; // solid support\n      }\n    }\n    return null;\n  }\n  async function tryPlaceTable() {\n    for (let attempt = 0; attempt < 3; attempt++) {\n      let placePos = findPlacementPos();\n      // if not found, walk a bit in a random horizontal direction and retry\n      if (!placePos) {\n        const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n        const randomDir = dirs[Math.floor(Math.random() * dirs.length)];\n        await exploreUntil(bot, randomDir, 60, () => null);\n        placePos = findPlacementPos();\n      }\n      if (!placePos) continue; // try next attempt\n\n      // move close enough to place\n      await bot.pathfinder.goto(new GoalPlaceBlock(placePos, bot.world, {}));\n      try {\n        await placeItem(bot, 'crafting_table', placePos);\n        const placed = bot.blockAt(placePos);\n        if (placed && placed.name === 'crafting_table') return placed;\n      } catch (e) {\n        bot.chat(`\u26a0\ufe0f Placement attempt ${attempt + 1} failed: ${e.message}`);\n      }\n    }\n    return null;\n  }\n  if (!tableBlock) {\n    bot.chat('\ud83d\udd28 No crafting table nearby \u2013 attempting to place one...');\n    tableBlock = await tryPlaceTable();\n    if (!tableBlock) {\n      bot.chat('\u274c Could not place a crafting table.');\n      return;\n    }\n    bot.chat(`\u2705 Crafting table placed at ${tableBlock.position}.`);\n  } else {\n    bot.chat('\u2705 Found existing crafting table nearby.');\n  }\n\n  // ---------- 4) craft the fishing rod ----------\n  bot.chat('\ud83c\udfa3 Crafting a fishing rod...');\n  try {\n    await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 2));\n    await craftItem(bot, 'fishing_rod', 1);\n    bot.chat('\u2705 Fishing rod crafted successfully!');\n  } catch (err) {\n    bot.chat(`\u274c Failed to craft fishing rod: ${err.message}`);\n  }\n}", "description": "async function craftOneFishingRod(bot) {\n    // The routine ensures the bot has at least three sticks and two strings, obtaining any missing items from the nearest chest within 32 blocks. It then checks for a crafting table within five blocks and, if none is found, attempts to place one on a suitable solid surface nearby. After securing a crafting table, the bot moves close to it and crafts a single fishing rod using the gathered materials. The process handles placement retries and aborts if required resources or a table cannot be secured.\n}"}, "craftOneClock": {"code": "// main function: craft exactly one clock\nasync function craftOneClock(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalNear,\n    GoalPlaceBlock,\n    GoalLookAtBlock\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- small helpers ----------\n  const countItem = name => {\n    const id = mcData.itemsByName[name]?.id;\n    return id ? bot.inventory.count(id) : 0;\n  };\n\n  // pick a random horizontal direction (no vertical component)\n  const randomHorizontalDirection = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n\n  // find an air block with a solid block underneath within radius r\n  const findAirWithGround = (radius = 4) => {\n    const base = bot.entity.position.floored(); // foot block\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const pos = base.offset(dx, 1, dz); // one block above ground level\n        const block = bot.blockAt(pos);\n        const below = bot.blockAt(pos.minus(new Vec3(0, 1, 0)));\n        if (block && block.name === 'air' && below && below.name !== 'air') {\n          return pos;\n        }\n      }\n    }\n    return null;\n  };\n\n  // ---------- 1. Verify required materials ----------\n  if (countItem('gold_ingot') < 4) {\n    bot.chat('\u274c Need 4 gold ingots to craft a clock.');\n    return;\n  }\n  if (countItem('redstone') < 1) {\n    bot.chat('\u274c Need redstone dust to craft a clock.');\n    return;\n  }\n  bot.chat('\u2705 Required materials are present.');\n\n  // ---------- 2. Ensure a crafting table ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 5\n  });\n  if (!tableBlock) {\n    bot.chat('\ud83d\udd28 No crafting table nearby \u2013 attempting to place one...');\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n\n    // try up to three placement attempts\n    for (let attempt = 0; attempt < 3; attempt++) {\n      // 2a. locate a suitable spot\n      let placePos = findAirWithGround(4);\n      if (!placePos) {\n        // move a bit randomly and try again\n        const dir = randomHorizontalDirection();\n        bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring a bit to find space (attempt ${attempt + 1})...`);\n        await exploreUntil(bot, dir, 20, () => null); // just walk\n        placePos = findAirWithGround(4);\n      }\n      if (!placePos) {\n        bot.chat('\u26a0\ufe0f Still could not find a free spot for the table.');\n        continue;\n      }\n\n      // 2b. if the target block is not air, clear it (mine)\n      const targetBlock = bot.blockAt(placePos);\n      if (targetBlock && targetBlock.name !== 'air') {\n        bot.chat('\u26cf\ufe0f Clearing block that occupies the placement spot...');\n        await mineBlock(bot, targetBlock.name, 1);\n      }\n\n      // 2c. move close enough and place\n      try {\n        await bot.pathfinder.goto(new GoalPlaceBlock(placePos, bot.world, {}));\n        await placeItem(bot, 'crafting_table', placePos);\n        tableBlock = bot.blockAt(placePos);\n        if (tableBlock && tableBlock.name === 'crafting_table') {\n          bot.chat(`\u2705 Placed crafting table at ${placePos}.`);\n          break;\n        }\n      } catch (e) {\n        bot.chat(`\u26a0\ufe0f Placement attempt ${attempt + 1} failed: ${e.message}`);\n      }\n    }\n    if (!tableBlock) {\n      bot.chat('\u274c Failed to place a crafting table \u2013 cannot craft the clock.');\n      return;\n    }\n  } else {\n    bot.chat('\u2705 Found an existing crafting table nearby.');\n  }\n\n  // ---------- 3. Craft the clock ----------\n  bot.chat('\u23f1\ufe0f Crafting the clock...');\n  try {\n    // ensure we are close enough to the table\n    await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 2));\n    await craftItem(bot, 'clock', 1);\n    bot.chat('\u2705 Clock crafted successfully!');\n  } catch (err) {\n    bot.chat(`\u274c Failed to craft the clock: ${err.message}`);\n  }\n}", "description": "async function craftOneClock(bot) {\n    // The function verifies that the bot has at least four gold ingots and one redstone dust, then searches for a nearby crafting table; if none is found it attempts up to three times to locate a suitable empty spot with solid ground, moves there, clears any obstructing block, and places a crafting table. After ensuring a crafting table is present, it moves within range of the table and crafts exactly one clock.\n}"}}