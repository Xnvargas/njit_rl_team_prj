{"mineOneWoodLog": {"code": "// main function to mine a single wood log\nasync function mineOneWoodLog(bot) {\n  const logNames = [\"oak_log\", \"birch_log\", \"spruce_log\", \"jungle_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n\n  // 1) Check if we already have a log in inventory\n  for (const name of logNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    if (item) {\n      await bot.chat(`I already have a ${name} in my inventory.`);\n      return;\n    }\n  }\n\n  // 2) Try to find a log nearby (within 32 blocks)\n  let foundLog = null;\n  for (const name of logNames) {\n    const block = bot.findBlock({\n      matching: mcData.blocksByName[name].id,\n      maxDistance: 32\n    });\n    if (block) {\n      foundLog = name;\n      break;\n    }\n  }\n\n  // 3) If a log was found, mine it directly\n  if (foundLog) {\n    await bot.chat(`Found a ${foundLog} nearby, mining it now.`);\n    await mineBlock(bot, foundLog, 1);\n    await bot.chat(`Mined 1 ${foundLog}.`);\n    return;\n  }\n\n  // 4) No log nearby \u2013 explore until we find one\n  await bot.chat(\"No log nearby, exploring to find a log...\");\n\n  // Helper to pick a random direction vector with components -1, 0, or 1 (not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n  const logFoundName = await exploreUntil(bot, randomDirection(), 60, () => {\n    for (const name of logNames) {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName[name].id,\n        maxDistance: 32\n      });\n      if (blk) return name; // stop exploration, return the log name\n    }\n    return null; // keep exploring\n  });\n  if (!logFoundName) {\n    await bot.chat(\"Failed to find any log after exploring.\");\n    return;\n  }\n\n  // 5) Mine the discovered log\n  await bot.chat(`Found a ${logFoundName} while exploring, mining it now.`);\n  await mineBlock(bot, logFoundName, 1);\n  await bot.chat(`Mined 1 ${logFoundName}.`);\n}", "description": "async function mineOneWoodLog(bot) {\n    // The function ensures the bot obtains a single wood log; it first scans the inventory for any log type and exits if one is already present; if none are found, it searches within 32 blocks for a log and mines it immediately when located; when no nearby log exists, it explores the world in random directions for up to a minute until a log block is detected; upon discovery during exploration, it mines exactly one log of the found type; then the process ends.\n}"}, "ensureFourOakPlanks": {"code": "// Main function: ensure the bot ends up with exactly 4 oak planks\nasync function ensureFourOakPlanks(bot) {\n  // 1\ufe0f\u20e3 Check current oak planks\n  const plankId = mcData.itemsByName[\"oak_planks\"].id;\n  let plankCount = bot.inventory.count(plankId);\n  if (plankCount >= 4) {\n    await bot.chat(`I already have ${plankCount} oak planks, no need to craft more.`);\n    return;\n  }\n\n  // 2\ufe0f\u20e3 How many more planks and how many logs we need\n  const neededPlanks = 4 - plankCount;\n  const craftTimes = Math.ceil(neededPlanks / 4); // each craft gives 4 planks\n  const neededLogs = craftTimes; // 1 log \u2192 4 planks\n\n  // 3\ufe0f\u20e3 Ensure we have enough oak logs\n  const logId = mcData.itemsByName[\"oak_log\"].id;\n  let logCount = bot.inventory.count(logId);\n  if (logCount < neededLogs) {\n    const toMine = neededLogs - logCount;\n    await bot.chat(`I need ${toMine} more oak log(s). Searching for logs...`);\n\n    // Try to find a log nearby\n    let logBlock = bot.findBlock({\n      matching: b => b.name.endsWith(\"_log\"),\n      maxDistance: 32\n    });\n\n    // If not found, explore until we locate one\n    if (!logBlock) {\n      const randomDirection = () => {\n        const choices = [-1, 0, 1];\n        let vec;\n        do {\n          vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n        } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n        return vec;\n      };\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: b => b.name.endsWith(\"_log\"),\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"Couldn't find any oak log after exploring.\");\n        return;\n      }\n    }\n\n    // Mine the required number of logs\n    await bot.chat(`Mining ${toMine} oak log(s)...`);\n    await mineBlock(bot, \"oak_log\", toMine);\n    await bot.chat(`Mined ${toMine} oak log(s).`);\n  } else {\n    await bot.chat(`I already have ${logCount} oak log(s) in inventory.`);\n  }\n\n  // 4\ufe0f\u20e3 Ensure a crafting table is available\n  let craftingTable = bot.findBlock({\n    matching: mcData.blocksByName[\"crafting_table\"].id,\n    maxDistance: 32\n  });\n  if (!craftingTable) {\n    await bot.chat(\"No crafting table nearby, placing one...\");\n    // Choose a free spot next to the bot (one block east)\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    // Ensure the target position is air; if not, shift further\n    let finalPos = placePos;\n    for (let i = 0; i < 5; i++) {\n      const block = bot.blockAt(finalPos);\n      if (block && block.name === \"air\") break;\n      finalPos = finalPos.offset(1, 0, 0); // move east\n    }\n    await placeItem(bot, \"crafting_table\", finalPos);\n    await bot.chat(\"Crafting table placed.\");\n    // Update reference\n    craftingTable = bot.blockAt(finalPos);\n  } else {\n    await bot.chat(\"Found a crafting table nearby.\");\n  }\n\n  // 5\ufe0f\u20e3 Craft the oak planks\n  await bot.chat(`Crafting oak planks (${craftTimes} time(s))...`);\n  await craftItem(bot, \"oak_planks\", craftTimes);\n  await bot.chat(\"Crafting done.\");\n\n  // 6\ufe0f\u20e3 Report final count\n  plankCount = bot.inventory.count(plankId);\n  await bot.chat(`I now have ${plankCount} oak planks (target was 4).`);\n}", "description": "async function ensureFourOakPlanks(bot) {\n    // The routine checks how many oak planks the bot currently holds and, if fewer than four, computes the number of additional planks and corresponding oak logs required; it then verifies that enough oak logs are in the inventory, searching the nearby area and mining extra logs when necessary; next, it ensures a crafting table is available, placing one nearby if none is found; using the gathered logs, it crafts the needed amount of oak planks to reach exactly four; finally, it updates the inventory count to reflect the target quantity.\n}"}, "craftWoodenPickaxe": {"code": "// main function to craft a wooden pickaxe, handling all prerequisites\nasync function craftWoodenPickaxe(bot) {\n  const plankName = \"oak_planks\";\n  const stickName = \"stick\";\n  const pickaxeName = \"wooden_pickaxe\";\n  const tableName = \"crafting_table\";\n\n  // --------------------------------------------------------------\n  // Helper: ensure we have at least `target` oak planks\n  // --------------------------------------------------------------\n  async function ensurePlanks(target) {\n    const plankId = mcData.itemsByName[plankName].id;\n    let have = bot.inventory.count(plankId);\n    if (have >= target) {\n      await bot.chat(`Planks OK: ${have}/${target}`);\n      return;\n    }\n    const missing = target - have;\n    const logsNeeded = Math.ceil(missing / 4); // 1 log \u2192 4 planks\n\n    // find any log nearby (any type)\n    let logBlock = bot.findBlock({\n      matching: b => b.name.endsWith(\"_log\"),\n      maxDistance: 32\n    });\n\n    // if none, explore until we see one\n    if (!logBlock) {\n      await bot.chat(\"Searching for a log to make planks...\");\n      const randomDir = () => {\n        const choices = [-1, 0, 1];\n        let v;\n        do {\n          v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n        } while (v.x === 0 && v.y === 0 && v.z === 0);\n        return v;\n      };\n      const found = await exploreUntil(bot, randomDir(), 60, () => {\n        const blk = bot.findBlock({\n          matching: b => b.name.endsWith(\"_log\"),\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not locate any log.\");\n        return;\n      }\n    }\n\n    // mine the required logs (any log type works)\n    await bot.chat(`Mining ${logsNeeded} log(s) for planks...`);\n    // try oak first, fallback to generic logs\n    try {\n      await mineBlock(bot, \"oak_log\", logsNeeded);\n    } catch (_) {\n      await mineBlock(bot, \"birch_log\", logsNeeded);\n    }\n\n    // craft the missing planks\n    const craftTimes = Math.ceil(missing / 4);\n    await bot.chat(`Crafting ${missing} plank(s) (${craftTimes} operation(s))...`);\n    await ensureCraftingTable(); // make sure a table is placed before crafting\n    await craftItem(bot, plankName, craftTimes);\n    await bot.chat(\"Plank crafting done.\");\n  }\n\n  // --------------------------------------------------------------\n  // Helper: ensure we have at least `target` sticks\n  // --------------------------------------------------------------\n  async function ensureSticks(target) {\n    const stickId = mcData.itemsByName[stickName].id;\n    let have = bot.inventory.count(stickId);\n    if (have >= target) {\n      await bot.chat(`Sticks OK: ${have}/${target}`);\n      return;\n    }\n    const missing = target - have;\n    const craftsNeeded = Math.ceil(missing / 4); // 1 craft \u2192 4 sticks\n    const planksNeeded = craftsNeeded * 2; // each craft consumes 2 planks\n\n    await ensurePlanks(planksNeeded);\n    await ensureCraftingTable();\n    await bot.chat(`Crafting ${missing} stick(s) (${craftsNeeded} operation(s))...`);\n    await craftItem(bot, stickName, craftsNeeded);\n    await bot.chat(\"Stick crafting done.\");\n  }\n\n  // --------------------------------------------------------------\n  // Helper: ensure we have a crafting\u2011table *item* in inventory\n  // --------------------------------------------------------------\n  async function ensureCraftingTableItem() {\n    const tableId = mcData.itemsByName[tableName].id;\n    if (bot.inventory.count(tableId) > 0) {\n      await bot.chat(\"Crafting table item already in inventory.\");\n      return;\n    }\n    await bot.chat(\"Need to craft a crafting table item.\");\n    await ensurePlanks(4); // 4 planks \u2192 1 table\n    await bot.chat(\"Crafting the crafting table item...\");\n    await craftItem(bot, tableName, 1);\n    await bot.chat(\"Crafting table item crafted.\");\n  }\n\n  // --------------------------------------------------------------\n  // Helper: place a crafting table on solid ground near the bot\n  // --------------------------------------------------------------\n  async function placeCraftingTableNearBot() {\n    await ensureCraftingTableItem();\n\n    // find a solid block within 3 blocks of the bot\n    const solidBlock = bot.findBlock({\n      matching: b => b.name !== \"air\",\n      maxDistance: 3\n    });\n    if (!solidBlock) {\n      await bot.chat(\"\u274c No solid block nearby to place a crafting table on.\");\n      return false;\n    }\n    const placePos = solidBlock.position.offset(0, 1, 0); // air block above solid\n    const targetBlock = bot.blockAt(placePos);\n    if (!targetBlock || targetBlock.name !== \"air\") {\n      await bot.chat(\"\u274c The space above the solid block is not free.\");\n      return false;\n    }\n    await bot.chat(`Placing crafting table at ${placePos}`);\n    await placeItem(bot, tableName, placePos);\n    // move next to the table so we can use it\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat(\"Crafting table placed and bot is nearby.\");\n    return true;\n  }\n\n  // --------------------------------------------------------------\n  // Helper: ensure a placed crafting table is reachable\n  // --------------------------------------------------------------\n  async function ensureCraftingTable() {\n    // check for an already placed table\n    const placed = bot.findBlock({\n      matching: mcData.blocksByName[tableName].id,\n      maxDistance: 32\n    });\n    if (placed) {\n      await bot.chat(\"Found a placed crafting table nearby.\");\n      await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n      return;\n    }\n    // otherwise place a new one\n    await bot.chat(\"No placed crafting table nearby, placing one...\");\n    const success = await placeCraftingTableNearBot();\n    if (!success) {\n      throw new Error(\"Failed to place a crafting table.\");\n    }\n  }\n\n  // --------------------------------------------------------------\n  // Main sequence\n  // --------------------------------------------------------------\n  await bot.chat(\"=== Starting wooden pickaxe crafting routine ===\");\n\n  // 1) Ensure we have a usable crafting table (placed)\n  await ensureCraftingTable();\n\n  // 2) Ensure we have at least 3 planks\n  await ensurePlanks(3);\n\n  // 3) Ensure we have at least 2 sticks\n  await ensureSticks(2);\n\n  // 4) Craft the wooden pickaxe\n  await bot.chat(\"Crafting wooden pickaxe...\");\n  await craftItem(bot, pickaxeName, 1);\n  await bot.chat(\"Wooden pickaxe crafted!\");\n\n  // 5) Report result\n  const pickaxeId = mcData.itemsByName[pickaxeName].id;\n  const hasPickaxe = bot.inventory.findInventoryItem(pickaxeId);\n  if (hasPickaxe) {\n    await bot.chat(\"\u2705 Successfully obtained a wooden pickaxe.\");\n  } else {\n    await bot.chat(\"\u274c Failed to craft the wooden pickaxe.\");\n  }\n}", "description": "async function craftWoodenPickaxe(bot) {\n    // The routine first guarantees a usable crafting table is placed nearby, then ensures the bot has at least three oak planks and two sticks, crafting any missing planks, sticks, or the table itself as needed, after which it crafts a wooden pickaxe and finally verifies that the pickaxe appears in the inventory.\n}"}, "mineEightCobblestone": {"code": "// Main function to ensure the bot ends up with at least 8 cobblestone\nasync function mineEightCobblestone(bot) {\n  // Helper: random direction vector with components -1, 0, or 1 (not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // 1\ufe0f\u20e3 Check how many cobblestone we already have\n  const cobId = mcData.itemsByName[\"cobblestone\"].id;\n  let cobCount = bot.inventory.count(cobId);\n  if (cobCount >= 8) {\n    await bot.chat(`I already have ${cobCount} cobblestone. Task completed.`);\n    return;\n  }\n  await bot.chat(`Cobblestone: ${cobCount}/8. Need to collect more.`);\n\n  // 2\ufe0f\u20e3 Ensure we have a pickaxe (any type)\n  const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  const hasPickaxe = pickaxeNames.some(name => bot.inventory.findInventoryItem(mcData.itemsByName[name].id));\n  if (!hasPickaxe) {\n    await bot.chat(\"No pickaxe found. Crafting a wooden pickaxe...\");\n\n    // Ensure we have at least 3 planks\n    const plankId = mcData.itemsByName[\"oak_planks\"].id;\n    let planks = bot.inventory.count(plankId);\n    if (planks < 3) {\n      const needed = 3 - planks;\n      const craftTimes = Math.ceil(needed / 4); // 4 planks per craft\n      await bot.chat(`Need ${needed} more planks. Crafting ${craftTimes} time(s).`);\n      // Ensure we have logs to make planks\n      const logId = mcData.itemsByName[\"oak_log\"].id;\n      let logs = bot.inventory.count(logId);\n      if (logs < craftTimes) {\n        const logsToMine = craftTimes - logs;\n        await bot.chat(`Mining ${logsToMine} oak log(s) for planks...`);\n        await mineBlock(bot, \"oak_log\", logsToMine);\n      }\n      await craftItem(bot, \"oak_planks\", craftTimes);\n    }\n\n    // Ensure we have at least 2 sticks\n    const stickId = mcData.itemsByName[\"stick\"].id;\n    let sticks = bot.inventory.count(stickId);\n    if (sticks < 2) {\n      const needSticks = 2 - sticks;\n      const craftTimes = Math.ceil(needSticks / 4); // 4 sticks per craft\n      const planksNeeded = craftTimes * 2;\n      await bot.chat(`Need ${needSticks} sticks. Crafting ${craftTimes} time(s).`);\n      // Ensure enough planks for sticks\n      planks = bot.inventory.count(plankId);\n      if (planks < planksNeeded) {\n        const extraPlankCrafts = Math.ceil((planksNeeded - planks) / 4);\n        await bot.chat(`Crafting ${extraPlankCrafts} extra plank batch(es) for sticks.`);\n        await craftItem(bot, \"oak_planks\", extraPlankCrafts);\n      }\n      await craftItem(bot, \"stick\", craftTimes);\n    }\n\n    // Craft the wooden pickaxe\n    await bot.chat(\"Crafting wooden pickaxe...\");\n    await craftItem(bot, \"wooden_pickaxe\", 1);\n    await bot.chat(\"Wooden pickaxe crafted.\");\n  } else {\n    await bot.chat(\"Pickaxe already in inventory.\");\n  }\n\n  // 3\ufe0f\u20e3 Locate stone blocks\n  let stoneBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"stone\"].id,\n    maxDistance: 32\n  });\n  if (!stoneBlock) {\n    await bot.chat(\"No stone nearby, exploring to find stone...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName[\"stone\"].id,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Could not locate any stone after exploring.\");\n      return;\n    }\n    await bot.chat(\"Stone found! Proceeding to mine.\");\n  } else {\n    await bot.chat(\"Stone block found nearby.\");\n  }\n\n  // 4\ufe0f\u20e3 Mine stone until we have 8 cobblestone\n  const neededCob = 8 - cobCount;\n  await bot.chat(`Mining ${neededCob} stone block(s) to obtain cobblestone...`);\n  await mineBlock(bot, \"stone\", neededCob);\n\n  // 5\ufe0f\u20e3 Final check\n  cobCount = bot.inventory.count(cobId);\n  if (cobCount >= 8) {\n    await bot.chat(`\u2705 Success! I now have ${cobCount} cobblestone.`);\n  } else {\n    await bot.chat(`\u274c Finished mining but only have ${cobCount} cobblestone.`);\n  }\n}", "description": "async function mineEightCobblestone(bot) {\n    // The routine guarantees the bot ends with at least eight cobblestone by first checking the current cobblestone count, then ensuring a pickaxe is available (crafting a wooden one if necessary, including gathering planks and sticks), searching for stone blocks within a 32\u2011block radius and exploring further if none are found, mining the required number of stone blocks to reach the target amount, and finally confirming that the inventory now contains eight or more cobblestone.\n}"}, "craftStonePickaxe": {"code": "// -----------------------------------------------------------------------------\n// Helper: pick a random direction vector with components -1, 0, or 1 (not all 0)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// Helper: find a free spot (air block) above a solid block within radius r\n\n// Helper: find a free spot (air block) above a solid block within radius r\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === \"air\") continue; // need solid\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === \"air\") {\n          // also ensure the block above the air is not a non\u2011replaceable block (e.g., water)\n          const aboveAbove = bot.blockAt(abovePos.offset(0, 1, 0));\n          if (aboveAbove && aboveAbove.name !== \"air\") {\n            // still fine \u2013 we only need the placement block to be air\n          }\n          return abovePos; // suitable spot\n        }\n      }\n    }\n  }\n  return null; // none found\n}\n\n// -----------------------------------------------------------------------------\n// Main function: craft a stone pickaxe\n\n// -----------------------------------------------------------------------------\n// Main function: craft a stone pickaxe\nasync function craftStonePickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Already have a stone pickaxe?\n  const stonePickaxeId = mcData.itemsByName[\"stone_pickaxe\"].id;\n  if (bot.inventory.findInventoryItem(stonePickaxeId)) {\n    await bot.chat(\"I already have a stone pickaxe.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure required materials ------------------------------------------------\n  const cobId = mcData.itemsByName[\"cobblestone\"].id;\n  const stickId = mcData.itemsByName[\"stick\"].id;\n\n  // --- Cobblestone (need 3) ----------------------------------------------------\n  let cobCount = bot.inventory.count(cobId);\n  if (cobCount < 3) {\n    const need = 3 - cobCount;\n    await bot.chat(`Need ${need} more cobblestone. Mining stone...`);\n    await mineBlock(bot, \"stone\", need);\n    cobCount = bot.inventory.count(cobId);\n  } else {\n    await bot.chat(`Cobblestone OK: ${cobCount}/3`);\n  }\n\n  // --- Sticks (need 2) ---------------------------------------------------------\n  let stickCount = bot.inventory.count(stickId);\n  if (stickCount < 2) {\n    const needSticks = 2 - stickCount;\n    // each stick craft yields 4 sticks, consumes 2 planks\n    const craftTimes = Math.ceil(needSticks / 4);\n    const planksNeeded = craftTimes * 2;\n\n    // ensure we have enough planks\n    const plankId = mcData.itemsByName[\"oak_planks\"].id;\n    let plankCount = bot.inventory.count(plankId);\n    if (plankCount < planksNeeded) {\n      const missingPlanks = planksNeeded - plankCount;\n      const logsNeeded = Math.ceil(missingPlanks / 4); // 1 log \u2192 4 planks\n      await bot.chat(`Need ${missingPlanks} planks \u2192 mining ${logsNeeded} oak log(s)...`);\n      await mineBlock(bot, \"oak_log\", logsNeeded);\n      await bot.chat(`Crafting ${logsNeeded} oak plank batch(es)...`);\n      await craftItem(bot, \"oak_planks\", logsNeeded);\n    }\n\n    // ensure a crafting table is placed before crafting sticks\n    await ensureCraftingTablePlaced(bot);\n    await bot.chat(`Crafting ${needSticks} stick(s) (${craftTimes} craft operation(s))...`);\n    await craftItem(bot, \"stick\", craftTimes);\n    stickCount = bot.inventory.count(stickId);\n  } else {\n    await bot.chat(`Sticks OK: ${stickCount}/2`);\n  }\n\n  // 3\ufe0f\u20e3 Ensure a placed crafting table ------------------------------------------------\n  async function ensureCraftingTablePlaced(bot) {\n    // Look for an already placed table\n    const placed = bot.findBlock({\n      matching: mcData.blocksByName[\"crafting_table\"].id,\n      maxDistance: 32\n    });\n    if (placed) {\n      await bot.chat(\"Found a placed crafting table nearby.\");\n      await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n      return;\n    }\n\n    // No placed table \u2013 need to place one from inventory\n    await bot.chat(\"Placing a crafting table...\");\n\n    // Find a free spot near the bot\n    let placePos = await findFreePlacementSpot(bot, 3);\n    // If not found, explore a bit and try again\n    while (!placePos) {\n      await bot.chat(\"No free spot nearby, exploring for a place...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(bot, 3);\n        return p ? true : null;\n      });\n      if (found) placePos = findFreePlacementSpot(bot, 3);else break;\n    }\n    if (!placePos) {\n      throw new Error(\"Could not find a free position to place a crafting table.\");\n    }\n\n    // Place the table\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Walk next to it\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat(`Crafting table placed at ${placePos}`);\n  }\n  await ensureCraftingTablePlaced(bot);\n\n  // 4\ufe0f\u20e3 Craft the stone pickaxe -------------------------------------------------\n  await bot.chat(\"Crafting stone pickaxe...\");\n  await craftItem(bot, \"stone_pickaxe\", 1);\n  await bot.chat(\"Stone pickaxe crafted!\");\n\n  // 5\ufe0f\u20e3 Final verification ----------------------------------------------------\n  if (bot.inventory.findInventoryItem(stonePickaxeId)) {\n    await bot.chat(\"\u2705 I now have a stone pickaxe.\");\n  } else {\n    await bot.chat(\"\u274c Failed to craft the stone pickaxe.\");\n  }\n}", "description": "async function craftStonePickaxe(bot) {\n    // The function first checks if a stone pickaxe is already in the inventory and exits if so; otherwise it ensures at least three cobblestones are present, mining stone blocks as needed, and gathers enough sticks by crafting planks from logs if required; it then guarantees a crafting table is available nearby, either by locating an existing one or by finding a free air spot and placing a new table, exploring the area when necessary; once all materials and the table are ready, it crafts the stone pickaxe; finally it verifies that the stone pickaxe was successfully added to the inventory.\n}"}, "mineThreeCopperOre": {"code": "// Helper: pick a random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// Helper: ensure a placed crafting table is nearby\n\n// Helper: ensure a placed crafting table is nearby\nasync function ensurePlacedCraftingTable(bot) {\n  const tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (tableBlock) {\n    await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n    await bot.chat(\"Found a placed crafting table.\");\n    return;\n  }\n\n  // No placed table \u2013 place one from inventory\n  await bot.chat(\"Placing a crafting table...\");\n  // Find a free air block above a solid block within radius 3\n  const freePos = await findFreePlacementSpot(bot, 3);\n  if (!freePos) throw new Error(\"No place to put a crafting table.\");\n  await placeItem(bot, \"crafting_table\", freePos);\n  await bot.pathfinder.goto(new GoalNear(freePos.x, freePos.y, freePos.z, 1));\n  await bot.chat(`Crafting table placed at ${freePos}`);\n}\n\n// Helper: ensure we have at least `count` cobblestone, mining stone if needed\n\n// Helper: ensure we have at least `count` cobblestone, mining stone if needed\nasync function ensureCobblestone(bot, count) {\n  const cobId = mcData.itemsByName.cobblestone.id;\n  let have = bot.inventory.count(cobId);\n  if (have >= count) {\n    await bot.chat(`Cobblestone OK: ${have}/${count}`);\n    return;\n  }\n  const need = count - have;\n  await bot.chat(`Need ${need} more cobblestone, mining stone...`);\n  await mineBlock(bot, \"stone\", need);\n  await bot.chat(`Mined ${need} stone \u2192 cobblestone.`);\n}\n\n// Helper: ensure a furnace is placed (crafts it if necessary)\n\n// Helper: ensure a furnace is placed (crafts it if necessary)\nasync function ensurePlacedFurnace(bot) {\n  const furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (furnaceBlock) {\n    await bot.pathfinder.goto(new GoalNear(furnaceBlock.position.x, furnaceBlock.position.y, furnaceBlock.position.z, 1));\n    await bot.chat(\"Found a placed furnace.\");\n    return furnaceBlock;\n  }\n\n  // Need to craft a furnace\n  await bot.chat(\"Crafting a furnace...\");\n  // Ensure we have 8 cobblestone\n  await ensureCobblestone(bot, 8);\n  // Ensure crafting table is placed (required for crafting)\n  await ensurePlacedCraftingTable(bot);\n  // Craft furnace (1)\n  await craftItem(bot, \"furnace\", 1);\n  await bot.chat(\"Furnace crafted.\");\n\n  // Place the furnace\n  const placePos = await findFreePlacementSpot(bot, 3);\n  if (!placePos) throw new Error(\"No free spot to place furnace.\");\n  await placeItem(bot, \"furnace\", placePos);\n  await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n  await bot.chat(`Furnace placed at ${placePos}`);\n  return bot.blockAt(placePos);\n}\n\n// Helper: ensure we have enough oak planks for fuel (1 plank per smelt)\n\n// Helper: ensure we have enough oak planks for fuel (1 plank per smelt)\nasync function ensureFuelPlanks(bot, needed) {\n  const plankId = mcData.itemsByName.oak_planks.id;\n  let have = bot.inventory.count(plankId);\n  if (have >= needed) {\n    await bot.chat(`Fuel planks OK: ${have}/${needed}`);\n    return;\n  }\n  const missing = needed - have;\n  await bot.chat(`Need ${missing} more oak planks for fuel.`);\n  // Ensure we have enough logs\n  const logId = mcData.itemsByName.oak_log.id;\n  let logs = bot.inventory.count(logId);\n  const logsNeeded = Math.ceil(missing / 4); // 1 log \u2192 4 planks\n  if (logs < logsNeeded) {\n    const toMine = logsNeeded - logs;\n    await bot.chat(`Mining ${toMine} oak log(s) for planks...`);\n    await mineBlock(bot, \"oak_log\", toMine);\n  }\n  // Craft the missing planks\n  const craftTimes = Math.ceil(missing / 4);\n  await ensurePlacedCraftingTable(bot);\n  await bot.chat(`Crafting ${missing} oak planks (${craftTimes} batch(es))...`);\n  await craftItem(bot, \"oak_planks\", craftTimes);\n}\n\n// Main function\n\n// Main function\nasync function mineThreeCopperOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  await bot.chat(\"=== Starting task: mine 3 copper ore ===\");\n\n  // 1) Ensure we have a stone pickaxe (required for copper)\n  const stonePickId = mcData.itemsByName.stone_pickaxe.id;\n  if (!bot.inventory.findInventoryItem(stonePickId)) {\n    await bot.chat(\"No stone pickaxe \u2013 cannot mine copper. Task aborted.\");\n    return;\n  }\n\n  // 2) Ensure a furnace exists for later smelting\n  const furnaceBlock = await ensurePlacedFurnace(bot);\n\n  // 3) Locate copper ore; explore if not nearby\n  let copperBlock = bot.findBlock({\n    matching: mcData.blocksByName.copper_ore.id,\n    maxDistance: 32\n  });\n  if (!copperBlock) {\n    await bot.chat(\"Copper ore not nearby, exploring...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.copper_ore.id,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Could not find copper ore after exploring.\");\n      return;\n    }\n    copperBlock = bot.findBlock({\n      matching: mcData.blocksByName.copper_ore.id,\n      maxDistance: 32\n    });\n  }\n  await bot.chat(\"Copper ore located, beginning mining...\");\n\n  // 4) Mine three copper ore blocks\n  await mineBlock(bot, \"copper_ore\", 3);\n  await bot.chat(\"Mined 3 copper ore blocks.\");\n\n  // 5) Ensure we have enough fuel (oak planks) for smelting 3 raw copper\n  await ensureFuelPlanks(bot, 3);\n\n  // 6) Smelt the raw copper into copper ingots\n  await bot.chat(\"Smelting raw copper into copper ingots...\");\n  await smeltItem(bot, \"raw_copper\", \"oak_planks\", 3);\n  await bot.chat(\"Smelting complete.\");\n\n  // 7) Final verification\n  const copperIngotId = mcData.itemsByName.copper_ingot.id;\n  const ingotCount = bot.inventory.count(copperIngotId);\n  if (ingotCount >= 3) {\n    await bot.chat(`\u2705 Task finished: ${ingotCount} copper ingot(s) in inventory.`);\n  } else {\n    await bot.chat(`\u274c Task finished but only ${ingotCount} copper ingot(s) obtained.`);\n  }\n}", "description": "async function mineThreeCopperOre(bot) {\n    // The routine first verifies a stone pickaxe is present, then makes sure a furnace is available, searches for copper ore within a 32\u2011block radius (exploring randomly if needed), mines three copper ore blocks, gathers enough oak planks for smelting fuel, smelts the raw copper into ingots, and finally confirms that at least three copper ingots are now in the inventory.\n}"}, "smeltThreeCopper": {"code": "// main function to smelt three raw copper into copper ingots\nasync function smeltThreeCopper(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- helpers ----------\n  // random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // find a free air block directly above a solid block within radius\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n\n  // move an item from hot\u2011bar to a free inventory slot (>=3)\n  async function relocateFuelToInventory(itemId, needed) {\n    // collect all slots that contain the item\n    const items = bot.inventory.items().filter(i => i.type === itemId);\n    // count how many are already in slots >=3\n    let alreadyGood = items.filter(i => i.slot >= 3).length;\n    if (alreadyGood >= needed) return true; // enough already in good slots\n\n    // find empty slots >=3\n    const emptySlots = [];\n    for (let s = 3; s < 36; s++) {\n      if (!bot.inventory.slots[s]) emptySlots.push(s);\n    }\n    // move from hot\u2011bar (slots 0\u20112) to empty slots\n    for (const it of items) {\n      if (alreadyGood >= needed) break;\n      if (it.slot < 3 && emptySlots.length) {\n        const target = emptySlots.shift();\n        await bot.inventory.moveItem(it.slot, target, 1);\n        alreadyGood++;\n      }\n    }\n    // after moving, check again\n    const finalCount = bot.inventory.items().filter(i => i.type === itemId && i.slot >= 3).length;\n    return finalCount >= needed;\n  }\n\n  // ---------- 1\ufe0f\u20e3 raw copper ----------\n  const rawCopperId = mcData.itemsByName[\"raw_copper\"].id;\n  const rawCopperCount = bot.inventory.count(rawCopperId);\n  if (rawCopperCount < 3) {\n    await bot.chat(`\u274c I only have ${rawCopperCount} raw copper. Need 3 to smelt.`);\n    return;\n  }\n  await bot.chat(`\u2705 I have ${rawCopperCount} raw copper, ready to smelt 3.`);\n\n  // ---------- 2\ufe0f\u20e3 furnace ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"furnace\"].id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    await bot.chat(\"No furnace found, trying to place one...\");\n\n    // need furnace item\n    const furnaceItemId = mcData.itemsByName[\"furnace\"].id;\n    const furnaceItem = bot.inventory.findInventoryItem(furnaceItemId);\n    if (!furnaceItem) {\n      await bot.chat(\"\u274c I don't have a furnace item to place.\");\n      return;\n    }\n\n    // find placement spot\n    let placePos = await findFreePlacementSpot(3);\n    while (!placePos) {\n      await bot.chat(\"No free spot nearby, exploring...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(3);\n        return p ? true : null;\n      });\n      if (found) placePos = await findFreePlacementSpot(3);else break;\n    }\n    if (!placePos) {\n      await bot.chat(\"\u274c Could not locate a suitable spot for the furnace.\");\n      return;\n    }\n    await placeItem(bot, \"furnace\", placePos);\n    await bot.chat(`Placed furnace at ${placePos}`);\n    furnaceBlock = bot.blockAt(placePos);\n  } else {\n    await bot.chat(`\u2705 Found a furnace at ${furnaceBlock.position}`);\n  }\n\n  // stand next to furnace\n  await bot.pathfinder.goto(new GoalNear(furnaceBlock.position.x, furnaceBlock.position.y, furnaceBlock.position.z, 1));\n\n  // ---------- 3\ufe0f\u20e3 fuel (birch_log) ----------\n  const birchLogId = mcData.itemsByName[\"birch_log\"].id;\n  const totalBirchLogs = bot.inventory.count(birchLogId);\n  if (totalBirchLogs < 2) {\n    await bot.chat(`\u274c Need at least 2 birch logs for fuel, only have ${totalBirchLogs}.`);\n    return;\n  }\n\n  // make sure at least 2 birch logs are in slots >=3\n  const fuelReady = await relocateFuelToInventory(birchLogId, 2);\n  if (!fuelReady) {\n    await bot.chat(\"\u274c Couldn't move enough birch logs out of the hot\u2011bar for fuel.\");\n    return;\n  }\n  await bot.chat(`\u2705 Fuel prepared: ${bot.inventory.count(birchLogId)} birch logs (\u2265 slot\u202f3).`);\n\n  // ---------- 4\ufe0f\u20e3 smelt ----------\n  await bot.chat(\"\ud83d\udd28 Starting smelting of 3 raw copper...\");\n  await smeltItem(bot, \"raw_copper\", \"birch_log\", 3);\n  await bot.chat(\"\u2705 Smelting finished.\");\n\n  // ---------- 5\ufe0f\u20e3 report ----------\n  const copperIngotId = mcData.itemsByName[\"copper_ingot\"].id;\n  const finalIngotCount = bot.inventory.count(copperIngotId);\n  await bot.chat(`\u2705 I now have ${finalIngotCount} copper ingot(s).`);\n}", "description": "async function smeltThreeCopper(bot) {\n    // The routine checks that the bot has at least three raw copper, finds or places a furnace within a short distance, moves the bot next to the furnace, ensures two birch logs are stored in inventory slots beyond the hot\u2011bar to serve as fuel, smelts the three raw copper into copper ingots, and finally reports the total number of copper ingots now in the inventory.\n}"}, "mineThreeLapis": {"code": "// Main function: mine at least three lapis lazuli\nasync function mineThreeLapis(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- helper: random direction vector ----------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // ---------- helper: ensure a placed crafting table ----------\n  async function ensurePlacedCraftingTable() {\n    const tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (tableBlock) {\n      await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n      await bot.chat(\"Found a placed crafting table.\");\n      return;\n    }\n    // place one from inventory\n    await bot.chat(\"Placing a crafting table...\");\n    const solid = bot.findBlock({\n      matching: b => b.name !== \"air\",\n      maxDistance: 3\n    });\n    const placePos = solid.position.offset(0, 1, 0);\n    await placeItem(bot, \"crafting_table\", placePos);\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat(\"Crafting table placed.\");\n  }\n\n  // ---------- helper: ensure a placed furnace ----------\n  async function ensurePlacedFurnace() {\n    const furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (furnaceBlock) {\n      await bot.pathfinder.goto(new GoalNear(furnaceBlock.position.x, furnaceBlock.position.y, furnaceBlock.position.z, 1));\n      await bot.chat(\"Found a placed furnace.\");\n      return furnaceBlock;\n    }\n    await bot.chat(\"Placing a furnace...\");\n    // need 8 cobblestone \u2013 we already have plenty\n    await ensurePlacedCraftingTable(); // needed to craft furnace\n    await craftItem(bot, \"furnace\", 1);\n    // find a free spot near the bot\n    const solid = bot.findBlock({\n      matching: b => b.name !== \"air\",\n      maxDistance: 3\n    });\n    const placePos = solid.position.offset(0, 1, 0);\n    await placeItem(bot, \"furnace\", placePos);\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat(\"Furnace placed.\");\n    return bot.blockAt(placePos);\n  }\n\n  // ---------- helper: ensure we have enough planks ----------\n  async function ensurePlanks(target) {\n    const plankId = mcData.itemsByName.oak_planks.id;\n    let have = bot.inventory.count(plankId);\n    if (have >= target) return;\n    const need = target - have;\n    const logsNeeded = Math.ceil(need / 4);\n    // ensure logs\n    const logId = mcData.itemsByName.oak_log.id;\n    let logs = bot.inventory.count(logId);\n    if (logs < logsNeeded) {\n      const toMine = logsNeeded - logs;\n      await bot.chat(`Mining ${toMine} oak log(s) for planks...`);\n      await mineBlock(bot, \"oak_log\", toMine);\n    }\n    await ensurePlacedCraftingTable();\n    const craftTimes = Math.ceil(need / 4);\n    await bot.chat(`Crafting ${need} planks (${craftTimes} batch(es))...`);\n    await craftItem(bot, \"oak_planks\", craftTimes);\n  }\n\n  // ---------- helper: ensure we have sticks ----------\n  async function ensureSticks(target) {\n    const stickId = mcData.itemsByName.stick.id;\n    let have = bot.inventory.count(stickId);\n    if (have >= target) return;\n    const need = target - have;\n    const crafts = Math.ceil(need / 4); // 4 sticks per craft\n    const planksNeeded = crafts * 2;\n    await ensurePlanks(planksNeeded);\n    await ensurePlacedCraftingTable();\n    await bot.chat(`Crafting ${need} sticks (${crafts} batch(es))...`);\n    await craftItem(bot, \"stick\", crafts);\n  }\n\n  // ---------- helper: ensure iron ingots ----------\n  async function ensureIronIngots(count) {\n    const ironIngotId = mcData.itemsByName.iron_ingot.id;\n    let have = bot.inventory.count(ironIngotId);\n    if (have >= count) return;\n    const need = count - have;\n\n    // 1 raw_iron per iron ore, so need that many raw_iron\n    const rawId = mcData.itemsByName.raw_iron.id;\n    let rawHave = bot.inventory.count(rawId);\n    const rawNeeded = need - rawHave;\n    if (rawNeeded > 0) {\n      // locate iron ore\n      let oreBlock = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      if (!oreBlock) {\n        await bot.chat(\"Searching for iron ore...\");\n        const found = await exploreUntil(bot, randomDirection(), 60, () => {\n          const blk = bot.findBlock({\n            matching: mcData.blocksByName.iron_ore.id,\n            maxDistance: 32\n          });\n          return blk ? true : null;\n        });\n        if (!found) {\n          await bot.chat(\"\u274c Could not find iron ore.\");\n          return;\n        }\n        oreBlock = bot.findBlock({\n          matching: mcData.blocksByName.iron_ore.id,\n          maxDistance: 32\n        });\n      }\n      await bot.chat(`Mining ${rawNeeded} iron ore block(s)...`);\n      await mineBlock(bot, \"iron_ore\", rawNeeded);\n    }\n\n    // smelt raw iron\n    const furnace = await ensurePlacedFurnace();\n    // ensure fuel (oak planks)\n    await ensurePlanks(need); // 1 plank per smelt is enough\n    await bot.chat(`Smelting ${need} raw iron into ingots...`);\n    await smeltItem(bot, \"raw_iron\", \"oak_planks\", need);\n  }\n\n  // ---------- Step 1: ensure iron pickaxe ----------\n  const ironPickId = mcData.itemsByName.iron_pickaxe.id;\n  if (!bot.inventory.findInventoryItem(ironPickId)) {\n    await bot.chat(\"Iron pickaxe not found, crafting one...\");\n    // need 3 iron ingots and 2 sticks\n    await ensureIronIngots(3);\n    await ensureSticks(2);\n    await ensurePlacedCraftingTable();\n    await bot.chat(\"Crafting iron pickaxe...\");\n    await craftItem(bot, \"iron_pickaxe\", 1);\n    await bot.chat(\"Iron pickaxe crafted.\");\n  } else {\n    await bot.chat(\"Iron pickaxe already in inventory.\");\n  }\n\n  // equip iron pickaxe (optional, but ensures correct tool)\n  const ironPick = bot.inventory.findInventoryItem(ironPickId);\n  if (ironPick) await bot.equip(ironPick, \"hand\");\n\n  // ---------- Step 2: locate and mine lapis lazuli ----------\n  const lapisName = \"lapis_ore\";\n  let lapisBlock = bot.findBlock({\n    matching: mcData.blocksByName[lapisName].id,\n    maxDistance: 32\n  });\n  if (!lapisBlock) {\n    await bot.chat(\"Searching for lapis lazuli ore...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName[lapisName].id,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Could not find lapis lazuli ore.\");\n      return;\n    }\n    lapisBlock = bot.findBlock({\n      matching: mcData.blocksByName[lapisName].id,\n      maxDistance: 32\n    });\n  }\n  await bot.chat(\"Mining lapis lazuli...\");\n  await mineBlock(bot, lapisName, 3); // mine three ore blocks to guarantee \u22653 lapis\n\n  // ---------- Step 3: report result ----------\n  const lapisId = mcData.itemsByName.lapis_lazuli.id;\n  const lapisCount = bot.inventory.count(lapisId);\n  if (lapisCount >= 3) {\n    await bot.chat(`\u2705 Success! I now have ${lapisCount} lapis lazuli.`);\n  } else {\n    await bot.chat(`\u274c Finished but only have ${lapisCount} lapis lazuli.`);\n  }\n}", "description": "async function mineThreeLapis(bot) {\n    // The function first ensures an iron pickaxe is available, crafting one if necessary by gathering iron ingots, sticks, and planks using a crafting table and furnace, then equips it; it searches the surrounding area for lapis lazuli ore, mines three ore blocks to guarantee at least three lapis, and finally checks the inventory count to confirm whether the required amount was obtained.\n}"}, "mineFiveIronOre": {"code": "// main function to mine at least 5 iron ore (raw iron)\nasync function mineFiveIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- 1. equip a suitable pickaxe ----------\n  const pickaxeNames = [\"diamond_pickaxe\", \"netherite_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const id = mcData.itemsByName[name].id;\n    const it = bot.inventory.findInventoryItem(id);\n    if (it) {\n      pickaxeItem = it;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    await bot.chat(\"\u274c No pickaxe found in inventory \u2013 cannot mine iron.\");\n    return;\n  }\n  await bot.equip(pickaxeItem, \"hand\");\n  await bot.chat(`Equipped ${pickaxeItem.name} for mining.`);\n\n  // ---------- helper to count raw iron ----------\n  const rawIronId = mcData.itemsByName[\"raw_iron\"] ? mcData.itemsByName[\"raw_iron\"].id : null; // older versions drop iron_ore directly (treated as block, not item)\n  const getRawIronCount = () => rawIronId ? bot.inventory.count(rawIronId) : 0;\n\n  // ---------- 2\u20114. locate and mine until we have 5 raw iron ----------\n  const neededTotal = 5;\n  while (getRawIronCount() < neededTotal) {\n    const stillNeeded = neededTotal - getRawIronCount();\n    // try to find ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName[\"iron_ore\"].id,\n      maxDistance: 32\n    });\n\n    // if not found, explore randomly until we see one (max 60\u202fs per attempt)\n    if (!oreBlock) {\n      await bot.chat(\"No iron ore nearby \u2013 exploring...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName[\"iron_ore\"].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Exploration failed to locate iron ore.\");\n        return;\n      }\n      oreBlock = bot.findBlock({\n        matching: mcData.blocksByName[\"iron_ore\"].id,\n        maxDistance: 32\n      });\n    }\n\n    // move close enough to the ore (within 2 blocks) before mining\n    await bot.pathfinder.goto(new GoalNear(oreBlock.position.x, oreBlock.position.y, oreBlock.position.z, 2));\n\n    // mine the required amount (may mine more if multiple ores are close)\n    await bot.chat(`Mining up to ${stillNeeded} iron ore block(s)...`);\n    await mineBlock(bot, \"iron_ore\", stillNeeded);\n\n    // short pause to let the inventory update\n    await bot.waitForTicks(10);\n  }\n\n  // ---------- 5. final report ----------\n  const finalCount = getRawIronCount();\n  await bot.chat(`\u2705 Finished mining. Collected ${finalCount} raw iron (need ${neededTotal}).`);\n}\n\n// ---------- random direction helper (components -1,0,1, not all zero) ----------\n\n// ---------- random direction helper (components -1,0,1, not all zero) ----------\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}", "description": "async function mineFiveIronOre(bot) {\n    // The routine equips the best available pickaxe from the inventory, then repeatedly searches for iron ore blocks within a short range, exploring randomly when none are nearby, moves close enough to each found ore, mines the necessary number of blocks, and continues this loop until at least five raw iron items are gathered, finally confirming the collected amount.\n}"}, "ensureIronHelmet": {"code": "// Main function: ensure the bot has at least one iron helmet\nasync function ensureIronHelmet(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- helper: random direction vector ----------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // ---------- helper: ensure a placed crafting table ----------\n  async function ensurePlacedCraftingTable() {\n    const tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (tableBlock) {\n      await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n      await bot.chat('Found a placed crafting table.');\n      return tableBlock;\n    }\n    await bot.chat('Placing a crafting table...');\n    // find a solid block within 3 blocks\n    const solid = bot.findBlock({\n      matching: b => b.name !== 'air',\n      maxDistance: 3\n    });\n    if (!solid) throw new Error('No solid block nearby to place a crafting table on');\n\n    // try to find a free air block directly above or nearby\n    let placePos = null;\n    const candidates = [solid.position.offset(0, 1, 0), solid.position.offset(1, 1, 0), solid.position.offset(-1, 1, 0), solid.position.offset(0, 1, 1), solid.position.offset(0, 1, -1)];\n    for (const p of candidates) {\n      if (bot.blockAt(p).name === 'air') {\n        placePos = p;\n        break;\n      }\n    }\n    if (!placePos) throw new Error('No free space to place a crafting table');\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat('Crafting table placed.');\n    return bot.blockAt(placePos);\n  }\n\n  // ---------- helper: ensure a placed furnace ----------\n  async function ensurePlacedFurnace() {\n    const furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (furnaceBlock) {\n      await bot.pathfinder.goto(new GoalNear(furnaceBlock.position.x, furnaceBlock.position.y, furnaceBlock.position.z, 1));\n      await bot.chat('Found a placed furnace.');\n      return furnaceBlock;\n    }\n    await bot.chat('Placing a furnace...');\n    const solid = bot.findBlock({\n      matching: b => b.name !== 'air',\n      maxDistance: 3\n    });\n    if (!solid) throw new Error('No solid block nearby to place a furnace');\n    const placePos = solid.position.offset(0, 1, 0);\n    await placeItem(bot, 'furnace', placePos);\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    await bot.chat('Furnace placed.');\n    return bot.blockAt(placePos);\n  }\n\n  // ---------- helper: ensure we have enough iron ingots ----------\n  async function ensureIronIngots(required) {\n    const ingotId = mcData.itemsByName.iron_ingot.id;\n    let have = bot.inventory.count(ingotId);\n    if (have >= required) return;\n    const need = required - have;\n    await bot.chat(`Need ${need} more iron ingot(s).`);\n\n    // Ensure raw iron\n    const rawId = mcData.itemsByName.raw_iron.id;\n    let rawHave = bot.inventory.count(rawId);\n    const rawNeeded = need - rawHave;\n    if (rawNeeded > 0) {\n      // Locate iron ore, explore if necessary\n      let ore = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      if (!ore) {\n        await bot.chat('Searching for iron ore...');\n        const found = await exploreUntil(bot, randomDirection(), 60, () => {\n          const blk = bot.findBlock({\n            matching: mcData.blocksByName.iron_ore.id,\n            maxDistance: 32\n          });\n          return blk ? true : null;\n        });\n        if (!found) throw new Error('Iron ore not found');\n        ore = bot.findBlock({\n          matching: mcData.blocksByName.iron_ore.id,\n          maxDistance: 32\n        });\n      }\n      await bot.chat(`Mining ${rawNeeded} iron ore block(s)...`);\n      await mineBlock(bot, 'iron_ore', rawNeeded);\n    }\n\n    // Ensure furnace\n    await ensurePlacedFurnace();\n\n    // Use oak planks as fuel (they are common)\n    await bot.chat(`Smelting ${need} raw iron into ingots...`);\n    await smeltItem(bot, 'raw_iron', 'oak_planks', need);\n  }\n\n  // ---------- Step 0: check if we already have a helmet ----------\n  const helmetId = mcData.itemsByName.iron_helmet.id;\n  if (bot.inventory.count(helmetId) > 0) {\n    await bot.chat('\u2705 I already have an iron helmet. No further action needed.');\n    return;\n  }\n\n  // ---------- Step 1: gather materials ----------\n  await ensureIronIngots(5);\n  await bot.chat('Enough iron ingots are ready.');\n\n  // ---------- Step 2: ensure a crafting table ----------\n  await ensurePlacedCraftingTable();\n\n  // ---------- Step 3: craft the helmet ----------\n  await bot.chat('Crafting an iron helmet...');\n  await craftItem(bot, 'iron_helmet', 1);\n  await bot.chat('\u2705 Iron helmet crafted!');\n\n  // ---------- Final verification ----------\n  const finalCount = bot.inventory.count(helmetId);\n  if (finalCount > 0) {\n    await bot.chat(`I now have ${finalCount} iron helmet(s) in my inventory.`);\n  } else {\n    await bot.chat('\u274c Something went wrong \u2013 no iron helmet was created.');\n  }\n}", "description": "async function ensureIronHelmet(bot) {\n    // The routine first checks the inventory for an iron helmet and returns immediately if one is found; otherwise it gathers at least five iron ingots by mining ore and smelting, ensures a crafting table and furnace are placed nearby, crafts a single iron helmet, and finally verifies that the helmet now exists in the inventory.\n}"}, "equipIronHelmet": {"code": "// ------------------------------------------------------------\n// Helper: place a crafting table if none is already placed\nasync function ensurePlacedCraftingTable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // Is there a placed table already?\n  const placed = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (placed) {\n    await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n    await bot.chat('Found a placed crafting table.');\n    return placed;\n  }\n\n  // Need to place one from inventory\n  const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n  if (!tableItem) throw new Error('No crafting table item in inventory.');\n\n  // Find a solid block within 3 blocks to place on\n  const solid = bot.findBlock({\n    matching: b => b.name !== 'air',\n    maxDistance: 3\n  });\n  if (!solid) throw new Error('No solid block nearby to place a crafting table on.');\n  const placePos = solid.position.offset(0, 1, 0); // air block above solid\n  await bot.chat(`Placing crafting table at ${placePos}`);\n  await placeItem(bot, 'crafting_table', placePos);\n  await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n  await bot.chat('Crafting table placed.');\n  return bot.blockAt(placePos);\n}\n\n// ------------------------------------------------------------\n// Helper: place a furnace if none is already placed\n\n// ------------------------------------------------------------\n// Helper: place a furnace if none is already placed\nasync function ensurePlacedFurnace(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const placed = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (placed) {\n    await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n    await bot.chat('Found a placed furnace.');\n    return placed;\n  }\n\n  // Need furnace item in inventory\n  const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n  if (!furnaceItem) throw new Error('No furnace item in inventory.');\n\n  // Find a solid block nearby\n  const solid = bot.findBlock({\n    matching: b => b.name !== 'air',\n    maxDistance: 3\n  });\n  if (!solid) throw new Error('No solid block nearby to place a furnace on.');\n  const placePos = solid.position.offset(0, 1, 0);\n  await bot.chat(`Placing furnace at ${placePos}`);\n  await placeItem(bot, 'furnace', placePos);\n  await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n  await bot.chat('Furnace placed.');\n  return bot.blockAt(placePos);\n}\n\n// ------------------------------------------------------------\n// Helper: ensure we have at least `target` iron ingots\n\n// ------------------------------------------------------------\n// Helper: ensure we have at least `target` iron ingots\nasync function ensureIronIngots(bot, target) {\n  const mcData = require('minecraft-data')(bot.version);\n  const ingotId = mcData.itemsByName.iron_ingot.id;\n  let have = bot.inventory.count(ingotId);\n  if (have >= target) return;\n  const need = target - have;\n  await bot.chat(`Need ${need} more iron ingot(s).`);\n\n  // 1\ufe0f\u20e3 Get raw iron (mine iron ore)\n  const rawId = mcData.itemsByName.raw_iron.id;\n  let rawHave = bot.inventory.count(rawId);\n  const rawNeeded = need - rawHave;\n  if (rawNeeded > 0) {\n    // Find iron ore, explore if necessary\n    let ore = bot.findBlock({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32\n    });\n    if (!ore) {\n      await bot.chat('Searching for iron ore...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName.iron_ore.id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) throw new Error('Iron ore not found.');\n      ore = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n    }\n    await bot.chat(`Mining ${rawNeeded} iron ore block(s)...`);\n    await mineBlock(bot, 'iron_ore', rawNeeded);\n  }\n\n  // 2\ufe0f\u20e3 Smelt raw iron \u2192 ingots\n  const furnace = await ensurePlacedFurnace(bot);\n  // Use any fuel we have (coal, wood, planks, etc.). We'll just use coal if available.\n  const fuelName = bot.inventory.findInventoryItem(mcData.itemsByName.coal.id) ? 'coal' : 'oak_planks';\n  await bot.chat(`Smelting ${need} raw iron into ingots using ${fuelName} as fuel...`);\n  await smeltItem(bot, 'raw_iron', fuelName, need);\n}\n\n// ------------------------------------------------------------\n// Helper: random direction vector (components -1,0,1, not all zero)\n\n// ------------------------------------------------------------\n// Helper: random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// ------------------------------------------------------------\n// Main function: equip an iron helmet (crafting if necessary)\n\n// ------------------------------------------------------------\n// Main function: equip an iron helmet (crafting if necessary)\nasync function equipIronHelmet(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const helmetId = mcData.itemsByName.iron_helmet.id;\n\n  // 1\ufe0f\u20e3 Is a helmet already equipped?\n  if (bot.inventory.slots[5] && bot.inventory.slots[5].type === helmetId) {\n    await bot.chat('\u2705 Iron helmet is already equipped.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Do we have a helmet in inventory?\n  let helmetItem = bot.inventory.findInventoryItem(helmetId);\n  if (helmetItem) {\n    await bot.chat('Found iron helmet in inventory, equipping...');\n    await bot.equip(helmetItem, 'head');\n    await bot.chat('\u2705 Iron helmet equipped.');\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Helmet missing \u2013 we need to craft it\n  await bot.chat('Iron helmet not in inventory, preparing to craft one.');\n\n  // 3a. Ensure we have at least 5 iron ingots\n  await ensureIronIngots(bot, 5);\n\n  // 3b. Ensure a crafting table is placed\n  await ensurePlacedCraftingTable(bot);\n\n  // 3c. Craft the helmet\n  await bot.chat('Crafting iron helmet...');\n  await craftItem(bot, 'iron_helmet', 1);\n  await bot.chat('Iron helmet crafted.');\n\n  // 3d. Equip the newly crafted helmet\n  helmetItem = bot.inventory.findInventoryItem(helmetId);\n  if (!helmetItem) {\n    await bot.chat('\u274c Unexpected error: helmet not found after crafting.');\n    return;\n  }\n  await bot.equip(helmetItem, 'head');\n  await bot.chat('\u2705 Iron helmet equipped.');\n}", "description": "async function equipIronHelmet(bot) {\n    // The routine first checks whether an iron helmet is already worn; if not, it searches the inventory and equips it if present, otherwise it gathers at least five iron ingots, places a crafting table if none is nearby, crafts an iron helmet using that table, then locates the newly crafted helmet in the inventory and equips it on the head, handling missing resources as errors.\n}"}, "mineEightIronIngot": {"code": "// Main function: mine enough iron ore and smelt to have at least 8 iron ingots\nasync function mineEightIronIngot(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // ----- helper: random direction vector (components -1,0,1, not all zero) -----\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // ----- helper: find a free air block directly above a solid block -----\n  async function findPlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === 'air') continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n\n  // ----- 1\ufe0f\u20e3 check current iron ingots -----\n  const ironIngotId = mcData.itemsByName.iron_ingot.id;\n  let ironIngots = bot.inventory.count(ironIngotId);\n  if (ironIngots >= 8) {\n    await bot.chat(`\u2705 I already have ${ironIngots} iron ingots. Task complete.`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd0e I have ${ironIngots} iron ingots, need ${8 - ironIngots} more.`);\n\n  // ----- 2\ufe0f\u20e3 ensure a pickaxe that can mine iron ore (stone or better) -----\n  const pickaxeNames = ['stone_pickaxe', 'iron_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const id = mcData.itemsByName[name].id;\n    const it = bot.inventory.findInventoryItem(id);\n    if (it) {\n      pickaxeItem = it;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    await bot.chat('\u274c No suitable pickaxe found. Cannot mine iron ore.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n  await bot.chat(`Equipped ${pickaxeItem.name} for mining.`);\n\n  // ----- 3\ufe0f\u20e3 ensure a furnace block is placed -----\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    await bot.chat('No furnace found, placing one...');\n    // need a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n    // find a free spot\n    let placePos = await findPlacementSpot(3);\n    while (!placePos) {\n      await bot.chat('Exploring for a free spot to place furnace...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findPlacementSpot(3);\n        return p ? true : null;\n      });\n      if (found) placePos = await findPlacementSpot(3);else break;\n    }\n    if (!placePos) {\n      await bot.chat('\u274c Could not locate a suitable placement spot for the furnace.');\n      return;\n    }\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    await bot.chat(`Furnace placed at ${placePos}.`);\n  } else {\n    await bot.chat(`Found existing furnace at ${furnaceBlock.position}.`);\n  }\n\n  // ----- 4\ufe0f\u20e3 mine needed iron ore -----\n  const neededIngots = 8 - ironIngots;\n  // each iron ore gives 1 raw_iron, which smelts to 1 iron_ingot\n  const neededOre = neededIngots;\n  await bot.chat(`Mining ${neededOre} iron ore block(s)...`);\n\n  // try to find ore nearby first\n  let oreBlock = bot.findBlock({\n    matching: mcData.blocksByName.iron_ore.id,\n    maxDistance: 32\n  });\n  if (!oreBlock) {\n    await bot.chat('Iron ore not nearby, exploring...');\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mcData.blocksByName.iron_ore.id,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat('\u274c Could not locate any iron ore.');\n      return;\n    }\n    oreBlock = bot.findBlock({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32\n    });\n  }\n\n  // Mine the required amount (mineBlock will stop early if not enough blocks)\n  await mineBlock(bot, 'iron_ore', neededOre);\n  await bot.chat(`Finished mining iron ore.`);\n\n  // ----- 5\ufe0f\u20e3 smelt the raw iron -----\n  // ensure we have enough fuel (coal); one coal smelts 8 items, we need at most neededIngots\n  const coalId = mcData.itemsByName.coal.id;\n  const coalCount = bot.inventory.count(coalId);\n  if (coalCount === 0) {\n    await bot.chat('\u274c No coal for fuel. Cannot smelt.');\n    return;\n  }\n  await bot.chat(`Smelting ${neededOre} raw iron using coal...`);\n  await smeltItem(bot, 'raw_iron', 'coal', neededOre);\n  await bot.chat('Smelting complete.');\n\n  // ----- 6\ufe0f\u20e3 final report -----\n  ironIngots = bot.inventory.count(ironIngotId);\n  if (ironIngots >= 8) {\n    await bot.chat(`\u2705 Success! I now have ${ironIngots} iron ingots.`);\n  } else {\n    await bot.chat(`\u274c Finished but only have ${ironIngots} iron ingots.`);\n  }\n}", "description": "async function mineEightIronIngot(bot) {\n    // The function ensures the bot has at least eight iron ingots by checking the current ingot count, equipping a suitable pickaxe, placing a furnace if none is found, mining the needed iron ore, smelting the raw iron using available coal, and finally confirming the final ingot total.\n}"}, "craftIronChestplate": {"code": "// -----------------------------------------------------------------------------\n// Helper: find a free air block directly above a solid block within a radius\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n      }\n    }\n  }\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Main function: craft an iron chestplate\n\n// -----------------------------------------------------------------------------\n// Main function: craft an iron chestplate\nasync function craftIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Ensure we have enough iron ingots\n  const ironIngotId = mcData.itemsByName[\"iron_ingot\"].id;\n  const haveIngots = bot.inventory.count(ironIngotId);\n  if (haveIngots < 5) {\n    await bot.chat(`\u274c I only have ${haveIngots} iron ingots; need 5 to craft a chestplate.`);\n    return;\n  }\n  await bot.chat(`\u2705 I have ${haveIngots} iron ingots, enough for a chestplate.`);\n\n  // 2\ufe0f\u20e3 Locate or place a crafting table\n  const tableId = mcData.blocksByName[\"crafting_table\"].id;\n  let tableBlock = bot.findBlock({\n    matching: tableId,\n    maxDistance: 32\n  });\n  if (tableBlock) {\n    await bot.chat(`\u2705 Found a placed crafting table at ${tableBlock.position}.`);\n    // Move next to it (within 1 block)\n    await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n  } else {\n    await bot.chat(\"\ud83d\udd28 No placed crafting table nearby \u2013 I will place one.\");\n\n    // Ensure we have a crafting table item in inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"crafting_table\"].id);\n    if (!tableItem) {\n      await bot.chat(\"\u274c I don't have a crafting table item to place.\");\n      return;\n    }\n\n    // Find a free spot to place it\n    let placePos = await findFreePlacementSpot(bot, 3);\n    // If not found, explore a bit and try again\n    while (!placePos) {\n      await bot.chat(\"Exploring for a suitable spot to place the crafting table...\");\n      await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(bot, 3);\n        return p ? true : null;\n      });\n      placePos = await findFreePlacementSpot(bot, 3);\n      if (!placePos) break;\n    }\n    if (!placePos) {\n      await bot.chat(\"\u274c Could not find a free location to place the crafting table.\");\n      return;\n    }\n\n    // Place the table\n    await placeItem(bot, \"crafting_table\", placePos);\n    await bot.chat(`\u2705 Placed crafting table at ${placePos}.`);\n    // Move next to it\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    tableBlock = bot.blockAt(placePos);\n  }\n\n  // 3\ufe0f\u20e3 Craft the iron chestplate\n  await bot.chat(\"\ud83d\udee0\ufe0f Crafting iron chestplate...\");\n  try {\n    await craftItem(bot, \"iron_chestplate\", 1);\n    await bot.chat(\"\u2705 Iron chestplate crafted successfully!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft iron chestplate: ${err.message}`);\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Optional: equip the chestplate (if desired)\n  const chestplateItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"iron_chestplate\"].id);\n  if (chestplateItem) {\n    await bot.equip(chestplateItem, \"torso\");\n    await bot.chat(\"\ud83d\udee1\ufe0f Iron chestplate equipped.\");\n  }\n}\n\n// Helper: random direction vector (components -1,0,1, not all zero)\n\n// Helper: random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}", "description": "async function craftIronChestplate(bot) {\n    // The routine first verifies that the inventory contains at least five iron ingots, then looks for a nearby crafting table and moves within one block of it, placing a new table on a suitable free spot above solid ground if none is found; after positioning at the table it crafts one iron chestplate and, if the item appears in the inventory, equips it on the torso.\n}"}, "craftIronSword": {"code": "// ------------------------------------------------------------\n// Helper: pick a random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// Helper: find a free air block directly above a solid block within a radius\n\n// Helper: find a free air block directly above a solid block within a radius\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === \"air\") {\n          // ensure the block below the above block is solid (already checked)\n          return abovePos;\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// ------------------------------------------------------------\n// Main function: craft one iron sword\n\n// ------------------------------------------------------------\n// Main function: craft one iron sword\nasync function craftIronSword(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Verify required materials\n  const ironIngotId = mcData.itemsByName[\"iron_ingot\"].id;\n  const stickId = mcData.itemsByName[\"stick\"].id;\n  const haveIron = bot.inventory.count(ironIngotId);\n  const haveSticks = bot.inventory.count(stickId);\n  if (haveIron < 2) {\n    await bot.chat(`\u274c Need 2 iron ingots, only have ${haveIron}.`);\n    return;\n  }\n  if (haveSticks < 1) {\n    await bot.chat(`\u274c Need a stick, none in inventory.`);\n    return;\n  }\n  await bot.chat(`\u2705 Materials OK (Iron: ${haveIron}, Sticks: ${haveSticks}).`);\n\n  // 2\ufe0f\u20e3 Ensure a placed crafting table\n  async function ensureCraftingTable() {\n    // Look for an already placed table\n    const placed = bot.findBlock({\n      matching: mcData.blocksByName[\"crafting_table\"].id,\n      maxDistance: 32\n    });\n    if (placed) {\n      await bot.chat(`Found placed crafting table at ${placed.position}.`);\n      await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n      return placed;\n    }\n\n    // No placed table \u2013 need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"crafting_table\"].id);\n    if (!tableItem) {\n      await bot.chat(`\u274c No crafting table item in inventory to place.`);\n      throw new Error(\"Missing crafting table item\");\n    }\n\n    // Find a free spot nearby\n    let placePos = await findFreePlacementSpot(bot, 3);\n    // If not found, explore until we locate one\n    while (!placePos) {\n      await bot.chat(\"Exploring for a free spot to place the crafting table...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(bot, 3);\n        return p ? true : null;\n      });\n      if (!found) break;\n      placePos = await findFreePlacementSpot(bot, 3);\n    }\n    if (!placePos) {\n      await bot.chat(\"\u274c Could not find a suitable location for the crafting table.\");\n      throw new Error(\"No placement spot\");\n    }\n\n    // Place the table\n    await bot.chat(`Placing crafting table at ${placePos}...`);\n    await placeItem(bot, \"crafting_table\", placePos);\n    // Move next to it\n    await bot.pathfinder.goto(new GoalNear(placePos.x, placePos.y, placePos.z, 1));\n    const placedBlock = bot.blockAt(placePos);\n    await bot.chat(\"Crafting table placed.\");\n    return placedBlock;\n  }\n  try {\n    await ensureCraftingTable();\n  } catch (e) {\n    await bot.chat(`\u274c Failed to ensure crafting table: ${e.message}`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Craft the iron sword\n  await bot.chat(\"Crafting iron sword...\");\n  try {\n    await craftItem(bot, \"iron_sword\", 1);\n    await bot.chat(\"\u2705 Iron sword crafted!\");\n  } catch (err) {\n    await bot.chat(`\u274c Crafting failed: ${err.message}`);\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Verify result\n  const swordId = mcData.itemsByName[\"iron_sword\"].id;\n  const swordCount = bot.inventory.count(swordId);\n  if (swordCount >= 1) {\n    await bot.chat(`\u2705 Task complete: I now have ${swordCount} iron sword(s).`);\n  } else {\n    await bot.chat(\"\u274c Task finished but no iron sword found in inventory.\");\n  }\n}", "description": "async function craftIronSword(bot) {\n    // The routine first checks that the bot has at least two iron ingots and one stick, then ensures a crafting table is available by either finding one nearby or placing one on a free air block, moves next to the table, crafts a single iron sword, and finally verifies the sword appears in the inventory, aborting if any step fails.\n}"}, "craftIronLeggings": {"code": "// Main function: craft iron leggings\nasync function craftIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Ensure we have enough iron ingots (7 needed)\n  const ironIngotId = mcData.itemsByName.iron_ingot.id;\n  const haveIngots = bot.inventory.count(ironIngotId);\n  if (haveIngots < 7) {\n    await bot.chat(`\u274c I only have ${haveIngots} iron ingot(s); need 7 to craft leggings.`);\n    return;\n  }\n  await bot.chat(`\u2705 Iron ingots OK: ${haveIngots}/7`);\n\n  // 2\ufe0f\u20e3 Find (or place) a crafting table\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n\n  // Helper: find a free air spot above a solid block within a radius\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === \"air\") continue; // need solid\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n  if (!tableBlock) {\n    await bot.chat(\"No placed crafting table found \u2013 placing one.\");\n    // Ensure we have a crafting table item\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat(\"\u274c I don't have a crafting table item in my inventory.\");\n      return;\n    }\n    const placePos = await findFreePlacementSpot(3);\n    if (!placePos) {\n      await bot.chat(\"\u274c Couldn't find a free spot to place a crafting table.\");\n      return;\n    }\n    await placeItem(bot, \"crafting_table\", placePos);\n    tableBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Crafting table placed at ${placePos}`);\n  } else {\n    await bot.chat(`\u2705 Found a placed crafting table at ${tableBlock.position}`);\n  }\n\n  // 3\ufe0f\u20e3 Move next to the crafting table\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // 4\ufe0f\u20e3 Craft iron leggings\n  await bot.chat(\"Crafting iron leggings...\");\n  try {\n    await craftItem(bot, \"iron_leggings\", 1);\n    await bot.chat(\"\u2705 Iron leggings crafted!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft iron leggings: ${err.message}`);\n  }\n}", "description": "async function craftIronLeggings(bot) {\n    // The routine verifies the inventory contains at least seven iron ingots, locates a crafting table within 32 blocks or places one on a free air spot above a solid block, moves the bot to stand next to the table, and then crafts a single set of iron leggings.\n}"}, "mineFourIronOre": {"code": "// main function: mine four iron ore blocks\nasync function mineFourIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // helper: random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n  await bot.chat(\"=== Goal: mine 4 iron ore ===\");\n\n  // -------------------------------------------------\n  // 1) Ensure we have a stone pickaxe or better\n  // -------------------------------------------------\n  const pickaxeNames = [\"wooden_pickaxe\", \"stone_pickaxe\", \"iron_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  const hasPickaxe = pickaxeNames.some(name => bot.inventory.findInventoryItem(mcData.itemsByName[name].id));\n  if (!hasPickaxe) {\n    await bot.chat(\"No pickaxe found \u2013 crafting a stone pickaxe.\");\n\n    // ---- 1a) Ensure cobblestone (3) ----\n    const cobId = mcData.itemsByName.cobblestone.id;\n    let cobCount = bot.inventory.count(cobId);\n    if (cobCount < 3) {\n      const need = 3 - cobCount;\n      await bot.chat(`Mining ${need} stone for cobblestone...`);\n      await mineBlock(bot, \"stone\", need);\n    }\n\n    // ---- 1b) Ensure sticks (2) ----\n    const stickId = mcData.itemsByName.stick.id;\n    let stickCount = bot.inventory.count(stickId);\n    if (stickCount < 2) {\n      const needSticks = 2 - stickCount;\n\n      // need planks: each craft of sticks uses 2 planks \u2192 yields 4 sticks\n      const stickCrafts = Math.ceil(needSticks / 4);\n      const planksNeeded = stickCrafts * 2;\n\n      // ensure planks\n      const plankId = mcData.itemsByName.oak_planks.id;\n      let plankCount = bot.inventory.count(plankId);\n      if (plankCount < planksNeeded) {\n        const missingPlanks = planksNeeded - plankCount;\n        // ensure logs\n        const logId = mcData.itemsByName.oak_log.id;\n        let logCount = bot.inventory.count(logId);\n        const logsNeeded = Math.ceil(missingPlanks / 4);\n        if (logCount < logsNeeded) {\n          await bot.chat(`Mining ${logsNeeded - logCount} oak log(s) for planks...`);\n          await mineBlock(bot, \"oak_log\", logsNeeded - logCount);\n        }\n        const plankBatches = Math.ceil(missingPlanks / 4);\n        await bot.chat(`Crafting ${plankBatches} batch(es) of oak planks...`);\n        await craftItem(bot, \"oak_planks\", plankBatches);\n      }\n      await bot.chat(`Crafting ${stickCrafts} batch(es) of sticks...`);\n      await craftItem(bot, \"stick\", stickCrafts);\n    }\n\n    // ---- 1c) Ensure a crafting table is placed ----\n    let tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat(\"Placing a crafting table for the pickaxe...\");\n      // find a solid block within 3 blocks of the bot\n      const solid = bot.findBlock({\n        matching: b => b.name !== \"air\",\n        maxDistance: 3\n      });\n      if (!solid) throw new Error(\"No solid block nearby to place a crafting table.\");\n      const placePos = solid.position.offset(0, 1, 0); // air block above solid\n      await placeItem(bot, \"crafting_table\", placePos);\n      tableBlock = bot.blockAt(placePos);\n    }\n    // walk to the table so we can use it\n    await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n    // ---- 1d) Craft the stone pickaxe ----\n    await bot.chat(\"Crafting stone pickaxe...\");\n    await craftItem(bot, \"stone_pickaxe\", 1);\n    await bot.chat(\"Stone pickaxe ready.\");\n  } else {\n    await bot.chat(\"Pickaxe already in inventory.\");\n  }\n\n  // -------------------------------------------------\n  // 2) Mine iron ore until we have 4 blocks\n  // -------------------------------------------------\n  let mined = 0;\n  while (mined < 4) {\n    // try to locate iron ore within 32 blocks\n    let ironBlock = bot.findBlock({\n      matching: mcData.blocksByName.iron_ore.id,\n      maxDistance: 32\n    });\n    if (!ironBlock) {\n      await bot.chat(\"Iron ore not nearby \u2013 exploring...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName.iron_ore.id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not locate iron ore after exploring. Stopping.\");\n        return;\n      }\n      continue; // after exploration loop again to find the block\n    }\n\n    // mine a single iron ore block\n    await mineBlock(bot, \"iron_ore\", 1);\n    mined++;\n    await bot.chat(`Mined ${mined}/4 iron ore blocks.`);\n  }\n  await bot.chat(\"\u2705 Finished mining 4 iron ore blocks.\");\n}", "description": "async function mineFourIronOre(bot) {\n    // The routine first checks the inventory for any pickaxe and, if none is present, gathers cobblestone, sticks, and wood, places a crafting table if needed, and crafts a stone pickaxe. It then ensures the pickaxe is equipped. It repeatedly searches for iron ore within a short range, and when none is found it explores in random directions until ore is located. Each found ore block is mined individually, incrementing a counter toward four. The loop continues until four iron ore blocks have been collected. The process then terminates.\n}"}, "craftIronBoots": {"code": "// main function to craft one iron boot pair\nasync function craftIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- 1. Ensure we have at least 4 iron ingots ----------\n  const ironIngotId = mcData.itemsByName[\"iron_ingot\"].id;\n  let ironCount = bot.inventory.count(ironIngotId);\n  if (ironCount < 4) {\n    await bot.chat(`I only have ${ironCount} iron ingot(s). Smelting raw iron...`);\n    // smelt raw_iron one by one until we have 4 ingots\n    while (ironCount < 4) {\n      const rawIronId = mcData.itemsByName[\"raw_iron\"].id;\n      const coalId = mcData.itemsByName[\"coal\"].id;\n\n      // check we have raw iron and coal\n      if (!bot.inventory.findInventoryItem(rawIronId) || !bot.inventory.findInventoryItem(coalId)) {\n        await bot.chat(\"\u274c Not enough raw iron or coal to smelt more ingots.\");\n        return;\n      }\n      await smeltItem(bot, \"raw_iron\", \"coal\", 1);\n      ironCount = bot.inventory.count(ironIngotId);\n      await bot.chat(`Smelted 1 iron ingot. Total now: ${ironCount}`);\n    }\n  } else {\n    await bot.chat(`I have ${ironCount} iron ingots \u2013 enough for boots.`);\n  }\n\n  // ---------- 2. Ensure a placed crafting table ----------\n  const tableBlockId = mcData.blocksByName[\"crafting_table\"].id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat(\"No placed crafting table nearby \u2013 will place one.\");\n\n    // make sure we have a crafting table item\n    const tableItemId = mcData.itemsByName[\"crafting_table\"].id;\n    const tableItem = bot.inventory.findInventoryItem(tableItemId);\n    if (!tableItem) {\n      await bot.chat(\"\u274c I don't have a crafting table item to place.\");\n      return;\n    }\n\n    // find a free air block directly above a solid block within 3 blocks radius\n    const botPos = bot.entity.position.floored();\n    let placePos = null;\n    for (let dx = -2; dx <= 2 && !placePos; dx++) {\n      for (let dy = -1; dy <= 2 && !placePos; dy++) {\n        for (let dz = -2; dz <= 2 && !placePos; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === \"air\") {\n            placePos = abovePos;\n          }\n        }\n      }\n    }\n\n    // if still not found, explore a bit and try again\n    if (!placePos) {\n      await bot.chat(\"Exploring for a suitable spot to place the crafting table...\");\n      const randomDirection = () => {\n        const choices = [-1, 0, 1];\n        let v;\n        do {\n          v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n        } while (v.x === 0 && v.y === 0 && v.z === 0);\n        return v;\n      };\n      await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = (() => {\n          const botPos2 = bot.entity.position.floored();\n          for (let dx = -2; dx <= 2; dx++) {\n            for (let dy = -1; dy <= 2; dy++) {\n              for (let dz = -2; dz <= 2; dz++) {\n                const solidPos = botPos2.offset(dx, dy, dz);\n                const solidBlock = bot.blockAt(solidPos);\n                if (!solidBlock || solidBlock.name === \"air\") continue;\n                const abovePos = solidPos.offset(0, 1, 0);\n                const aboveBlock = bot.blockAt(abovePos);\n                if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n              }\n            }\n          }\n          return null;\n        })();\n        return p ? true : null;\n      });\n      // try to locate again after exploration\n      const botPos2 = bot.entity.position.floored();\n      outer: for (let dx = -2; dx <= 2; dx++) {\n        for (let dy = -1; dy <= 2; dy++) {\n          for (let dz = -2; dz <= 2; dz++) {\n            const solidPos = botPos2.offset(dx, dy, dz);\n            const solidBlock = bot.blockAt(solidPos);\n            if (!solidBlock || solidBlock.name === \"air\") continue;\n            const abovePos = solidPos.offset(0, 1, 0);\n            const aboveBlock = bot.blockAt(abovePos);\n            if (aboveBlock && aboveBlock.name === \"air\") {\n              placePos = abovePos;\n              break outer;\n            }\n          }\n        }\n      }\n    }\n    if (!placePos) {\n      await bot.chat(\"\u274c Could not find a free spot to place a crafting table.\");\n      return;\n    }\n    await placeItem(bot, \"crafting_table\", placePos);\n    await bot.chat(`Placed crafting table at ${placePos}`);\n    // update reference\n    tableBlock = bot.blockAt(placePos);\n  } else {\n    await bot.chat(`Found a placed crafting table at ${tableBlock.position}`);\n  }\n\n  // move next to the table (within 1 block) \u2013 ensures the crafting UI can be opened\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // ---------- 3. Craft the iron boots ----------\n  await bot.chat(\"Crafting iron boots...\");\n  try {\n    await craftItem(bot, \"iron_boots\", 1);\n    await bot.chat(\"\u2705 Iron boots crafted!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft iron boots: ${err.message}`);\n    return;\n  }\n\n  // ---------- 4. Verify ----------\n  const bootsId = mcData.itemsByName[\"iron_boots\"].id;\n  const boots = bot.inventory.findInventoryItem(bootsId);\n  if (boots) {\n    await bot.chat(\"\ud83d\udee1\ufe0f Iron boots are now in my inventory.\");\n  } else {\n    await bot.chat(\"\u26a0\ufe0f Something went wrong \u2013 boots not found in inventory.\");\n  }\n}", "description": "async function craftIronBoots(bot) {\n    // The routine first checks the inventory for at least four iron ingots and, if insufficient, repeatedly smelts raw iron using coal until the required amount is obtained. It then searches for a nearby placed crafting table; if none is found, it locates a suitable air block above solid ground, places a crafting table there, and updates the reference. After positioning the bot within one block of the table, it opens the crafting interface and creates one pair of iron boots. Finally, it confirms that the crafted boots appear in the inventory.\n}"}, "equipIronLeggings": {"code": "// Main function to equip iron leggings\nasync function equipIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const leggingsId = mcData.itemsByName[\"iron_leggings\"].id;\n  const ingotId = mcData.itemsByName[\"iron_ingot\"].id;\n  const rawIronId = mcData.itemsByName[\"raw_iron\"].id;\n  const coalId = mcData.itemsByName[\"coal\"].id;\n  const tableItemId = mcData.itemsByName[\"crafting_table\"].id;\n  const tableBlockId = mcData.blocksByName[\"crafting_table\"].id;\n\n  // 1\ufe0f\u20e3 Check if leggings are already equipped\n  const equippedLeggings = bot.inventory.slots.filter(slot => slot && slot.type === \"armor\" && slot.slot === 2 // slot 2 = legs in Mineflayer\n  )[0];\n  if (equippedLeggings && equippedLeggings.type === \"armor\" && equippedLeggings.name === \"iron_leggings\") {\n    await bot.chat(\"\u2705 Iron leggings are already equipped.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have iron leggings in inventory\n  let leggingsItem = bot.inventory.findInventoryItem(leggingsId);\n  if (!leggingsItem) {\n    await bot.chat(\"\ud83d\udd28 I don't have iron leggings yet, preparing to craft them.\");\n\n    // ---- 2a. Ensure enough iron ingots (7 needed) ----\n    let ingotCount = bot.inventory.count(ingotId);\n    const neededIngot = 7;\n    if (ingotCount < neededIngot) {\n      const missing = neededIngot - ingotCount;\n      await bot.chat(`\ud83e\udea8 Need ${missing} more iron ingot(s). Smelting raw iron...`);\n      // Smelt raw iron one by one until we have enough ingots\n      while (bot.inventory.count(ingotId) < neededIngot) {\n        // Check we have raw iron and coal\n        if (!bot.inventory.findInventoryItem(rawIronId) || !bot.inventory.findInventoryItem(coalId)) {\n          await bot.chat(\"\u274c Not enough raw iron or coal to smelt more ingots.\");\n          return;\n        }\n        await smeltItem(bot, \"raw_iron\", \"coal\", 1);\n        await bot.chat(`\u2705 Smelted 1 iron ingot. Total now: ${bot.inventory.count(ingotId)}`);\n      }\n    }\n\n    // ---- 2b. Ensure a placed crafting table exists ----\n    let placedTable = bot.findBlock({\n      matching: tableBlockId,\n      maxDistance: 32\n    });\n    if (!placedTable) {\n      await bot.chat(\"\ud83e\udeb5 No placed crafting table nearby, placing one.\");\n      // Ensure we have the crafting table item\n      const tableItem = bot.inventory.findInventoryItem(tableItemId);\n      if (!tableItem) {\n        await bot.chat(\"\u274c I don't have a crafting table item to place.\");\n        return;\n      }\n      // Choose a free spot next to the bot (one block east)\n      const placePos = bot.entity.position.floored().offset(1, 0, 0);\n      await placeItem(bot, \"crafting_table\", placePos);\n      await bot.chat(`\u2705 Crafting table placed at ${placePos}`);\n    } else {\n      await bot.chat(`\u2705 Found placed crafting table at ${placedTable.position}`);\n    }\n\n    // ---- 2c. Craft the leggings ----\n    await bot.chat(\"\ud83d\udee0\ufe0f Crafting iron leggings...\");\n    try {\n      await craftItem(bot, \"iron_leggings\", 1);\n      await bot.chat(\"\u2705 Iron leggings crafted.\");\n    } catch (err) {\n      await bot.chat(`\u274c Failed to craft iron leggings: ${err.message}`);\n      return;\n    }\n\n    // Refresh reference to the newly crafted item\n    leggingsItem = bot.inventory.findInventoryItem(leggingsId);\n    if (!leggingsItem) {\n      await bot.chat(\"\u274c Something went wrong, leggings not found after crafting.\");\n      return;\n    }\n  } else {\n    await bot.chat(\"\u2705 Iron leggings already in inventory.\");\n  }\n\n  // 3\ufe0f\u20e3 Equip the leggings\n  try {\n    await bot.equip(leggingsItem, \"legs\");\n    await bot.chat(\"\ud83d\udee1\ufe0f Iron leggings equipped successfully!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip iron leggings: ${err.message}`);\n  }\n}", "description": "async function equipIronLeggings(bot) {\n    // The routine first checks whether iron leggings are already worn, and if not it verifies the inventory contains the item; if missing, it gathers enough iron ingots by smelting raw iron with coal, places a crafting table if none is nearby, crafts the leggings, and finally equips them on the legs slot, reporting any failures along the way.\n}"}, "equipIronBoots": {"code": "// Helper: find a free air block directly above a solid block within a radius\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n      }\n    }\n  }\n  return null;\n}\n\n// Main function: equip iron boots (crafting if necessary)\n\n// Main function: equip iron boots (crafting if necessary)\nasync function equipIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const bootsId = mcData.itemsByName[\"iron_boots\"].id;\n  const ironIngotId = mcData.itemsByName[\"iron_ingot\"].id;\n  const rawIronId = mcData.itemsByName[\"raw_iron\"].id;\n  const coalId = mcData.itemsByName[\"coal\"].id;\n  const tableItemId = mcData.itemsByName[\"crafting_table\"].id;\n  const tableBlockId = mcData.blocksByName[\"crafting_table\"].id;\n\n  // 1\ufe0f\u20e3 Check if boots are already equipped\n  const equippedBoots = bot.inventory.slots.find(s => s && s.type === \"armor\" && s.slot === 3 // slot 3 = boots in Mineflayer\n  );\n  if (equippedBoots && equippedBoots.type === \"armor\" && equippedBoots.name === \"iron_boots\") {\n    await bot.chat(\"\u2705 Iron boots are already equipped.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Find iron boots in inventory\n  let bootsItem = bot.inventory.findInventoryItem(bootsId);\n  if (!bootsItem) {\n    await bot.chat(\"\ud83d\udd28 I don't have iron boots yet, preparing to craft them.\");\n\n    // 2a\ufe0f\u20e3 Ensure we have at least 4 iron ingots\n    const neededIngot = 4;\n    let ingotCount = bot.inventory.count(ironIngotId);\n    if (ingotCount < neededIngot) {\n      const missing = neededIngot - ingotCount;\n      await bot.chat(`\ud83e\udea8 Need ${missing} more iron ingot(s). Smelting raw iron...`);\n      while (bot.inventory.count(ironIngotId) < neededIngot) {\n        if (!bot.inventory.findInventoryItem(rawIronId) || !bot.inventory.findInventoryItem(coalId)) {\n          await bot.chat(\"\u274c Not enough raw iron or coal to smelt more ingots.\");\n          return;\n        }\n        await smeltItem(bot, \"raw_iron\", \"coal\", 1);\n        await bot.chat(`\u2705 Smelted 1 iron ingot (total ${bot.inventory.count(ironIngotId)}).`);\n      }\n    } else {\n      await bot.chat(`\u2705 Iron ingots OK (${ingotCount}/${neededIngot}).`);\n    }\n\n    // 2b\ufe0f\u20e3 Ensure a placed crafting table exists\n    let placedTable = bot.findBlock({\n      matching: tableBlockId,\n      maxDistance: 32\n    });\n    if (!placedTable) {\n      await bot.chat(\"\ud83e\udeb5 No placed crafting table nearby \u2013 will place one.\");\n\n      // Ensure we have a crafting table item\n      const tableItem = bot.inventory.findInventoryItem(tableItemId);\n      if (!tableItem) {\n        await bot.chat(\"\u274c I don't have a crafting table item to place.\");\n        return;\n      }\n\n      // Find a free spot\n      let placePos = await findFreePlacementSpot(bot, 3);\n      if (!placePos) {\n        await bot.chat(\"Exploring for a suitable spot to place the crafting table...\");\n        const found = await exploreUntil(bot, new Vec3(1, 0, 1), 60, () => {\n          const p = findFreePlacementSpot(bot, 3);\n          return p ? true : null;\n        });\n        if (!found) {\n          await bot.chat(\"\u274c Could not locate a free spot for the crafting table.\");\n          return;\n        }\n        placePos = await findFreePlacementSpot(bot, 3);\n      }\n      await bot.chat(`Placing crafting table at ${placePos}`);\n      await placeItem(bot, \"crafting_table\", placePos);\n      placedTable = bot.blockAt(placePos);\n    } else {\n      await bot.chat(`\u2705 Found placed crafting table at ${placedTable.position}`);\n    }\n\n    // Move next to the table so we can craft\n    await bot.pathfinder.goto(new GoalNear(placedTable.position.x, placedTable.position.y, placedTable.position.z, 1));\n\n    // 2c\ufe0f\u20e3 Craft the iron boots\n    await bot.chat(\"\ud83d\udee0\ufe0f Crafting iron boots...\");\n    try {\n      await craftItem(bot, \"iron_boots\", 1);\n      await bot.chat(\"\u2705 Iron boots crafted.\");\n    } catch (err) {\n      await bot.chat(`\u274c Failed to craft iron boots: ${err.message}`);\n      return;\n    }\n\n    // Refresh reference to the newly crafted boots\n    bootsItem = bot.inventory.findInventoryItem(bootsId);\n    if (!bootsItem) {\n      await bot.chat(\"\u274c Something went wrong \u2013 boots not found after crafting.\");\n      return;\n    }\n  } else {\n    await bot.chat(\"\u2705 Iron boots already in inventory.\");\n  }\n\n  // 3\ufe0f\u20e3 Equip the boots\n  try {\n    await bot.equip(bootsItem, \"feet\");\n    await bot.chat(\"\ud83d\udee1\ufe0f Iron boots equipped successfully!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip iron boots: ${err.message}`);\n  }\n}", "description": "async function equipIronBoots(bot) {\n    // The function ensures the bot wears iron boots by checking if they are already equipped, locating them in the inventory or gathering enough iron ingots (smelting raw iron with coal if necessary), placing a crafting table at a nearby free spot, moving next to the table, crafting the boots, and finally equipping them on the feet.\n}"}, "mineFiveCopperOre": {"code": "// main function to mine at least 5 raw copper ore items\nasync function mineFiveCopperOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let v;\n    do {\n      v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (v.x === 0 && v.y === 0 && v.z === 0);\n    return v;\n  }\n\n  // 1\ufe0f\u20e3 Check current raw copper amount\n  const rawCopperId = mcData.itemsByName[\"raw_copper\"].id;\n  let rawCopper = bot.inventory.count(rawCopperId);\n  if (rawCopper >= 5) {\n    await bot.chat(`\u2705 I already have ${rawCopper} raw copper. Task completed.`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd0e Need ${5 - rawCopper} more raw copper.`);\n\n  // 2\ufe0f\u20e3 Ensure we have a stone\u2011tier pickaxe (stone, iron, gold, diamond, netherite)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  // fallback: craft a wooden pickaxe if none found\n  if (!pickaxeItem) {\n    await bot.chat(\"\u2692\ufe0f No suitable pickaxe found, crafting a wooden pickaxe...\");\n    // ensure we have 3 planks and 2 sticks (craftItem will handle missing items)\n    await craftItem(bot, \"wooden_pickaxe\", 1);\n    pickaxeItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"wooden_pickaxe\"].id);\n    if (!pickaxeItem) {\n      await bot.chat(\"\u274c Failed to obtain a pickaxe.\");\n      return;\n    }\n  }\n\n  // 3\ufe0f\u20e3 Equip the pickaxe\n  try {\n    await bot.equip(pickaxeItem, \"hand\");\n    await bot.chat(`\ud83e\ude93 Equipped ${pickaxeItem.name}.`);\n  } catch (e) {\n    await bot.chat(`\u274c Could not equip pickaxe: ${e.message}`);\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Mine copper ore until we have 5 raw copper\n  const copperOreName = \"copper_ore\";\n  while (rawCopper < 5) {\n    // a. Find copper ore blocks nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName[copperOreName].id,\n      maxDistance: 32\n    });\n\n    // b. If none, explore\n    if (!oreBlock) {\n      await bot.chat(\"\ud83d\udeb6\u200d\u2642\ufe0f No copper ore nearby, exploring...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName[copperOreName].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not locate copper ore after exploring.\");\n        return;\n      }\n      oreBlock = bot.findBlock({\n        matching: mcData.blocksByName[copperOreName].id,\n        maxDistance: 32\n      });\n    }\n\n    // c. Determine how many more we need\n    const need = 5 - rawCopper;\n    await bot.chat(`\u26cf\ufe0f Mining ${need} copper ore block(s)...`);\n    // mineBlock will collect up to `need` blocks; it safely stops if fewer are found\n    await mineBlock(bot, copperOreName, need);\n\n    // d. Re\u2011count raw copper\n    rawCopper = bot.inventory.count(rawCopperId);\n    await bot.chat(`\ud83d\udce6 Raw copper now: ${rawCopper}/5`);\n  }\n\n  // 5\ufe0f\u20e3 Completion message\n  await bot.chat(`\u2705 Task finished \u2013 I have ${rawCopper} raw copper!`);\n}", "description": "async function mineFiveCopperOre(bot) {\n    // The function ensures the bot has at least five raw copper items by first checking the current inventory count; if insufficient, it searches for a stone\u2011tier or better pickaxe, crafting a wooden one as a fallback and then equips it; it repeatedly looks for copper ore blocks within a short range and, if none are found, explores in random directions until ore is located; once ore is found it mines the needed number of blocks, updating the raw copper count after each attempt; this loop continues until the inventory contains five or more raw copper items.\n}"}, "craftOneBucket": {"code": "// Main function to craft 1 bucket\nasync function craftOneBucket(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const {\n    Vec3\n  } = require('vec3');\n\n  // Helper: find a free air block directly above a solid block within a radius\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -1; dy <= 2; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === 'air') continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n\n  // 1\ufe0f\u20e3 Check if we already have a bucket\n  const bucketId = mcData.itemsByName['bucket'].id;\n  if (bot.inventory.findInventoryItem(bucketId)) {\n    await bot.chat('\u2705 I already have a bucket.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have at least 3 iron ingots\n  const ironIngotId = mcData.itemsByName['iron_ingot'].id;\n  const ironCount = bot.inventory.count(ironIngotId);\n  if (ironCount < 3) {\n    await bot.chat(`\u274c Not enough iron ingots (have ${ironCount}, need 3).`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Locate a placed crafting table\n  const tableBlockId = mcData.blocksByName['crafting_table'].id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n\n  // 4\ufe0f\u20e3 If none, place one\n  if (!tableBlock) {\n    await bot.chat('\ud83e\udeb5 No placed crafting table nearby \u2013 placing one.');\n\n    // 4a) Ensure we have a crafting table item\n    const tableItemId = mcData.itemsByName['crafting_table'].id;\n    const tableItem = bot.inventory.findInventoryItem(tableItemId);\n    if (!tableItem) {\n      await bot.chat('\u274c I do not have a crafting table item to place.');\n      return;\n    }\n\n    // 4b) Find a free spot\n    let placePos = await findFreePlacementSpot(3);\n    if (!placePos) {\n      // Explore until a spot appears\n      await bot.chat('\ud83d\udd0e Exploring for a suitable spot to place the crafting table...');\n      const found = await exploreUntil(bot,\n      // random direction vector\n      new Vec3([-1, 0, 1][Math.floor(Math.random() * 3)], [-1, 0, 1][Math.floor(Math.random() * 3)], [-1, 0, 1][Math.floor(Math.random() * 3)]), 60, async () => {\n        const pos = await findFreePlacementSpot(3);\n        return pos ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not find a free spot for the crafting table.');\n        return;\n      }\n      placePos = await findFreePlacementSpot(3);\n    }\n\n    // 4c) Place the table\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Placed crafting table at ${placePos}`);\n  } else {\n    await bot.chat(`\u2705 Found placed crafting table at ${tableBlock.position}`);\n  }\n\n  // 5\ufe0f\u20e3 Move next to the crafting table\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // 6\ufe0f\u20e3 Craft the bucket\n  await bot.chat('\ud83d\udee0\ufe0f Crafting a bucket...');\n  try {\n    await craftItem(bot, 'bucket', 1);\n    await bot.chat('\u2705 Bucket crafted!');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft bucket: ${err.message}`);\n    return;\n  }\n\n  // 7\ufe0f\u20e3 Verify\n  if (bot.inventory.findInventoryItem(bucketId)) {\n    await bot.chat('\ud83e\udea3 Bucket is now in my inventory.');\n  } else {\n    await bot.chat('\u26a0\ufe0f Bucket not found after crafting.');\n  }\n}", "description": "async function craftOneBucket(bot) {\n    // The function ensures the bot has a bucket by first checking the inventory, then confirming it possesses at least three iron ingots; it searches for a nearby crafting table and, if none is found, places one on a suitable air block above solid ground; after positioning the bot adjacent to the crafting table, it attempts to craft a bucket using the available resources; finally, it verifies that the bucket now exists in the inventory.\n}"}, "mineFiveRedstoneDust": {"code": "// main function: mine at least 5 redstone dust\nasync function mineFiveRedstoneDust(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: pick a random non\u2011zero direction vector (components -1,0,1)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // 1\ufe0f\u20e3 Ensure we have an iron\u2011tier pickaxe\n  const pickaxeIds = [mcData.itemsByName.iron_pickaxe.id, mcData.itemsByName.diamond_pickaxe.id, mcData.itemsByName.netherite_pickaxe.id, mcData.itemsByName.stone_pickaxe.id // stone works but slower; keep as fallback\n  ];\n  let pickaxeItem = null;\n  for (const id of pickaxeIds) {\n    const it = bot.inventory.findInventoryItem(id);\n    if (it) {\n      pickaxeItem = it;\n      break;\n    }\n  }\n  if (!pickaxeItem) {\n    await bot.chat('\u274c No suitable pickaxe found. Cannot mine redstone.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Equip the pickaxe\n  try {\n    await bot.equip(pickaxeItem, 'hand');\n    await bot.chat(`\ud83e\ude93 Equipped ${pickaxeItem.name}.`);\n  } catch (e) {\n    await bot.chat(`\u274c Failed to equip pickaxe: ${e.message}`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Mine until we have 5 redstone dust\n  const redstoneDustId = mcData.itemsByName.redstone.id; // dust item\n  let redstoneCount = bot.inventory.count(redstoneDustId);\n  while (redstoneCount < 5) {\n    // a. Look for redstone ore (stone or deepslate version)\n    let oreBlock = bot.findBlock({\n      matching: [mcData.blocksByName.redstone_ore.id, mcData.blocksByName.deepslate_redstone_ore?.id].filter(Boolean),\n      // filter out undefined on older versions\n      maxDistance: 32\n    });\n\n    // b. If not found, explore\n    if (!oreBlock) {\n      await bot.chat('\ud83d\udd0e No redstone ore nearby, exploring...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: [mcData.blocksByName.redstone_ore.id, mcData.blocksByName.deepslate_redstone_ore?.id].filter(Boolean),\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not locate redstone ore after exploring.');\n        return;\n      }\n      // re\u2011search after exploration\n      oreBlock = bot.findBlock({\n        matching: [mcData.blocksByName.redstone_ore.id, mcData.blocksByName.deepslate_redstone_ore?.id].filter(Boolean),\n        maxDistance: 32\n      });\n    }\n\n    // c. Mine a single ore block\n    await bot.chat('\u26cf\ufe0f Mining a redstone ore block...');\n    await mineBlock(bot, oreBlock.name, 1); // mineBlock will collect the block(s)\n\n    // d. Update count and report\n    redstoneCount = bot.inventory.count(redstoneDustId);\n    await bot.chat(`\ud83d\udce6 Redstone dust collected: ${redstoneCount}/5`);\n  }\n\n  // 4\ufe0f\u20e3 Completion\n  await bot.chat('\u2705 Task complete \u2013 I have at least 5 redstone dust!');\n}", "description": "async function mineFiveRedstoneDust(bot) {\n    // The routine first looks for an iron\u2011tier or better pickaxe in the inventory and equips it. It then repeatedly searches nearby blocks for redstone ore (including deepslate variants) within a 32\u2011block radius. If no ore is found, it moves in random directions to explore until ore is located. Each discovered ore block is mined and the inventory count of redstone dust is updated. The loop continues until the bot has collected at least five redstone dust, after which the task is considered complete.\n}"}, "craftCompass": {"code": "// Helper: find a free air block directly above a solid block within a given radius\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const {\n    Vec3\n  } = require('vec3');\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === 'air') continue; // need solid ground\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n      }\n    }\n  }\n  return null;\n}\n\n// Main function: craft one compass\n\n// Main function: craft one compass\nasync function craftCompass(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3 Check if compass already in inventory\n  const compassId = mcData.itemsByName.compass.id;\n  if (bot.inventory.findInventoryItem(compassId)) {\n    await bot.chat('\u2705 I already have a compass.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Verify required materials\n  const ironIngotId = mcData.itemsByName.iron_ingot.id;\n  const redstoneId = mcData.itemsByName.redstone.id;\n  const ironCount = bot.inventory.count(ironIngotId);\n  const redstoneCount = bot.inventory.count(redstoneId);\n  if (ironCount < 4 || redstoneCount < 1) {\n    await bot.chat(`\u274c Missing materials: need 4 iron ingots (${ironCount}) and 1 redstone (${redstoneCount}).`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd27 Materials OK \u2013 ${ironCount} iron ingots, ${redstoneCount} redstone.`);\n\n  // 3\ufe0f\u20e3 Ensure a placed crafting table exists\n  const tableBlockId = mcData.blocksByName.crafting_table.id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83e\udeb5 No placed crafting table nearby \u2013 placing one.');\n\n    // Ensure we have a crafting table item\n    const tableItemId = mcData.itemsByName.crafting_table.id;\n    const tableItem = bot.inventory.findInventoryItem(tableItemId);\n    if (!tableItem) {\n      await bot.chat('\u274c I do not have a crafting table item to place.');\n      return;\n    }\n\n    // Find a free spot\n    let placePos = await findFreePlacementSpot(bot, 3);\n    if (!placePos) {\n      // Explore until we find a suitable spot\n      await bot.chat('Exploring for a suitable spot to place the crafting table...');\n      const found = await exploreUntil(bot, new Vec3([-1, 0, 1][Math.floor(Math.random() * 3)], [-1, 0, 1][Math.floor(Math.random() * 3)], [-1, 0, 1][Math.floor(Math.random() * 3)]), 60, () => {\n        const p = findFreePlacementSpot(bot, 3);\n        return p ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not locate a free spot for the crafting table.');\n        return;\n      }\n      placePos = await findFreePlacementSpot(bot, 3);\n    }\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.chat(`\u2705 Placed crafting table at ${placePos}`);\n    tableBlock = bot.blockAt(placePos);\n  } else {\n    await bot.chat(`\u2705 Found placed crafting table at ${tableBlock.position}`);\n  }\n\n  // 4\ufe0f\u20e3 Move next to the crafting table\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // 5\ufe0f\u20e3 Craft the compass\n  await bot.chat('\ud83d\udee0\ufe0f Crafting a compass...');\n  try {\n    await craftItem(bot, 'compass', 1);\n    await bot.chat('\u2705 Compass crafted successfully!');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft compass: ${err.message}`);\n    return;\n  }\n\n  // 6\ufe0f\u20e3 Verify result\n  if (bot.inventory.findInventoryItem(compassId)) {\n    await bot.chat('\ud83e\udded I now have a compass in my inventory.');\n  } else {\n    await bot.chat('\u26a0\ufe0f Compass not found after crafting.');\n  }\n}", "description": "async function craftCompass(bot) {\n    // The routine first checks whether a compass is already in the inventory and aborts if found. It then confirms the presence of at least four iron ingots and one redstone, stopping if the required materials are missing. If no crafting table is nearby, it locates a suitable free spot, places a crafting table there, and records its position. The bot navigates to a position adjacent to the crafting table. Using the table it crafts one compass. Finally it verifies that the newly crafted compass appears in the inventory.\n}"}, "smeltThreeRawCopper": {"code": "/**\n * Returns a random direction vector whose components are -1, 0 or 1\n * (but not the zero vector).\n */\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let v;\n  do {\n    v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (v.x === 0 && v.y === 0 && v.z === 0);\n  return v;\n}\n\n/**\n * Finds a free air block directly above a solid block within the given radius.\n * Returns a Vec3 or null.\n */\n\n/**\n * Finds a free air block directly above a solid block within the given radius.\n * Returns a Vec3 or null.\n */\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const botPos = bot.entity.position.floored();\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const solidPos = botPos.offset(dx, dy, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === 'air') continue; // need solid ground\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n      }\n    }\n  }\n  return null;\n}\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\n/**\n * Smelts exactly three raw copper using a furnace and lava bucket as fuel.\n * The function is fully self\u2011contained and checks/collects everything it needs.\n */\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\n/**\n * Smelts exactly three raw copper using a furnace and lava bucket as fuel.\n * The function is fully self\u2011contained and checks/collects everything it needs.\n */\nasync function smeltThreeRawCopper(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // ---------- 1. Check we have enough raw copper ----------\n  const rawCopperId = mcData.itemsByName['raw_copper'].id;\n  let rawCopperCount = bot.inventory.count(rawCopperId);\n  if (rawCopperCount < 3) {\n    await bot.chat(`\u274c I only have ${rawCopperCount} raw copper \u2013 need at least 3.`);\n    return;\n  }\n  await bot.chat(`\u2705 I have ${rawCopperCount} raw copper, ready to smelt 3.`);\n\n  // ---------- 2. Ensure a furnace is placed ----------\n  const furnaceBlockId = mcData.blocksByName['furnace'].id;\n  let furnaceBlock = bot.findBlock({\n    matching: furnaceBlockId,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    await bot.chat('\ud83d\udd28 No furnace nearby \u2013 placing one.');\n    // we need a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName['furnace'].id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c I have no furnace item to place.');\n      return;\n    }\n    // find a free spot\n    let placePos = await findFreePlacementSpot(bot, 3);\n    if (!placePos) {\n      await bot.chat('Exploring for a suitable spot to place the furnace...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(bot, 3);\n        return p ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not locate a free spot for the furnace.');\n        return;\n      }\n      placePos = await findFreePlacementSpot(bot, 3);\n    }\n    await placeItem(bot, 'furnace', placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Furnace placed at ${placePos}`);\n  } else {\n    await bot.chat(`\u2705 Found a furnace at ${furnaceBlock.position}`);\n  }\n\n  // ---------- 3. Ensure we have a lava bucket ----------\n  const lavaBucketId = mcData.itemsByName['lava_bucket'].id;\n  async function haveLavaBucket() {\n    return !!bot.inventory.findInventoryItem(lavaBucketId);\n  }\n  async function fillLavaBucket() {\n    // locate nearest lava block\n    const lavaId = mcData.blocksByName['lava'].id;\n    const lavaBlock = bot.findBlock({\n      matching: lavaId,\n      maxDistance: 32\n    });\n    if (!lavaBlock) {\n      await bot.chat('\u274c No lava block found nearby to fill a bucket.');\n      return false;\n    }\n    // move next to the lava block\n    await bot.pathfinder.goto(new GoalNear(lavaBlock.position.x, lavaBlock.position.y, lavaBlock.position.z, 1));\n    // equip empty bucket\n    const emptyBucket = bot.inventory.findInventoryItem(mcData.itemsByName['bucket'].id);\n    if (!emptyBucket) {\n      await bot.chat('\u274c I have no empty bucket to fill.');\n      return false;\n    }\n    await bot.equip(emptyBucket, 'hand');\n    // look at the lava block and activate\n    await bot.lookAt(lavaBlock.position);\n    await bot.activateItem();\n    // wait a tick for the inventory to update\n    await bot.waitForTicks(1);\n    return true;\n  }\n\n  // ---------- 4. Smelt three raw copper ----------\n  for (let i = 0; i < 3; i++) {\n    // make sure we have a lava bucket for this iteration\n    if (!(await haveLavaBucket())) {\n      await bot.chat(`\ud83d\udd04 Filling lava bucket (${i + 1}/3)...`);\n      const filled = await fillLavaBucket();\n      if (!filled) {\n        await bot.chat('\u274c Failed to obtain lava bucket \u2013 aborting smelting.');\n        return;\n      }\n    }\n    await bot.chat(`\ud83d\udd25 Smelting raw copper #${i + 1}...`);\n    try {\n      await smeltItem(bot, 'raw_copper', 'lava_bucket', 1);\n    } catch (err) {\n      await bot.chat(`\u274c Smelting failed: ${err.message}`);\n      return;\n    }\n    // after smelting the lava bucket becomes an empty bucket again,\n    // which is fine \u2013 the next loop will refill it if needed.\n  }\n\n  // ---------- 5. Report result ----------\n  const copperIngotId = mcData.itemsByName['copper_ingot'].id;\n  const ingotCount = bot.inventory.count(copperIngotId);\n  await bot.chat(`\u2705 Finished! I now have ${ingotCount} copper ingot(s).`);\n}", "description": "async function smeltThreeRawCopper(bot) {\n    // The routine verifies that at least three raw copper items are in the inventory, locates or places a furnace nearby, ensures a lava bucket is available (filling an empty bucket from a lava source when needed), then smelts three raw copper pieces one by one using the furnace with lava as fuel, refilling the bucket between cycles if necessary, and finally reports the total copper ingots obtained.\n}"}, "equipIronChestplate": {"code": "// main function to equip an iron chestplate (crafting if necessary)\nasync function equipIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helpers -------------------------------------------------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let v;\n    do {\n      v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (v.x === 0 && v.y === 0 && v.z === 0);\n    return v;\n  }\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === 'air') continue;\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n  // --------------------------------------------------------------\n\n  // 1\ufe0f\u20e3 Already equipped?\n  const equipped = bot.inventory.slots.find(s => s && s.type === 'armor' && s.slot === 2 // slot 2 = chest armor\n  );\n  if (equipped && equipped.name === 'iron_chestplate') {\n    await bot.chat('\u2705 Iron chestplate is already equipped.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Chestplate in inventory?\n  const chestplateId = mcData.itemsByName['iron_chestplate'].id;\n  let chestplateItem = bot.inventory.findInventoryItem(chestplateId);\n  if (chestplateItem) {\n    await bot.equip(chestplateItem, 'torso');\n    await bot.chat('\u2705 Iron chestplate equipped from inventory.');\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Need to craft \u2013 ensure 8 iron ingots\n  const ironIngotId = mcData.itemsByName['iron_ingot'].id;\n  const rawIronId = mcData.itemsByName['raw_iron'].id;\n  const oakPlankId = mcData.itemsByName['oak_planks'].id;\n  const oakLogId = mcData.itemsByName['oak_log'].id;\n  const neededIngot = 8;\n  let ironCount = bot.inventory.count(ironIngotId);\n  if (ironCount < neededIngot) {\n    const needIngots = neededIngot - ironCount;\n    await bot.chat(`\ud83d\udd28 Need ${needIngots} more iron ingot(s).`);\n\n    // 3a) Ensure enough raw iron\n    let rawIronCount = bot.inventory.count(rawIronId);\n    const needRaw = needIngots - rawIronCount;\n    if (needRaw > 0) {\n      await bot.chat(`\u26cf\ufe0f Mining ${needRaw} iron ore block(s) for raw iron...`);\n      let mined = 0;\n      while (mined < needRaw) {\n        let ore = bot.findBlock({\n          matching: mcData.blocksByName['iron_ore'].id,\n          maxDistance: 32\n        });\n        if (!ore) {\n          await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f Exploring for iron ore...');\n          const found = await exploreUntil(bot, randomDirection(), 60, () => {\n            const blk = bot.findBlock({\n              matching: mcData.blocksByName['iron_ore'].id,\n              maxDistance: 32\n            });\n            return blk ? true : null;\n          });\n          if (!found) {\n            await bot.chat('\u274c Could not locate iron ore after exploring.');\n            return;\n          }\n          continue; // try again after exploration\n        }\n        await mineBlock(bot, 'iron_ore', 1);\n        mined++;\n      }\n    }\n\n    // 3b) Ensure a furnace is placed\n    const furnaceBlockId = mcData.blocksByName['furnace'].id;\n    let furnaceBlock = bot.findBlock({\n      matching: furnaceBlockId,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      await bot.chat('\ud83e\udeb5 No furnace placed \u2013 placing one.');\n      const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName['furnace'].id);\n      if (!furnaceItem) {\n        await bot.chat('\u274c No furnace item in inventory.');\n        return;\n      }\n      const placePos = await findFreePlacementSpot(3);\n      if (!placePos) {\n        await bot.chat('\u274c Could not find a free spot for the furnace.');\n        return;\n      }\n      await placeItem(bot, 'furnace', placePos);\n      furnaceBlock = bot.blockAt(placePos);\n      await bot.chat(`\u2705 Furnace placed at ${placePos}`);\n    }\n\n    // 3c) Ensure enough fuel (oak planks)\n    let plankCount = bot.inventory.count(oakPlankId);\n    if (plankCount < needIngots) {\n      const missingPlanks = needIngots - plankCount;\n      const logCount = bot.inventory.count(oakLogId);\n      if (logCount > 0) {\n        const logsNeeded = Math.ceil(missingPlanks / 4);\n        await bot.chat(`\ud83e\udeb5 Crafting ${logsNeeded} oak log(s) into planks...`);\n        await craftItem(bot, 'oak_planks', logsNeeded);\n        plankCount = bot.inventory.count(oakPlankId);\n      }\n    }\n\n    // 3d) Smelt raw iron into ingots\n    const toSmelt = neededIngot - ironCount;\n    await bot.chat(`\ud83d\udd25 Smelting ${toSmelt} raw iron into ingots...`);\n    for (let i = 0; i < toSmelt; i++) {\n      await smeltItem(bot, 'raw_iron', 'oak_planks', 1);\n    }\n    ironCount = bot.inventory.count(ironIngotId);\n    await bot.chat(`\u2705 Iron ingots now: ${ironCount}`);\n  }\n\n  // 4\ufe0f\u20e3 Ensure a crafting table is placed\n  const tableBlockId = mcData.blocksByName['crafting_table'].id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83e\udeb5 No crafting table nearby \u2013 placing one.');\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName['crafting_table'].id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n    const placePos = await findFreePlacementSpot(3);\n    if (!placePos) {\n      await bot.chat('\u274c Could not find a free spot for the crafting table.');\n      return;\n    }\n    await placeItem(bot, 'crafting_table', placePos);\n    tableBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Crafting table placed at ${placePos}`);\n  }\n\n  // 5\ufe0f\u20e3 Craft the iron chestplate\n  await bot.chat('\ud83d\udee0\ufe0f Crafting iron chestplate...');\n  try {\n    await craftItem(bot, 'iron_chestplate', 1);\n    await bot.chat('\u2705 Iron chestplate crafted.');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft iron chestplate: ${err.message}`);\n    return;\n  }\n\n  // 6\ufe0f\u20e3 Equip the chestplate\n  chestplateItem = bot.inventory.findInventoryItem(chestplateId);\n  if (!chestplateItem) {\n    await bot.chat('\u274c Chestplate not found after crafting.');\n    return;\n  }\n  try {\n    await bot.equip(chestplateItem, 'torso');\n    await bot.chat('\ud83d\udee1\ufe0f Iron chestplate equipped successfully!');\n  } catch (err) {\n    await bot.chat(`\u274c Could not equip chestplate: ${err.message}`);\n  }\n}", "description": "async function equipIronChestplate(bot) {\n    // The routine first verifies whether an iron chestplate is already worn, then looks for one in the inventory to equip it; if missing, it gathers enough iron ingots by mining iron ore, smelting raw iron using a furnace and oak\u2011plank fuel, and crafting any needed planks; it also ensures a furnace and a crafting table are placed nearby, finding free placement spots when necessary; after securing eight iron ingots, it crafts an iron chestplate at the crafting table; finally, it equips the newly crafted chestplate on the torso slot.\n}"}, "killOneSpider": {"code": "// helper: pick a random direction vector (components -1, 0, or 1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// main function: kill exactly one spider\n\n// main function: kill exactly one spider\nasync function killOneSpider(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  await bot.chat('\ud83d\udd0e Looking for a sword to fight the spider...');\n  // 1\ufe0f\u20e3 Ensure we have a melee weapon (prefer iron sword)\n  let weaponItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_sword.id);\n  if (!weaponItem) {\n    await bot.chat('\u2694\ufe0f No iron sword found, trying to use a bow...');\n    weaponItem = bot.inventory.findInventoryItem(mcData.itemsByName.bow.id);\n    if (!weaponItem) {\n      await bot.chat('\u274c No suitable weapon (sword or bow) in inventory. Cannot kill spider.');\n      return;\n    }\n  }\n\n  // 2\ufe0f\u20e3 Equip the weapon in the hand\n  try {\n    await bot.equip(weaponItem, 'hand');\n    await bot.chat(`\u2705 Equipped ${weaponItem.name} in hand.`);\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip weapon: ${err.message}`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Search for a spider\n  await bot.chat('\ud83d\udd0e Searching for a spider...');\n  const spiderFound = await exploreUntil(bot, randomDirection(), 60, () => {\n    const spider = bot.nearestEntity(e => e.name === 'spider' && e.position.distanceTo(bot.entity.position) < 32);\n    return spider ? true : null;\n  });\n  if (!spiderFound) {\n    await bot.chat('\u274c Could not locate a spider within the search time.');\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Kill the spider using the helper\n  await bot.chat('\u2694\ufe0f Spider located! Engaging...');\n  try {\n    await killMob(bot, 'spider', 300);\n    await bot.chat('\u2705 Spider has been killed.');\n  } catch (err) {\n    await bot.chat(`\u274c Error while killing spider: ${err.message}`);\n  }\n}", "description": "async function killOneSpider(bot) {\n    // The function ensures the bot has a suitable weapon (preferring an iron sword, otherwise a bow), equips it, scans the nearby area for a spider within a limited time, and if a spider is found, engages and kills it while handling cases where no weapon is available, the spider cannot be located, or an error occurs during combat.\n}"}, "smeltFiveRawCopper": {"code": "// main function to smelt exactly 5 raw copper\nasync function smeltFiveRawCopper(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // Helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // 1\ufe0f\u20e3 Check current raw copper amount\n  const rawCopperId = mcData.itemsByName[\"raw_copper\"].id;\n  let rawCopperCount = bot.inventory.count(rawCopperId);\n  if (rawCopperCount >= 5) {\n    await bot.chat(`\u2705 I already have ${rawCopperCount} raw copper. Ready to smelt 5 of them.`);\n  } else {\n    await bot.chat(`\u274c I only have ${rawCopperCount} raw copper, cannot fulfill the task.`);\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Find a placed furnace block\n  const furnaceBlockId = mcData.blocksByName[\"furnace\"].id;\n  let furnaceBlock = bot.findBlock({\n    matching: furnaceBlockId,\n    maxDistance: 32\n  });\n\n  // 3\ufe0f\u20e3 If no furnace, place one\n  if (!furnaceBlock) {\n    await bot.chat(\"\ud83d\udd28 No furnace nearby, placing one.\");\n\n    // Ensure we have a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"furnace\"].id);\n    if (!furnaceItem) {\n      await bot.chat(\"\u274c I don't have a furnace item to place.\");\n      return;\n    }\n\n    // Find a free spot (air block above solid ground) within radius 3\n    const botPos = bot.entity.position.floored();\n    let placePos = null;\n    for (let dx = -3; dx <= 3; dx++) {\n      for (let dz = -3; dz <= 3; dz++) {\n        const groundPos = botPos.offset(dx, -1, dz);\n        const groundBlock = bot.blockAt(groundPos);\n        const abovePos = groundPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (groundBlock && groundBlock.name !== \"air\" && aboveBlock && aboveBlock.name === \"air\") {\n          placePos = abovePos;\n          break;\n        }\n      }\n      if (placePos) break;\n    }\n\n    // If still not found, explore a bit to locate a suitable spot\n    if (!placePos) {\n      await bot.chat(\"Exploring for a suitable spot to place the furnace...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const botPos2 = bot.entity.position.floored();\n        for (let dx = -3; dx <= 3; dx++) {\n          for (let dz = -3; dz <= 3; dz++) {\n            const groundPos = botPos2.offset(dx, -1, dz);\n            const groundBlock = bot.blockAt(groundPos);\n            const abovePos = groundPos.offset(0, 1, 0);\n            const aboveBlock = bot.blockAt(abovePos);\n            if (groundBlock && groundBlock.name !== \"air\" && aboveBlock && aboveBlock.name === \"air\") {\n              return abovePos; // stop exploration\n            }\n          }\n        }\n        return null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not find a place to put the furnace.\");\n        return;\n      }\n      placePos = found;\n    }\n\n    // Place the furnace\n    await placeItem(bot, \"furnace\", placePos);\n    furnaceBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Furnace placed at ${placePos}`);\n  } else {\n    await bot.chat(`\u2705 Found an existing furnace at ${furnaceBlock.position}`);\n  }\n\n  // 4\ufe0f\u20e3 Ensure we have enough fuel (coal) for 5 smelts\n  const coalId = mcData.itemsByName[\"coal\"].id;\n  const neededFuel = 5;\n  const coalCount = bot.inventory.count(coalId);\n  if (coalCount < neededFuel) {\n    await bot.chat(`\u274c Not enough coal for smelting (need ${neededFuel}, have ${coalCount}).`);\n    return;\n  }\n\n  // 5\ufe0f\u20e3 Smelt the required amount\n  const needed = 5;\n  await bot.chat(`\u26cf\ufe0f Starting smelting of ${needed} raw copper...`);\n  for (let i = 0; i < needed; i++) {\n    await smeltItem(bot, \"raw_copper\", \"coal\", 1);\n    await bot.chat(`\u2705 Smelted ${i + 1}/${needed}`);\n  }\n\n  // 6\ufe0f\u20e3 Final check and report\n  const copperIngotId = mcData.itemsByName[\"copper_ingot\"].id;\n  const ingotCount = bot.inventory.count(copperIngotId);\n  await bot.chat(`\u2705 Finished! I now have ${ingotCount} copper ingot(s).`);\n}", "description": "async function smeltFiveRawCopper(bot) {\n    // The routine verifies that the bot has at least five raw copper, locates or places a furnace nearby, confirms sufficient coal for five smelts, then sequentially smelts five raw copper items using the furnace, and finally checks the inventory to confirm the resulting copper ingots.\n}"}, "mineEightCoal": {"code": "// Main function to mine at least 8 coal ore blocks\nasync function mineEightCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // Helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let v;\n    do {\n      v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (v.x === 0 && v.y === 0 && v.z === 0);\n    return v;\n  }\n\n  // 1\ufe0f\u20e3 Check current coal amount\n  const coalId = mcData.itemsByName[\"coal\"].id;\n  let coalCount = bot.inventory.count(coalId);\n  if (coalCount >= 8) {\n    await bot.chat(`\u2705 I already have ${coalCount} coal. Task completed.`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd0e Need ${8 - coalCount} more coal.`);\n\n  // 2\ufe0f\u20e3 Ensure we have a suitable pickaxe (stone tier or better)\n  const pickaxeNames = [\"stone_pickaxe\", \"iron_pickaxe\", \"golden_pickaxe\", \"diamond_pickaxe\", \"netherite_pickaxe\"];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n\n  // Fallback: craft a wooden pickaxe if nothing found (unlikely)\n  if (!pickaxeItem) {\n    await bot.chat(\"\u2692\ufe0f No pickaxe found, crafting a wooden pickaxe...\");\n    await craftItem(bot, \"wooden_pickaxe\", 1);\n    pickaxeItem = bot.inventory.findInventoryItem(mcData.itemsByName[\"wooden_pickaxe\"].id);\n    if (!pickaxeItem) {\n      await bot.chat(\"\u274c Failed to obtain any pickaxe.\");\n      return;\n    }\n  }\n\n  // Equip the pickaxe\n  try {\n    await bot.equip(pickaxeItem, \"hand\");\n    await bot.chat(`\ud83e\ude93 Equipped ${pickaxeItem.name}.`);\n  } catch (e) {\n    await bot.chat(`\u274c Could not equip pickaxe: ${e.message}`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Mine coal until we have 8\n  const coalOreName = \"coal_ore\";\n  while (coalCount < 8) {\n    // a. Look for coal ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName[coalOreName].id,\n      maxDistance: 32\n    });\n\n    // b. If none, explore\n    if (!oreBlock) {\n      await bot.chat(\"\ud83d\udeb6\u200d\u2642\ufe0f No coal ore nearby, exploring...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName[coalOreName].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not locate coal ore after exploring.\");\n        return;\n      }\n      // re\u2011search after exploration\n      oreBlock = bot.findBlock({\n        matching: mcData.blocksByName[coalOreName].id,\n        maxDistance: 32\n      });\n    }\n\n    // c. Mine the needed amount\n    const need = 8 - coalCount;\n    await bot.chat(`\u26cf\ufe0f Mining ${need} coal ore block(s)...`);\n    await mineBlock(bot, coalOreName, need);\n\n    // d. Re\u2011count coal\n    coalCount = bot.inventory.count(coalId);\n    await bot.chat(`\ud83d\udce6 Coal now: ${coalCount}/8`);\n  }\n\n  // 4\ufe0f\u20e3 Completion\n  await bot.chat(`\u2705 Task finished \u2013 I now have ${coalCount} coal!`);\n}", "description": "async function mineEightCoal(bot) {\n    // The routine first checks how many coal items are already in the inventory and aborts if eight or more are present. It then looks for a stone\u2011tier or better pickaxe, crafting a wooden one only as a last resort, and equips the found tool. Afterwards it repeatedly searches for coal ore blocks within a short radius, and if none are found it explores in random directions until ore is located. Once ore is found it mines the necessary amount of blocks, updating the coal count after each batch. The loop continues until the inventory holds at least eight coal, at which point the task is considered complete.\n}"}, "ensureLightningRod": {"code": "// main function: ensure the bot has at least one lightning rod\nasync function ensureLightningRod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  // Random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let v;\n    do {\n      v = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (v.x === 0 && v.y === 0 && v.z === 0);\n    return v;\n  }\n\n  // Find an air block directly above a solid block within a radius\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -1; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === 'air') continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === 'air') return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n\n  // ---------- step 1: already have a lightning rod? ----------\n  const rodId = mcData.itemsByName['lightning_rod'].id;\n  if (bot.inventory.findInventoryItem(rodId)) {\n    await bot.chat('\u2705 I already have a lightning rod.');\n    return;\n  }\n\n  // ---------- step 2: obtain at least 3 copper ingots ----------\n  const copperIngotId = mcData.itemsByName['copper_ingot'].id;\n  const rawCopperId = mcData.itemsByName['raw_copper'].id;\n  const coalId = mcData.itemsByName['coal'].id;\n  const neededIngot = 3;\n  while (bot.inventory.count(copperIngotId) < neededIngot) {\n    // locate copper ore\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName['copper_ore'].id,\n      maxDistance: 32\n    });\n\n    // explore if none found\n    if (!oreBlock) {\n      await bot.chat('\ud83d\udd0e No copper ore nearby, exploring...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName['copper_ore'].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not locate copper ore after exploring.');\n        return;\n      }\n      oreBlock = bot.findBlock({\n        matching: mcData.blocksByName['copper_ore'].id,\n        maxDistance: 32\n      });\n    }\n\n    // mine the ore (one block per loop is enough)\n    await bot.chat('\u26cf\ufe0f Mining copper ore...');\n    await mineBlock(bot, 'copper_ore', 1);\n\n    // ensure we have coal for smelting\n    if (!bot.inventory.findInventoryItem(coalId)) {\n      await bot.chat('\u274c No coal left for smelting.');\n      return;\n    }\n\n    // smelt raw copper into an ingot\n    await bot.chat('\ud83d\udd25 Smelting raw copper...');\n    await smeltItem(bot, 'raw_copper', 'coal', 1);\n    await bot.chat(`\ud83d\udce6 Copper ingots: ${bot.inventory.count(copperIngotId)}/${neededIngot}`);\n  }\n\n  // ---------- step 3: ensure a placed crafting table ----------\n  const tableBlockId = mcData.blocksByName['crafting_table'].id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83e\udeb5 No crafting table nearby, placing one.');\n\n    // need a crafting table item\n    const tableItemId = mcData.itemsByName['crafting_table'].id;\n    const tableItem = bot.inventory.findInventoryItem(tableItemId);\n    if (!tableItem) {\n      await bot.chat('\u274c I do not have a crafting table item to place.');\n      return;\n    }\n\n    // find a free spot (or explore for one)\n    let spot = await findFreePlacementSpot(3);\n    if (!spot) {\n      await bot.chat('\ud83d\udd0d Exploring for a free spot to place the table...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(3);\n        return p ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not find a suitable spot for the crafting table.');\n        return;\n      }\n      spot = await findFreePlacementSpot(3);\n    }\n    await placeItem(bot, 'crafting_table', spot);\n    await bot.chat(`\u2705 Placed crafting table at ${spot}`);\n    tableBlock = bot.blockAt(spot);\n  } else {\n    await bot.chat(`\u2705 Found existing crafting table at ${tableBlock.position}`);\n  }\n\n  // move next to the table (within 1 block) so we can open the UI\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // ---------- step 4: craft the lightning rod ----------\n  await bot.chat('\ud83d\udee0\ufe0f Crafting lightning rod...');\n  try {\n    await craftItem(bot, 'lightning_rod', 1);\n    await bot.chat('\u2705 Lightning rod crafted!');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft lightning rod: ${err.message}`);\n    return;\n  }\n\n  // ---------- step 5: final verification ----------\n  if (bot.inventory.findInventoryItem(rodId)) {\n    await bot.chat('\ud83e\ude84 I now have a lightning rod in my inventory.');\n  } else {\n    await bot.chat('\u26a0\ufe0f Something went wrong \u2013 lightning rod not found.');\n  }\n}", "description": "async function ensureLightningRod(bot) {\n    // The routine first checks if a lightning rod is already in the inventory and exits if found; otherwise it gathers at least three copper ingots by locating and mining copper ore, smelting the raw copper with coal as needed. It then ensures a crafting table is available, placing one on a free air block near solid ground if none is nearby. After moving within one block of the table, it crafts a lightning rod using the collected ingots. Finally it confirms that the lightning rod now resides in the inventory.\n}"}, "craftOneBow": {"code": "// main function to craft a single bow\nasync function craftOneBow(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // 1\ufe0f\u20e3 Check if we already have a bow\n  const bowId = mcData.itemsByName[\"bow\"].id;\n  if (bot.inventory.findInventoryItem(bowId)) {\n    await bot.chat(\"\u2705 I already have a bow.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Verify we have enough sticks and strings\n  const stickId = mcData.itemsByName[\"stick\"].id;\n  const stringId = mcData.itemsByName[\"string\"].id;\n  const neededSticks = 3;\n  const neededStrings = 3;\n  const haveSticks = bot.inventory.count(stickId);\n  const haveStrings = bot.inventory.count(stringId);\n  if (haveSticks < neededSticks || haveStrings < neededStrings) {\n    await bot.chat(`\u274c Missing materials: ${neededSticks - haveSticks} stick(s), ${neededStrings - haveStrings} string(s).`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Find an already placed crafting table\n  const tableBlockId = mcData.blocksByName[\"crafting_table\"].id;\n  let tableBlock = bot.findBlock({\n    matching: tableBlockId,\n    maxDistance: 32\n  });\n\n  // 4\ufe0f\u20e3 If none, place one\n  if (!tableBlock) {\n    await bot.chat(\"\ud83d\udd28 No crafting table placed nearby \u2013 placing one.\");\n\n    // Ensure we have a crafting table item\n    const tableItemId = mcData.itemsByName[\"crafting_table\"].id;\n    const tableItem = bot.inventory.findInventoryItem(tableItemId);\n    if (!tableItem) {\n      await bot.chat(\"\u274c I don't have a crafting table item to place.\");\n      return;\n    }\n\n    // Helper: find a free air block directly above a solid block within a radius\n    async function findFreePlacementSpot(radius = 3) {\n      const botPos = bot.entity.position.floored();\n      for (let dx = -radius; dx <= radius; dx++) {\n        for (let dy = -radius; dy <= radius; dy++) {\n          for (let dz = -radius; dz <= radius; dz++) {\n            const solidPos = botPos.offset(dx, dy, dz);\n            const solidBlock = bot.blockAt(solidPos);\n            if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n            const abovePos = solidPos.offset(0, 1, 0);\n            const aboveBlock = bot.blockAt(abovePos);\n            if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n          }\n        }\n      }\n      return null;\n    }\n    let placePos = await findFreePlacementSpot();\n    if (!placePos) {\n      await bot.chat(\"\u26a0\ufe0f Could not find a free spot nearby, exploring for one.\");\n      const found = await exploreUntil(bot, new Vec3(1, 0, 1), 60, () => {\n        const p = findFreePlacementSpot();\n        return p ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Failed to locate a placement spot for the crafting table.\");\n        return;\n      }\n      placePos = await findFreePlacementSpot();\n    }\n    await placeItem(bot, \"crafting_table\", placePos);\n    tableBlock = bot.blockAt(placePos);\n    await bot.chat(`\u2705 Placed crafting table at ${placePos}`);\n  } else {\n    await bot.chat(`\u2705 Found placed crafting table at ${tableBlock.position}`);\n  }\n\n  // 5\ufe0f\u20e3 Move next to the crafting table\n  await bot.pathfinder.goto(new GoalNear(tableBlock.position.x, tableBlock.position.y, tableBlock.position.z, 1));\n\n  // 6\ufe0f\u20e3 Craft the bow\n  await bot.chat(\"\ud83d\udee0\ufe0f Crafting a bow...\");\n  try {\n    await craftItem(bot, \"bow\", 1);\n    await bot.chat(\"\u2705 Bow crafted successfully!\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to craft bow: ${err.message}`);\n    return;\n  }\n\n  // 7\ufe0f\u20e3 Final verification\n  if (bot.inventory.findInventoryItem(bowId)) {\n    await bot.chat(\"\u2705 I now have a bow in my inventory.\");\n  } else {\n    await bot.chat(\"\u274c Bow not found after crafting.\");\n  }\n}", "description": "async function craftOneBow(bot) {\n    // The routine first checks if a bow is already in the inventory and aborts if so. It then ensures the bot has at least three sticks and three strings, stopping if materials are missing. Next it searches for a nearby crafting table, and if none is found it locates a suitable empty block and places a crafting table there. After moving within one block of the table, it attempts to craft one bow using the available resources. Finally it confirms that the bow now exists in the inventory.\n}"}, "mineFiveGravel": {"code": "// main function to mine at least 5 gravel\nasync function mineFiveGravel(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let dir;\n    do {\n      dir = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (dir.x === 0 && dir.y === 0 && dir.z === 0);\n    return dir;\n  }\n  const gravelId = mcData.itemsByName['gravel'].id;\n  let gravelCount = bot.inventory.count(gravelId);\n  if (gravelCount >= 5) {\n    await bot.chat(`\u2705 I already have ${gravelCount} gravel. Task completed.`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd0e Need ${5 - gravelCount} more gravel.`);\n\n  // ---- ensure we have a pickaxe and equip it ----\n  const pickaxeNames = ['wooden_pickaxe', 'stone_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'diamond_pickaxe', 'netherite_pickaxe'];\n  let pickaxeItem = null;\n  for (const name of pickaxeNames) {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[name].id);\n    if (item) {\n      pickaxeItem = item;\n      break;\n    }\n  }\n  if (pickaxeItem) {\n    try {\n      await bot.equip(pickaxeItem, 'hand');\n      await bot.chat(`\ud83e\ude93 Equipped ${pickaxeItem.name}.`);\n    } catch (e) {\n      await bot.chat(`\u26a0\ufe0f Could not equip pickaxe: ${e.message}`);\n    }\n  } else {\n    await bot.chat('\u26a0\ufe0f No pickaxe found in inventory. I will try to mine with my hand.');\n  }\n\n  // ---- mining loop ----\n  while (gravelCount < 5) {\n    // find a gravel block nearby\n    let gravelBlock = bot.findBlock({\n      matching: mcData.blocksByName['gravel'].id,\n      maxDistance: 32\n    });\n\n    // if none, explore until we find one\n    if (!gravelBlock) {\n      await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f No gravel nearby, exploring...');\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName['gravel'].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat('\u274c Could not locate gravel after exploring. Stopping.');\n        return;\n      }\n      gravelBlock = bot.findBlock({\n        matching: mcData.blocksByName['gravel'].id,\n        maxDistance: 32\n      });\n    }\n    const need = 5 - gravelCount;\n    await bot.chat(`\u26cf\ufe0f Mining ${need} gravel block(s)...`);\n    await mineBlock(bot, 'gravel', need);\n\n    // recount\n    gravelCount = bot.inventory.count(gravelId);\n    await bot.chat(`\ud83d\udce6 Gravel now: ${gravelCount}/5`);\n  }\n  await bot.chat('\u2705 Task finished \u2013 I have collected at least 5 gravel!');\n}", "description": "async function mineFiveGravel(bot) {\n    // The function ensures the bot collects at least five gravel by first checking the current inventory count, then attempting to equip any available pickaxe. It repeatedly searches for nearby gravel blocks, and if none are found it explores in random directions until gravel is located. Once gravel is found, it mines the required number of blocks and updates the inventory count, looping until the target amount is reached. Finally, it confirms the task is complete once five or more gravel items are in the inventory.\n}"}, "equipIronSword": {"code": "// Main function: equip an iron sword to the bot's hand\nasync function equipIronSword(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // 1\ufe0f\u20e3 Find the iron sword in the inventory\n  const swordId = mcData.itemsByName.iron_sword.id;\n  const swordItem = bot.inventory.findInventoryItem(swordId);\n  if (!swordItem) {\n    await bot.chat(\"\u274c I don't have an iron sword in my inventory to equip.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Equip the sword to the main hand\n  try {\n    await bot.equip(swordItem, \"hand\");\n    await bot.chat(\"\u2705 Iron sword equipped in my hand.\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip iron sword: ${err.message}`);\n  }\n}", "description": "async function equipIronSword(bot) {\n    // The function searches the bot\u2019s inventory for an iron sword and exits if none is found; if the sword is present, it attempts to equip it in the main hand and handles any errors that may occur during the equipping process.\n}"}, "craftStoneAxe": {"code": "// main function to craft one stone axe\nasync function craftStoneAxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // Helper: pick a random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // Helper: find a free air spot above a solid block within a radius\n  async function findFreePlacementSpot(radius = 3) {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -radius; dx <= radius; dx++) {\n      for (let dy = -radius; dy <= radius; dy++) {\n        for (let dz = -radius; dz <= radius; dz++) {\n          const solidPos = botPos.offset(dx, dy, dz);\n          const solidBlock = bot.blockAt(solidPos);\n          if (!solidBlock || solidBlock.name === \"air\") continue; // need solid ground\n          const abovePos = solidPos.offset(0, 1, 0);\n          const aboveBlock = bot.blockAt(abovePos);\n          if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n        }\n      }\n    }\n    return null;\n  }\n\n  // 1\ufe0f\u20e3 Already have a stone axe?\n  const axeId = mcData.itemsByName[\"stone_axe\"].id;\n  if (bot.inventory.findInventoryItem(axeId)) {\n    await bot.chat(\"I already have a stone axe.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have enough cobblestone (\u22653) and sticks (\u22652)\n  const cobId = mcData.itemsByName[\"cobblestone\"].id;\n  const stickId = mcData.itemsByName[\"stick\"].id;\n  let cobCount = bot.inventory.count(cobId);\n  let stickCount = bot.inventory.count(stickId);\n  if (cobCount < 3) {\n    const need = 3 - cobCount;\n    await bot.chat(`Need ${need} more cobblestone, mining stone...`);\n    await mineBlock(bot, \"stone\", need);\n    cobCount = bot.inventory.count(cobId);\n  } else {\n    await bot.chat(`Cobblestone OK: ${cobCount}/3`);\n  }\n  if (stickCount < 2) {\n    const need = 2 - stickCount;\n    // each stick craft yields 4 sticks, consumes 2 planks\n    const craftTimes = Math.ceil(need / 4);\n    const planksNeeded = craftTimes * 2;\n\n    // ensure planks\n    const plankId = mcData.itemsByName[\"oak_planks\"].id;\n    let plankCount = bot.inventory.count(plankId);\n    if (plankCount < planksNeeded) {\n      const logsNeeded = Math.ceil((planksNeeded - plankCount) / 4);\n      await bot.chat(`Need ${planksNeeded - plankCount} planks, mining ${logsNeeded} oak log(s)...`);\n      await mineBlock(bot, \"oak_log\", logsNeeded);\n      await craftItem(bot, \"oak_planks\", logsNeeded);\n    }\n\n    // ensure a crafting table is placed before crafting sticks\n    await ensureCraftingTablePlaced();\n    await bot.chat(`Crafting ${need} stick(s) (${craftTimes} craft operation(s))...`);\n    await craftItem(bot, \"stick\", craftTimes);\n    stickCount = bot.inventory.count(stickId);\n  } else {\n    await bot.chat(`Sticks OK: ${stickCount}/2`);\n  }\n\n  // 3\ufe0f\u20e3 Ensure a placed crafting table is nearby\n  async function ensureCraftingTablePlaced() {\n    // Look for an already placed table\n    const placed = bot.findBlock({\n      matching: mcData.blocksByName[\"crafting_table\"].id,\n      maxDistance: 32\n    });\n    if (placed) {\n      await bot.chat(\"Found a placed crafting table nearby.\");\n      await bot.pathfinder.goto(new GoalNear(placed.position.x, placed.position.y, placed.position.z, 1));\n      return;\n    }\n\n    // No placed table \u2013 need to place one from inventory\n    const tableItemId = mcData.itemsByName[\"crafting_table\"].id;\n    if (!bot.inventory.findInventoryItem(tableItemId)) {\n      await bot.chat(\"\u274c No crafting table item in inventory, cannot place one.\");\n      throw new Error(\"Missing crafting table item\");\n    }\n\n    // Find a free spot\n    let spot = await findFreePlacementSpot(3);\n    // If not found, explore a bit and retry\n    while (!spot) {\n      await bot.chat(\"No free spot nearby, exploring for a place...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const p = findFreePlacementSpot(3);\n        return p ? true : null;\n      });\n      if (found) spot = await findFreePlacementSpot(3);else break;\n    }\n    if (!spot) {\n      await bot.chat(\"\u274c Could not find a place to put a crafting table.\");\n      throw new Error(\"No placement spot\");\n    }\n    await bot.chat(`Placing crafting table at ${spot}`);\n    await placeItem(bot, \"crafting_table\", spot);\n    // Move next to it\n    await bot.pathfinder.goto(new GoalNear(spot.x, spot.y, spot.z, 1));\n    await bot.chat(\"Crafting table placed and bot is nearby.\");\n  }\n  await ensureCraftingTablePlaced();\n\n  // 4\ufe0f\u20e3 Craft the stone axe\n  await bot.chat(\"Crafting stone axe...\");\n  await craftItem(bot, \"stone_axe\", 1);\n  await bot.chat(\"Stone axe crafted.\");\n\n  // 5\ufe0f\u20e3 Verify result\n  if (bot.inventory.findInventoryItem(axeId)) {\n    await bot.chat(\"\u2705 I now have a stone axe.\");\n  } else {\n    await bot.chat(\"\u274c Failed to craft the stone axe.\");\n  }\n}", "description": "async function craftStoneAxe(bot) {\n    // The routine first checks if a stone axe is already in the inventory and, if not, ensures the bot has at least three cobblestones and two sticks (mining stone and logs and crafting planks and sticks as needed); it then locates or places a crafting table on a free air spot near a solid block, moves the bot next to it, crafts the stone axe, and finally verifies that the axe was successfully added to the inventory.\n}"}, "smeltFiveIronOre": {"code": "// main function: smelt 5 iron ore (raw_iron -> iron_ingot)\nasync function smeltFiveIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // -----------------------------------------------------------------\n  // Helper: random direction vector with components -1,0,1 (not all 0)\n  // -----------------------------------------------------------------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // -----------------------------------------------------------------\n  // Helper: find a free air block directly above a solid block within 3 blocks\n  // -----------------------------------------------------------------\n  async function findPlacementSpot() {\n    const botPos = bot.entity.position.floored();\n    for (let dx = -3; dx <= 3; dx++) {\n      for (let dz = -3; dz <= 3; dz++) {\n        const solidPos = botPos.offset(dx, 0, dz);\n        const solidBlock = bot.blockAt(solidPos);\n        if (!solidBlock || solidBlock.name === \"air\") continue; // need solid support\n        const abovePos = solidPos.offset(0, 1, 0);\n        const aboveBlock = bot.blockAt(abovePos);\n        if (aboveBlock && aboveBlock.name === \"air\") return abovePos;\n      }\n    }\n    return null;\n  }\n\n  // -----------------------------------------------------------------\n  // 1\ufe0f\u20e3 Ensure we have at least 5 raw_iron\n  // -----------------------------------------------------------------\n  const rawIronId = mcData.itemsByName[\"raw_iron\"].id;\n  let rawIronCount = bot.inventory.count(rawIronId);\n  const TARGET_RAW = 5;\n  if (rawIronCount < TARGET_RAW) {\n    const need = TARGET_RAW - rawIronCount;\n    await bot.chat(`Need ${need} more raw iron. Searching for iron ore...`);\n\n    // Try to locate ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName[\"iron_ore\"].id,\n      maxDistance: 32\n    });\n\n    // If not found, explore until one appears\n    if (!oreBlock) {\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName[\"iron_ore\"].id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Could not locate any iron ore after exploring.\");\n        return;\n      }\n    }\n\n    // Mine the required amount (may mine a few extra, that's fine)\n    await bot.chat(`Mining ${need} iron ore block(s)...`);\n    await mineBlock(bot, \"iron_ore\", need);\n    await bot.waitForTicks(10); // let inventory update\n    rawIronCount = bot.inventory.count(rawIronId);\n    await bot.chat(`Now have ${rawIronCount} raw iron.`);\n    if (rawIronCount < TARGET_RAW) {\n      await bot.chat(\"\u274c Still not enough raw iron after mining.\");\n      return;\n    }\n  } else {\n    await bot.chat(`Already have ${rawIronCount} raw iron.`);\n  }\n\n  // -----------------------------------------------------------------\n  // 2\ufe0f\u20e3 Ensure a furnace is placed\n  // -----------------------------------------------------------------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName[\"furnace\"].id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    await bot.chat(\"No placed furnace found. Trying to place one from inventory...\");\n\n    // Need a furnace item\n    const furnaceItemId = mcData.itemsByName[\"furnace\"].id;\n    const furnaceItem = bot.inventory.findInventoryItem(furnaceItemId);\n    if (!furnaceItem) {\n      await bot.chat(\"\u274c No furnace item in inventory, cannot continue.\");\n      return;\n    }\n\n    // Find a free spot\n    let placePos = await findPlacementSpot();\n    if (!placePos) {\n      await bot.chat(\"\u274c Could not find a suitable spot to place a furnace.\");\n      return;\n    }\n    await placeItem(bot, \"furnace\", placePos);\n    await bot.chat(`Furnace placed at ${placePos}`);\n    furnaceBlock = bot.blockAt(placePos);\n  } else {\n    await bot.chat(\"Found a placed furnace nearby.\");\n  }\n\n  // -----------------------------------------------------------------\n  // 3\ufe0f\u20e3 Ensure we have fuel (prefer coal, fallback to sticks)\n  // -----------------------------------------------------------------\n  let fuelName = \"coal\";\n  let fuelId = mcData.itemsByName[fuelName].id;\n  let fuelCount = bot.inventory.count(fuelId);\n  if (fuelCount < 1) {\n    // try sticks as fallback\n    fuelName = \"stick\";\n    fuelId = mcData.itemsByName[fuelName].id;\n    fuelCount = bot.inventory.count(fuelId);\n    if (fuelCount < 1) {\n      await bot.chat(\"\u274c No coal or sticks for fuel. Cannot smelt.\");\n      return;\n    }\n  }\n  await bot.chat(`Fuel check passed (${fuelName} x${fuelCount}).`);\n\n  // -----------------------------------------------------------------\n  // 4\ufe0f\u20e3 Smelt the raw iron\n  // -----------------------------------------------------------------\n  const toSmelt = Math.min(TARGET_RAW, rawIronCount);\n  await bot.chat(`Smelting ${toSmelt} raw iron using ${fuelName}...`);\n  await smeltItem(bot, \"raw_iron\", fuelName, toSmelt);\n  await bot.chat(\"Smelting completed.\");\n\n  // -----------------------------------------------------------------\n  // 5\ufe0f\u20e3 Report final ingot count\n  // -----------------------------------------------------------------\n  const ingotId = mcData.itemsByName[\"iron_ingot\"].id;\n  const finalIngotCount = bot.inventory.count(ingotId);\n  await bot.chat(`\u2705 I now have ${finalIngotCount} iron ingot(s). Task complete.`);\n}", "description": "async function smeltFiveIronOre(bot) {\n    // The function gathers at least five raw iron (mining ore if needed), ensures a furnace is placed nearby, verifies that fuel (coal or sticks) is available, smelts the raw iron into iron ingots using the furnace, and finally reports the total number of iron ingots obtained.\n}"}, "takeBreadFromChest": {"code": "// Main function: take bread from the chest at (-11, 31, -62)\nasync function takeBreadFromChest(bot) {\n  const {\n    Vec3\n  } = require('vec3'); // import Vec3\n  const chestPos = new Vec3(-11, 31, -62); // chest coordinates\n\n  // Try to move to the chest and withdraw 1 stack of bread\n  try {\n    await bot.chat('Going to the chest to take bread...');\n    await getItemFromChest(bot, chestPos, {\n      bread: 1\n    });\n    await bot.chat('\u2705 Bread has been taken from the chest.');\n  } catch (err) {\n    // If something goes wrong (e.g., chest not found), report it\n    await bot.chat(`\u274c Failed to take bread: ${err.message}`);\n  }\n}", "description": "async function takeBreadFromChest(bot) {\n    // The routine moves the bot to the chest located at (-11,\u202f31,\u202f\u201162), attempts to withdraw a full stack of bread, ensures the bot reaches the chest before extraction, and handles any errors that occur, indicating whether the bread was successfully taken.\n}"}, "craftOneShield": {"code": "// -----------------------------------------------------------------------------\n// Helper: random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// Helper: find a free air block directly above a **solid, non\u2011fluid** block\n\n// Helper: find a free air block directly above a **solid, non\u2011fluid** block\nasync function findFreePlacementSpot(bot, radius = 3) {\n  const mcData = require('minecraft-data')(bot.version);\n  const botPos = bot.entity.position.floored();\n\n  // helper to decide whether a block can support placement\n  const isSolidGround = block => {\n    if (!block) return false;\n    if (block.name === 'air') return false;\n    if (block.name.includes('water') || block.name.includes('lava')) return false;\n    // most solid blocks have a non\u2011empty bounding box\n    return block.boundingBox !== 'empty';\n  };\n  for (let dx = -radius; dx <= radius; dx++) {\n    for (let dy = -radius; dy <= radius; dy++) {\n      for (let dz = -radius; dz <= radius; dz++) {\n        const groundPos = botPos.offset(dx, dy, dz);\n        const groundBlock = bot.blockAt(groundPos);\n        if (!isSolidGround(groundBlock)) continue;\n        const placePos = groundPos.offset(0, 1, 0); // the block we will place on\n        const above = bot.blockAt(placePos);\n        const head = bot.blockAt(placePos.offset(0, 1, 0));\n        if (above && above.name === 'air' && head && head.name === 'air') {\n          return placePos; // suitable spot\n        }\n      }\n    }\n  }\n  return null;\n}\n\n// Ensure a crafting table is placed nearby and return its block position\n\n// Ensure a crafting table is placed nearby and return its block position\nasync function ensureCraftingTable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Look for an already placed table\n  const existing = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (existing) {\n    await bot.pathfinder.goto(new GoalNear(existing.position.x, existing.position.y, existing.position.z, 1));\n    await bot.chat('Found a placed crafting table.');\n    return existing.position;\n  }\n\n  // 2\ufe0f\u20e3 Need to place one from inventory\n  const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n  if (!tableItem) {\n    await bot.chat('\u274c No crafting table item in inventory.');\n    throw new Error('Missing crafting table');\n  }\n\n  // 3\ufe0f\u20e3 Find a valid spot\n  let spot = await findFreePlacementSpot(bot, 3);\n  while (!spot) {\n    await bot.chat('No free spot for table, exploring...');\n    const found = await exploreUntil(bot, randomDirection(), 60, () => findFreePlacementSpot(bot, 3) ? true : null);\n    if (!found) break;\n    spot = await findFreePlacementSpot(bot, 3);\n  }\n  if (!spot) {\n    await bot.chat('\u274c Could not locate a suitable position to place a crafting table.');\n    throw new Error('No placement spot');\n  }\n\n  // 4\ufe0f\u20e3 Place the table\n  await bot.chat(`Placing crafting table at ${spot}`);\n  await placeItem(bot, 'crafting_table', spot);\n  await bot.pathfinder.goto(new GoalNear(spot.x, spot.y, spot.z, 1));\n  await bot.chat('Crafting table placed.');\n  return spot;\n}\n\n// -----------------------------------------------------------------------------\n// Main function: craft one shield\n\n// -----------------------------------------------------------------------------\n// Main function: craft one shield\nasync function craftOneShield(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // Helper to count items by name\n  const countItem = name => bot.inventory.count(mcData.itemsByName[name].id);\n\n  // 1\ufe0f\u20e3 Ensure we have at least 6 planks (any type). Use oak_planks as default.\n  const plankName = 'oak_planks';\n  const neededPlanks = 6;\n  let havePlanks = countItem(plankName);\n  if (havePlanks < neededPlanks) {\n    const missing = neededPlanks - havePlanks;\n    await bot.chat(`Need ${missing} more planks.`);\n\n    // Mine logs if necessary\n    const logsNeeded = Math.ceil(missing / 4);\n    await bot.chat(`Mining ${logsNeeded} oak log(s)...`);\n    await mineBlock(bot, 'oak_log', logsNeeded);\n\n    // Ensure a crafting table to craft planks\n    await ensureCraftingTable(bot);\n    const batches = Math.ceil(missing / 4);\n    await bot.chat(`Crafting ${batches} batch(es) of oak planks...`);\n    await craftItem(bot, plankName, batches);\n    havePlanks = countItem(plankName);\n    await bot.chat(`Now have ${havePlanks} planks.`);\n  } else {\n    await bot.chat(`Plank count sufficient (${havePlanks}).`);\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have at least 1 iron ingot\n  const ironIngotId = mcData.itemsByName.iron_ingot.id;\n  if (bot.inventory.count(ironIngotId) < 1) {\n    await bot.chat('\u274c No iron ingot available, cannot craft shield.');\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Ensure a crafting table is present (may already be placed)\n  await ensureCraftingTable(bot);\n\n  // 4\ufe0f\u20e3 Craft the shield\n  await bot.chat('Crafting the shield...');\n  await craftItem(bot, 'shield', 1);\n  const shieldId = mcData.itemsByName.shield.id;\n  if (bot.inventory.findInventoryItem(shieldId)) {\n    await bot.chat('\u2705 Shield crafted successfully!');\n  } else {\n    await bot.chat('\u274c Failed to craft the shield.');\n  }\n}", "description": "async function craftOneShield(bot) {\n    // The routine first verifies that the inventory contains at least six planks, mining oak logs and crafting additional planks as needed, then checks for at least one iron ingot, ensures a crafting table is placed nearby, crafts a single shield, and finally confirms that the shield now exists in the inventory.\n}"}, "equipShield": {"code": "// Main function to equip a shield in the off\u2011hand\nasync function equipShield(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // 1\ufe0f\u20e3 Find the shield item in the inventory\n  const shieldId = mcData.itemsByName.shield.id;\n  const shieldItem = bot.inventory.findInventoryItem(shieldId);\n  if (!shieldItem) {\n    await bot.chat(\"\u274c I don't have a shield in my inventory to equip.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Equip the shield to the off\u2011hand slot\n  try {\n    await bot.equip(shieldItem, \"off-hand\");\n    await bot.chat(\"\u2705 Shield equipped in off\u2011hand.\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip shield: ${err.message}`);\n  }\n}", "description": "async function equipShield(bot) {\n    // The function searches the bot\u2019s inventory for a shield item and aborts if none is found; if a shield is present, it attempts to equip it into the off\u2011hand slot and catches any errors that occur during the equip operation.\n}"}, "eatBread": {"code": "// Main function to eat a loaf of bread\nasync function eatBread(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const breadId = mcData.itemsByName.bread.id;\n\n  // 1\ufe0f\u20e3 Find bread in inventory\n  const breadItem = bot.inventory.findInventoryItem(breadId);\n  if (!breadItem) {\n    await bot.chat(\"\u274c I don't have any bread in my inventory to eat.\");\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Equip bread to the hand\n  try {\n    await bot.equip(breadItem, \"hand\");\n    await bot.chat(\"\u2705 Bread equipped, preparing to eat...\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip bread: ${err.message}`);\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Eat the bread\n  try {\n    await bot.consume(); // this will wait until the eating animation finishes\n    await bot.chat(\"\u2705 I have eaten the bread and restored my hunger.\");\n  } catch (err) {\n    await bot.chat(`\u274c Failed to eat bread: ${err.message}`);\n  }\n}", "description": "async function eatBread(bot) {\n    // The function checks the bot\u2019s inventory for bread and stops if none is present, then attempts to equip the bread in the hand, handling any equip errors, and finally tries to consume the bread to restore hunger while catching any consumption failures.\n}"}, "mineFiveGoldOre": {"code": "// ---------------------------------------------------------------\n// Helper: random direction vector (components -1,0,1, not all zero)\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// ---------------------------------------------------------------\n// Helper: ensure we have an iron\u2011or\u2011better pickaxe equipped\n\n// ---------------------------------------------------------------\n// Helper: ensure we have an iron\u2011or\u2011better pickaxe equipped\nasync function ensurePickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const order = [\"netherite_pickaxe\", \"diamond_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n  for (const name of order) {\n    const id = mcData.itemsByName[name].id;\n    const item = bot.inventory.findInventoryItem(id);\n    if (item) {\n      await bot.equip(item, \"hand\");\n      await bot.chat(`\u2705 Equipped ${name}.`);\n      return true;\n    }\n  }\n  await bot.chat(\"\u274c No pickaxe (iron or better) in inventory.\");\n  return false;\n}\n\n// ---------------------------------------------------------------\n// Helper: ensure we have at least `count` coal (mines if needed)\n\n// ---------------------------------------------------------------\n// Helper: ensure we have at least `count` coal (mines if needed)\nasync function ensureCoal(bot, count) {\n  const mcData = require('minecraft-data')(bot.version);\n  const coalId = mcData.itemsByName.coal.id;\n  const have = bot.inventory.count(coalId);\n  if (have >= count) {\n    await bot.chat(`\u2705 Coal check passed (${have}/${count}).`);\n    return;\n  }\n  const need = count - have;\n  await bot.chat(`\ud83d\udd28 Need ${need} more coal, mining coal ore...`);\n  await mineBlock(bot, \"coal_ore\", need);\n}\n\n// ---------------------------------------------------------------\n// Helper: ensure a furnace exists within 32 blocks of the bot.\n// If none is found, place a new one next to the bot.\n\n// ---------------------------------------------------------------\n// Helper: ensure a furnace exists within 32 blocks of the bot.\n// If none is found, place a new one next to the bot.\nasync function ensureFurnaceNearby(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  // look for any furnace within 32 blocks of current position\n  let furnace = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (furnace) {\n    await bot.chat(`\u2705 Found nearby furnace at ${furnace.position}`);\n    return furnace;\n  }\n\n  // need a furnace item to place\n  const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n  if (!furnaceItem) {\n    await bot.chat(\"\u274c No furnace item in inventory to place.\");\n    return null;\n  }\n\n  // find a solid block adjacent to the bot to serve as reference\n  const reference = bot.findBlock({\n    matching: b => b.name !== \"air\",\n    maxDistance: 3\n  });\n  if (!reference) {\n    await bot.chat(\"\u274c No solid block nearby to place a furnace on.\");\n    return null;\n  }\n  const placePos = reference.position.offset(0, 1, 0);\n  await bot.chat(`Placing furnace at ${placePos}`);\n  await placeItem(bot, \"furnace\", placePos);\n  return bot.blockAt(placePos);\n}\n\n// ---------------------------------------------------------------\n// Main function: mine at least 5 gold ore and smelt them\n\n// ---------------------------------------------------------------\n// Main function: mine at least 5 gold ore and smelt them\nasync function mineFiveGoldOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // 1\ufe0f\u20e3 Pickaxe\n  if (!(await ensurePickaxe(bot))) return;\n\n  // 2\ufe0f\u20e3 Coal for smelting (5 pieces)\n  await ensureCoal(bot, 5);\n\n  // 3\ufe0f\u20e3 Locate gold ore (explore if necessary)\n  const goldOreId = mcData.blocksByName.gold_ore.id;\n  let goldBlock = bot.findBlock({\n    matching: goldOreId,\n    maxDistance: 32\n  });\n  if (!goldBlock) {\n    await bot.chat(\"\ud83d\udd0e Gold ore not nearby, exploring...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: goldOreId,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Exploration failed to locate gold ore.\");\n      return;\n    }\n    goldBlock = bot.findBlock({\n      matching: goldOreId,\n      maxDistance: 32\n    });\n  }\n  await bot.chat(`\u2705 Gold ore located at ${goldBlock.position}`);\n\n  // 4\ufe0f\u20e3 Mine 5 gold ore blocks\n  await bot.chat(\"\u26cf\ufe0f Mining gold ore...\");\n  await mineBlock(bot, \"gold_ore\", 5);\n\n  // 5\ufe0f\u20e3 Verify we have at least 5 raw_gold\n  const rawGoldId = mcData.itemsByName.raw_gold.id;\n  let rawGoldCount = bot.inventory.count(rawGoldId);\n  if (rawGoldCount < 5) {\n    const need = 5 - rawGoldCount;\n    await bot.chat(`\u26a0\ufe0f Only ${rawGoldCount} raw gold, mining ${need} more ore...`);\n    await mineBlock(bot, \"gold_ore\", need);\n    rawGoldCount = bot.inventory.count(rawGoldId);\n  }\n\n  // 6\ufe0f\u20e3 Ensure a furnace is nearby\n  const furnaceBlock = await ensureFurnaceNearby(bot);\n  if (!furnaceBlock) {\n    await bot.chat(\"\u274c Cannot continue without a furnace.\");\n    return;\n  }\n\n  // 7\ufe0f\u20e3 Move next to the furnace\n  await bot.pathfinder.goto(new GoalNear(furnaceBlock.position.x, furnaceBlock.position.y, furnaceBlock.position.z, 1));\n\n  // 8\ufe0f\u20e3 Smelt raw gold into ingots\n  await bot.chat(`\ud83d\udd25 Smelting ${rawGoldCount} raw gold into ingots...`);\n  await smeltItem(bot, \"raw_gold\", \"coal\", rawGoldCount);\n\n  // 9\ufe0f\u20e3 Report result\n  const goldIngotId = mcData.itemsByName.gold_ingot.id;\n  const goldIngotCount = bot.inventory.count(goldIngotId);\n  if (goldIngotCount >= 5) {\n    await bot.chat(`\u2705 Success! I now have ${goldIngotCount} gold ingot(s).`);\n  } else {\n    await bot.chat(`\u274c Finished but only have ${goldIngotCount} gold ingot(s).`);\n  }\n}", "description": "async function mineFiveGoldOre(bot) {\n    // The routine first checks that the bot has an iron\u2011or\u2011better pickaxe equipped. It then guarantees at least five pieces of coal are available for smelting, mining more if necessary. It searches for gold ore within a 32\u2011block radius and, if none is found, explores randomly until a vein is located. After mining at least five gold ore blocks and confirming sufficient raw gold, it ensures a furnace is present nearby, places one if needed, and moves the bot next to it. Finally, it smelts the raw gold into ingots and reports whether at least five gold ingots were obtained.\n}"}, "placeChestNearby": {"code": "// Main function to place a chest near the bot\nasync function placeChestNearby(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3 Check if a chest already exists nearby (within 5 blocks)\n  const existingChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 5\n  });\n  if (existingChest) {\n    await bot.chat(`\u2705 Chest already present at ${existingChest.position}.`);\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Ensure we have a chest item in inventory\n  const chestItem = bot.inventory.findInventoryItem(mcData.itemsByName.chest.id);\n  if (!chestItem) {\n    await bot.chat(\"\u274c I don't have a chest item in my inventory.\");\n    return;\n  }\n\n  // 3\ufe0f\u20e3 Find a solid reference block close to the bot (within 3 blocks)\n  const reference = bot.findBlock({\n    matching: b => b && b.name !== \"air\",\n    maxDistance: 3\n  });\n  if (!reference) {\n    await bot.chat(\"\u274c No solid block nearby to use as a placement reference.\");\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Determine possible placement positions around the reference block\n  const candidateOffsets = [new Vec3(0, 1, 0),\n  // on top\n  new Vec3(1, 0, 0),\n  // east\n  new Vec3(-1, 0, 0),\n  // west\n  new Vec3(0, 0, 1),\n  // south\n  new Vec3(0, 0, -1) // north\n  ];\n  let placePos = null;\n  for (const off of candidateOffsets) {\n    const pos = reference.position.plus(off);\n    const block = bot.blockAt(pos);\n    if (block && block.name === \"air\") {\n      placePos = pos;\n      break;\n    }\n  }\n  if (!placePos) {\n    await bot.chat(\"\u274c Couldn't find a free air block next to a solid block to place the chest.\");\n    return;\n  }\n\n  // 5\ufe0f\u20e3 Place the chest\n  await bot.chat(`Placing chest at ${placePos}...`);\n  try {\n    await placeItem(bot, \"chest\", placePos);\n  } catch (err) {\n    await bot.chat(`\u274c Failed to place chest: ${err.message}`);\n    return;\n  }\n\n  // 6\ufe0f\u20e3 Verify placement\n  const placed = bot.blockAt(placePos);\n  if (placed && placed.name === \"chest\") {\n    await bot.chat(`\u2705 Chest successfully placed at ${placePos}.`);\n  } else {\n    await bot.chat(\"\u274c Chest placement failed.\");\n  }\n}", "description": "async function placeChestNearby(bot) {\n    // The routine first looks for an existing chest within five blocks and aborts if one is found, then confirms the bot holds a chest item, searches for a nearby solid block within three blocks, chooses an adjacent empty air space from a set of possible offsets, attempts to place the chest at that location, and finally checks that the chest was successfully placed.\n}"}, "craftClock": {"code": "// ---------- helper functions ----------\nfunction randomDirection() {\n  const choices = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n  } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n  return vec;\n}\n\n// equip any pickaxe (iron or better)\n\n// equip any pickaxe (iron or better)\nasync function ensurePickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const pickaxeOrder = [\"netherite_pickaxe\", \"diamond_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n  for (const name of pickaxeOrder) {\n    const id = mcData.itemsByName[name].id;\n    const item = bot.inventory.findInventoryItem(id);\n    if (item) {\n      await bot.equip(item, \"hand\");\n      await bot.chat(`\u2705 Equipped ${name}.`);\n      return true;\n    }\n  }\n  await bot.chat(\"\u274c No pickaxe found in inventory.\");\n  return false;\n}\n\n// ensure we have at least `count` redstone dust\n\n// ensure we have at least `count` redstone dust\nasync function ensureRedstone(bot, count = 1) {\n  const mcData = require('minecraft-data')(bot.version);\n  const redstoneId = mcData.itemsByName.redstone.id;\n  let have = bot.inventory.count(redstoneId);\n  if (have >= count) {\n    await bot.chat(`\u2705 Redstone check passed (${have}/${count}).`);\n    return true;\n  }\n\n  // try to take from a chest nearby\n  const nearbyChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 5\n  });\n  if (nearbyChest) {\n    const chestBlock = bot.blockAt(nearbyChest.position);\n    const chest = await bot.openContainer(chestBlock);\n    const stack = chest.findContainerItem(redstoneId);\n    if (stack) {\n      const toTake = Math.min(count - have, stack.count);\n      await chest.withdraw(redstoneId, null, toTake);\n      await chest.close();\n      have = bot.inventory.count(redstoneId);\n      if (have >= count) {\n        await bot.chat(`\u2705 Took ${toTake} redstone from chest.`);\n        return true;\n      }\n    }\n    await chest.close();\n  }\n\n  // need to mine redstone ore\n  await bot.chat(`\ud83d\udd0e Need ${count - have} more redstone dust \u2013 mining redstone ore...`);\n  // find ore nearby\n  const mc = require('minecraft-data')(bot.version);\n  let ore = bot.findBlock({\n    matching: mc.blocksByName.redstone_ore.id,\n    maxDistance: 32\n  });\n  if (!ore) {\n    await bot.chat(\"Exploring for redstone ore...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: mc.blocksByName.redstone_ore.id,\n        maxDistance: 32\n      });\n      return blk ? true : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Could not locate redstone ore.\");\n      return false;\n    }\n    ore = bot.findBlock({\n      matching: mc.blocksByName.redstone_ore.id,\n      maxDistance: 32\n    });\n  }\n\n  // mine enough ore blocks\n  const needBlocks = Math.ceil((count - have) / 1); // each ore drops at least 1 dust\n  await mineBlock(bot, \"redstone_ore\", needBlocks);\n  // short wait for inventory update\n  await bot.waitForTicks(10);\n  have = bot.inventory.count(redstoneId);\n  if (have >= count) {\n    await bot.chat(`\u2705 Acquired ${have} redstone dust.`);\n    return true;\n  }\n  await bot.chat(`\u274c Still missing redstone dust after mining (have ${have}).`);\n  return false;\n}\n\n// ensure a crafting table block exists nearby, otherwise place one\n\n// ensure a crafting table block exists nearby, otherwise place one\nasync function ensureCraftingTable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const tableId = mcData.blocksByName.crafting_table.id;\n  const nearby = bot.findBlock({\n    matching: tableId,\n    maxDistance: 5\n  });\n  if (nearby) {\n    await bot.chat(`\u2705 Crafting table already present at ${nearby.position}.`);\n    return true;\n  }\n\n  // need a crafting table item\n  const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n  if (!tableItem) {\n    await bot.chat(\"\u274c No crafting table item in inventory.\");\n    return false;\n  }\n\n  // find a free air block adjacent to the bot\n  const candidates = [bot.entity.position.offset(1, 0, 0), bot.entity.position.offset(-1, 0, 0), bot.entity.position.offset(0, 0, 1), bot.entity.position.offset(0, 0, -1), bot.entity.position.offset(0, 1, 0)];\n  let placePos = null;\n  for (const pos of candidates) {\n    const block = bot.blockAt(pos);\n    if (block && block.name === \"air\") {\n      placePos = pos;\n      break;\n    }\n  }\n  if (!placePos) {\n    await bot.chat(\"\u274c No suitable air block to place a crafting table.\");\n    return false;\n  }\n  await bot.chat(`Placing crafting table at ${placePos}...`);\n  try {\n    await placeItem(bot, \"crafting_table\", placePos);\n    await bot.chat(\"\u2705 Crafting table placed.\");\n    return true;\n  } catch (e) {\n    await bot.chat(`\u274c Failed to place crafting table: ${e.message}`);\n    return false;\n  }\n}\n\n// ---------- main function ----------\n\n// ---------- main function ----------\nasync function craftClock(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const goldId = mcData.itemsByName.gold_ingot.id;\n  const redstoneId = mcData.itemsByName.redstone.id;\n\n  // 1. Equip a pickaxe\n  if (!(await ensurePickaxe(bot))) return;\n\n  // 2. Ensure we have at least 4 gold ingots\n  const goldCount = bot.inventory.count(goldId);\n  if (goldCount < 4) {\n    await bot.chat(`\u274c Need at least 4 gold ingots (have ${goldCount}).`);\n    return;\n  }\n  await bot.chat(`\u2705 Gold ingots check passed (${goldCount} available).`);\n\n  // 3. Ensure we have at least 1 redstone dust\n  if (!(await ensureRedstone(bot, 1))) return;\n\n  // 4. Ensure a crafting table is present\n  if (!(await ensureCraftingTable(bot))) return;\n\n  // 5. Craft the clock\n  await bot.chat(\"\ud83d\udee0\ufe0f Crafting a clock...\");\n  try {\n    await craftItem(bot, \"clock\", 1);\n    await bot.chat(\"\u2705 Clock crafted successfully!\");\n  } catch (e) {\n    await bot.chat(`\u274c Failed to craft clock: ${e.message}`);\n  }\n}", "description": "async function craftClock(bot) {\n    // The routine first ensures the bot is equipped with a pickaxe of iron tier or better, then verifies that the inventory contains at least four gold ingots; it also checks for at least one redstone dust, acquiring more if needed, and confirms a crafting table is nearby, placing one if absent, before finally attempting to craft a clock using the gathered resources.\n}"}, "mineTenGravel": {"code": "// main function to mine at least 10 gravel\nasync function mineTenGravel(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- 1. Ensure we have a shovel ----------\n  async function ensureShovel() {\n    // try to find any shovel, prefer the best one\n    const shovelOrder = [\"netherite_shovel\", \"diamond_shovel\", \"iron_shovel\", \"stone_shovel\", \"golden_shovel\", \"wooden_shovel\"];\n    for (const name of shovelOrder) {\n      const id = mcData.itemsByName[name].id;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) {\n        await bot.equip(item, \"hand\");\n        await bot.chat(`\u2705 Shovel equipped: ${name}`);\n        return true;\n      }\n    }\n\n    // No shovel \u2013 craft an iron shovel (needs 2 sticks + 1 iron_ingot)\n    const stickId = mcData.itemsByName.stick.id;\n    const ironIngotId = mcData.itemsByName.iron_ingot.id;\n    if (bot.inventory.count(stickId) < 2 || bot.inventory.count(ironIngotId) < 1) {\n      await bot.chat(\"\u274c Not enough sticks or iron ingots to craft a shovel.\");\n      return false;\n    }\n\n    // Ensure a crafting table is present before crafting\n    if (!(await ensureCraftingTable())) return false;\n    await bot.chat(\"\ud83d\udd28 Crafting an iron shovel...\");\n    try {\n      await craftItem(bot, \"iron_shovel\", 1);\n      const shovelItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_shovel.id);\n      await bot.equip(shovelItem, \"hand\");\n      await bot.chat(\"\u2705 Iron shovel crafted and equipped.\");\n      return true;\n    } catch (e) {\n      await bot.chat(`\u274c Failed to craft shovel: ${e.message}`);\n      return false;\n    }\n  }\n\n  // ---------- 2. Ensure a crafting table block ----------\n  async function ensureCraftingTable() {\n    const tableId = mcData.blocksByName.crafting_table.id;\n    const nearby = bot.findBlock({\n      matching: tableId,\n      maxDistance: 5\n    });\n    if (nearby) {\n      await bot.chat(`\u2705 Crafting table already nearby at ${nearby.position}`);\n      return true;\n    }\n\n    // Need a crafting table item\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat(\"\u274c No crafting table item in inventory.\");\n      return false;\n    }\n\n    // Find an air block adjacent to the bot to place it\n    const candidates = [bot.entity.position.offset(1, 0, 0), bot.entity.position.offset(-1, 0, 0), bot.entity.position.offset(0, 0, 1), bot.entity.position.offset(0, 0, -1), bot.entity.position.offset(0, 1, 0)];\n    let placePos = null;\n    for (const pos of candidates) {\n      const blk = bot.blockAt(pos);\n      if (blk && blk.name === \"air\") {\n        placePos = pos;\n        break;\n      }\n    }\n    if (!placePos) {\n      await bot.chat(\"\u274c No suitable spot to place a crafting table.\");\n      return false;\n    }\n    await bot.chat(`\ud83d\udce6 Placing crafting table at ${placePos}`);\n    try {\n      await placeItem(bot, \"crafting_table\", placePos);\n      await bot.chat(\"\u2705 Crafting table placed.\");\n      return true;\n    } catch (e) {\n      await bot.chat(`\u274c Failed to place crafting table: ${e.message}`);\n      return false;\n    }\n  }\n\n  // ---------- 3. Locate gravel ----------\n  async function locateGravel() {\n    const gravelId = mcData.blocksByName.gravel.id;\n    let gravelBlock = bot.findBlock({\n      matching: gravelId,\n      maxDistance: 32\n    });\n    if (gravelBlock) return gravelBlock;\n\n    // Not found \u2013 explore randomly until we see one\n    await bot.chat(\"\ud83d\udd0e Exploring for gravel...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: gravelId,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    if (!found) {\n      await bot.chat(\"\u274c Could not find any gravel within the time limit.\");\n      return null;\n    }\n    return bot.findBlock({\n      matching: gravelId,\n      maxDistance: 32\n    });\n  }\n\n  // ---------- 4. Mine gravel ----------\n  async function mineGravel(targetCount) {\n    const gravelId = mcData.itemsByName.gravel.id;\n    let have = bot.inventory.count(gravelId);\n    while (have < targetCount) {\n      const need = targetCount - have;\n      await bot.chat(`\u26cf\ufe0f Mining ${need} gravel...`);\n      await mineBlock(bot, \"gravel\", need);\n      // small wait for inventory update\n      await bot.waitForTicks(10);\n      have = bot.inventory.count(gravelId);\n    }\n    await bot.chat(`\u2705 Finished mining. Gravel count: ${have}`);\n  }\n\n  // ---------- Helper: random direction ----------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // -------------------- Execution --------------------\n  // 1. Shovel\n  if (!(await ensureShovel())) return;\n\n  // 2. Find gravel block (move close to it)\n  const gravelBlock = await locateGravel();\n  if (!gravelBlock) return;\n\n  // Move next to the gravel so mining works reliably\n  await bot.pathfinder.goto(new GoalNear(gravelBlock.position.x, gravelBlock.position.y, gravelBlock.position.z, 1));\n\n  // 3. Mine until we have at least 10 gravel\n  await mineGravel(10);\n}", "description": "async function mineTenGravel(bot) {\n    // The routine first ensures the bot has a shovel, crafting an iron shovel if none are present, and places a crafting table if required; it then searches for a gravel block within a reasonable distance, exploring randomly until one is found; once a gravel block is located, the bot moves to a spot next to it; finally it repeatedly mines gravel until the inventory holds at least ten gravel items.\n}"}, "mineOneDiamondOreSafe": {"code": "// main function: mine exactly one diamond ore safely\nasync function mineOneDiamondOreSafe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // ---------- helpers ----------\n  // 1. Equip an iron (or better) pickaxe\n  async function ensurePickaxe() {\n    const order = [\"netherite_pickaxe\", \"diamond_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n    for (const name of order) {\n      const id = mcData.itemsByName[name].id;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) {\n        await bot.equip(item, \"hand\");\n        await bot.chat(`\u2705 Pickaxe equipped: ${name}`);\n        return true;\n      }\n    }\n    await bot.chat(\"\u274c No pickaxe (iron or better) found.\");\n    return false;\n  }\n\n  // 2. Ensure we have a weapon (sword preferred)\n  async function ensureWeapon() {\n    const swordId = mcData.itemsByName.iron_sword.id;\n    let weapon = bot.inventory.findInventoryItem(swordId);\n    if (weapon) {\n      await bot.equip(weapon, \"hand\");\n      await bot.chat(\"\u2705 Iron sword equipped.\");\n      return true;\n    }\n    const bowId = mcData.itemsByName.bow.id;\n    weapon = bot.inventory.findInventoryItem(bowId);\n    if (weapon) {\n      await bot.equip(weapon, \"hand\");\n      await bot.chat(\"\u2705 Bow equipped.\");\n      return true;\n    }\n    await bot.chat(\"\u274c No weapon (sword or bow) available.\");\n    return false;\n  }\n\n  // 3. Eat if needed\n  async function ensureFood() {\n    if (bot.food >= 12 && bot.health >= 14) return;\n    const foodItem = bot.inventory.items().find(i => i.food);\n    if (!foodItem) {\n      await bot.chat(\"\u26a0\ufe0f No food found, continuing without eating.\");\n      return;\n    }\n    await bot.equip(foodItem, \"hand\");\n    await bot.consume();\n    await bot.chat(\"\ud83c\udf57 Eating food.\");\n  }\n\n  // 4. Random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // 5. Try to kill a nearby creeper; if it fails, move away and retry\n  async function handleCreeper() {\n    const creeper = bot.nearestEntity(e => e.name === \"creeper\" && e.position.distanceTo(bot.entity.position) < 12);\n    if (!creeper) return true; // no threat\n\n    await bot.chat(\"\u2694\ufe0f Creeper spotted! Attempting to eliminate.\");\n    if (!(await ensureWeapon())) return false;\n\n    // Try up to 3 attempts; on failure move away and retry\n    for (let attempt = 1; attempt <= 3; attempt++) {\n      try {\n        await killMob(bot, \"creeper\", 30);\n        await bot.chat(\"\u2705 Creeper eliminated.\");\n        return true;\n      } catch (e) {\n        await bot.chat(`\u2757 Kill attempt ${attempt} failed: ${e.message}`);\n        // move a few blocks away in a random safe direction\n        const dir = randomDirection();\n        const safePos = bot.entity.position.plus(dir.scaled(5));\n        await bot.pathfinder.goto(new GoalNear(safePos.x, safePos.y, safePos.z, 1));\n        // give it a short pause before retrying\n        await bot.waitForTicks(10);\n      }\n    }\n    await bot.chat(\"\u274c Could not safely remove the creeper.\");\n    return false;\n  }\n\n  // 6. Locate a deepslate diamond ore block\n  async function findDiamondOre() {\n    const oreId = mcData.blocksByName.deepslate_diamond_ore.id;\n    let ore = bot.findBlock({\n      matching: oreId,\n      maxDistance: 32\n    });\n    if (ore) return ore;\n    await bot.chat(\"\ud83d\udd0e Exploring for deepslate diamond ore...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: oreId,\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    if (!found) return null;\n    return bot.findBlock({\n      matching: oreId,\n      maxDistance: 32\n    });\n  }\n\n  // ---------- execution ----------\n  // 1) Pickaxe\n  if (!(await ensurePickaxe())) return;\n\n  // 2) Food / health safety\n  await ensureFood();\n\n  // 3) Deal with creepers\n  if (!(await handleCreeper())) return;\n\n  // 4) Find the diamond ore\n  const diamondOre = await findDiamondOre();\n  if (!diamondOre) {\n    await bot.chat(\"\u274c No deepslate diamond ore found within the time limit.\");\n    return;\n  }\n  await bot.chat(`\u2705 Diamond ore located at ${diamondOre.position}`);\n\n  // 5) Move next to the ore\n  await bot.pathfinder.goto(new GoalNear(diamondOre.position.x, diamondOre.position.y, diamondOre.position.z, 1));\n\n  // 6) Mine exactly one ore\n  await bot.chat(\"\u26cf\ufe0f Mining the diamond ore...\");\n  await mineBlock(bot, \"deepslate_diamond_ore\", 1);\n\n  // 7) Verify we got a diamond\n  const diamondId = mcData.itemsByName.diamond.id;\n  const count = bot.inventory.count(diamondId);\n  if (count > 0) {\n    await bot.chat(`\u2705 Success! Collected ${count} diamond(s).`);\n  } else {\n    await bot.chat(\"\u274c Mining finished but no diamond was obtained.\");\n  }\n}", "description": "async function mineOneDiamondOreSafe(bot) {\n    // The routine safely obtains a single diamond by first equipping an iron\u2011or\u2011better pickaxe, ensuring sufficient food and health, and eliminating any nearby creeper threat; it then searches for a deepslate diamond ore within a limited range, navigates to the block, mines exactly one ore, and finally verifies that a diamond was added to the inventory.\n}"}, "mineOneDiamondOre": {"code": "// main function: mine exactly one diamond ore safely\nasync function mineOneDiamondOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // ---------- helpers ----------\n  // 1. Equip an iron (or better) pickaxe\n  async function ensurePickaxe() {\n    const order = [\"netherite_pickaxe\", \"diamond_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n    for (const name of order) {\n      const id = mcData.itemsByName[name].id;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) {\n        await bot.equip(item, \"hand\");\n        await bot.chat(`\u2705 Pickaxe equipped: ${name}`);\n        return true;\n      }\n    }\n    await bot.chat(\"\u274c No pickaxe (iron or better) found in inventory.\");\n    return false;\n  }\n\n  // 2. Ensure we have enough food and eat if needed\n  async function ensureFood() {\n    if (bot.food >= 12 && bot.health >= 14) return;\n    const foodItem = bot.inventory.items().find(i => i.food);\n    if (!foodItem) {\n      await bot.chat(\"\u26a0\ufe0f No food in inventory, proceeding without eating.\");\n      return;\n    }\n    await bot.equip(foodItem, \"hand\");\n    await bot.consume();\n    await bot.chat(\"\ud83c\udf57 Eating food to restore hunger.\");\n  }\n\n  // 3. Kill a nearby hostile mob (spider, zombie, creeper, etc.)\n  async function handleNearbyMobs() {\n    const hostile = bot.nearestEntity(e => {\n      return (e.type === \"mob\" || e.type === \"player\") && [\"spider\", \"zombie\", \"creeper\", \"skeleton\", \"enderman\"].includes(e.name) && e.position.distanceTo(bot.entity.position) < 12;\n    });\n    if (!hostile) return true; // no threat\n\n    // ensure we have a weapon\n    const sword = bot.inventory.findInventoryItem(mcData.itemsByName.iron_sword.id);\n    if (sword) await bot.equip(sword, \"hand\");else {\n      const bow = bot.inventory.findInventoryItem(mcData.itemsByName.bow.id);\n      if (bow) await bot.equip(bow, \"hand\");\n    }\n    await bot.chat(`\u2694\ufe0f Engaging hostile ${hostile.name}`);\n    try {\n      await killMob(bot, hostile.name, 30);\n      await bot.chat(`\u2705 ${hostile.name} eliminated.`);\n      return true;\n    } catch (e) {\n      await bot.chat(`\u2757 Failed to kill ${hostile.name}: ${e.message}`);\n      return false;\n    }\n  }\n\n  // 4. Random direction vector (components -1,0,1, not all zero)\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // 5. Find a diamond ore block (regular or deepslate)\n  async function locateDiamondOre() {\n    const oreIds = [mcData.blocksByName.diamond_ore.id, mcData.blocksByName.deepslate_diamond_ore.id];\n    // quick search\n    let oreBlock = bot.findBlock({\n      matching: b => oreIds.includes(b.type),\n      maxDistance: 32\n    });\n    if (oreBlock) return oreBlock;\n\n    // explore until found\n    await bot.chat(\"\ud83d\udd0e Exploring for diamond ore...\");\n    const found = await exploreUntil(bot, randomDirection(), 60, () => {\n      const blk = bot.findBlock({\n        matching: b => oreIds.includes(b.type),\n        maxDistance: 32\n      });\n      return blk ? blk : null;\n    });\n    if (!found) return null;\n    // after exploration, locate again\n    return bot.findBlock({\n      matching: b => oreIds.includes(b.type),\n      maxDistance: 32\n    });\n  }\n\n  // ---------- execution ----------\n  // 1) Pickaxe\n  if (!(await ensurePickaxe())) return;\n\n  // 2) Food / health safety\n  await ensureFood();\n\n  // 3) Deal with nearby hostile mobs\n  if (!(await handleNearbyMobs())) return;\n\n  // 4) Locate the diamond ore\n  const oreBlock = await locateDiamondOre();\n  if (!oreBlock) {\n    await bot.chat(\"\u274c Could not find any diamond ore within the time limit.\");\n    return;\n  }\n  await bot.chat(`\u2705 Diamond ore located at ${oreBlock.position}`);\n\n  // 5) Move next to the ore\n  await bot.pathfinder.goto(new GoalNear(oreBlock.position.x, oreBlock.position.y, oreBlock.position.z, 1));\n\n  // 6) Mine exactly one ore (use the correct block name)\n  const oreName = oreBlock.name; // \"diamond_ore\" or \"deepslate_diamond_ore\"\n  await bot.chat(`\u26cf\ufe0f Mining ${oreName}...`);\n  await mineBlock(bot, oreName, 1);\n\n  // 7) Verify we obtained a diamond\n  const diamondId = mcData.itemsByName.diamond.id;\n  const count = bot.inventory.count(diamondId);\n  if (count > 0) {\n    await bot.chat(`\u2705 Success! Collected ${count} diamond(s).`);\n  } else {\n    await bot.chat(\"\u274c Mining finished but no diamond was obtained.\");\n  }\n}", "description": "async function mineOneDiamondOre(bot) {\n    // The routine first equips an iron\u2011or\u2011better pickaxe, ensures sufficient food and health, and eliminates any nearby hostile mob; it then searches for a diamond ore block (including deepslate), exploring randomly if needed, and moves the bot adjacent to the located ore; after positioning, it mines exactly one diamond ore block; finally it checks the inventory for diamonds and confirms success if any are obtained.\n}"}, "mineFiveCoal": {"code": "// main function to mine at least 5 coal ore and end up with 5 coal items\nasync function mineFiveCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // ---------- helper: pick the best pickaxe and equip it ----------\n  async function ensurePickaxe() {\n    const order = [\"netherite_pickaxe\", \"diamond_pickaxe\", \"iron_pickaxe\", \"stone_pickaxe\", \"golden_pickaxe\", \"wooden_pickaxe\"];\n    for (const name of order) {\n      const id = mcData.itemsByName[name].id;\n      const item = bot.inventory.findInventoryItem(id);\n      if (item) {\n        await bot.equip(item, \"hand\");\n        await bot.chat(`\u2705 Equipped ${name}.`);\n        return true;\n      }\n    }\n    await bot.chat(\"\u274c No pickaxe (iron or better) found in inventory.\");\n    return false;\n  }\n\n  // ---------- helper: random direction vector (components -1,0,1, not all zero) ----------\n  function randomDirection() {\n    const choices = [-1, 0, 1];\n    let vec;\n    do {\n      vec = new Vec3(choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)], choices[Math.floor(Math.random() * 3)]);\n    } while (vec.x === 0 && vec.y === 0 && vec.z === 0);\n    return vec;\n  }\n\n  // ---------- start of main logic ----------\n  // 1\ufe0f\u20e3 Equip a pickaxe\n  if (!(await ensurePickaxe())) return;\n\n  // 2\ufe0f\u20e3 Helper to count coal in inventory\n  const coalId = mcData.itemsByName.coal.id;\n  function coalCount() {\n    return bot.inventory.count(coalId);\n  }\n\n  // 3\ufe0f\u20e3 If we already have enough coal, we're done\n  if (coalCount() >= 5) {\n    await bot.chat(`\u2705 Already have ${coalCount()} coal. Task completed.`);\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Loop until we have at least 5 coal\n  for (let attempt = 0; attempt < 5; attempt++) {\n    const have = coalCount();\n    if (have >= 5) break; // success\n\n    const need = 5 - have;\n    await bot.chat(`\ud83d\udd0e Need ${need} more coal (currently ${have}). Searching for coal ore...`);\n\n    // Try to find coal ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName.coal_ore.id,\n      maxDistance: 32\n    });\n\n    // If not found, explore\n    if (!oreBlock) {\n      await bot.chat(\"\ud83d\udeb6\u200d\u2642\ufe0f Exploring for coal ore...\");\n      const found = await exploreUntil(bot, randomDirection(), 60, () => {\n        const blk = bot.findBlock({\n          matching: mcData.blocksByName.coal_ore.id,\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      if (!found) {\n        await bot.chat(\"\u274c Exploration timed out \u2013 no coal ore found.\");\n        break;\n      }\n      oreBlock = bot.findBlock({\n        matching: mcData.blocksByName.coal_ore.id,\n        maxDistance: 32\n      });\n    }\n    if (!oreBlock) {\n      await bot.chat(\"\u274c Still couldn't locate coal ore. Stopping.\");\n      break;\n    }\n    await bot.chat(`\u2705 Coal ore located at ${oreBlock.position}. Mining ${need} block(s)...`);\n    // Mine the required amount (mineBlock will stop early if not enough blocks are found)\n    await mineBlock(bot, \"coal_ore\", need);\n\n    // Small pause to let inventory update\n    await bot.waitForTicks(10);\n  }\n\n  // 5\ufe0f\u20e3 Final report\n  const finalCount = coalCount();\n  if (finalCount >= 5) {\n    await bot.chat(`\u2705 Success! I now have ${finalCount} coal.`);\n  } else {\n    await bot.chat(`\u26a0\ufe0f Task finished but only have ${finalCount} coal.`);\n  }\n}", "description": "async function mineFiveCoal(bot) {\n    // The routine first equips the best available pickaxe, then checks if the inventory already contains five coal items; if not, it repeatedly searches for coal ore within a 32\u2011block radius, exploring in random directions when none is found, mines the needed number of ore blocks, and repeats until at least five coal are collected, finally reporting whether the goal was achieved.\n}"}}