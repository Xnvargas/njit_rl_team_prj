{"mineOneWoodLog": {"code": "// main function\nasync function mineOneWoodLog(bot) {\n  // announce start\n  await bot.chat(\"Starting to mine a wood log...\");\n\n  // helper: try to mine a specific log type, returns true if we now have it\n  async function tryMineLog(logName) {\n    // attempt to collect one block of this log type\n    await mineBlock(bot, logName, 1);\n    // check inventory for the log we just tried to mine\n    const item = mcData.itemsByName[logName];\n    const found = bot.inventory.findInventoryItem(item.id);\n    return !!found;\n  }\n\n  // list of log names we are allowed to mine\n  const logNames = [\"oak_log\", \"jungle_log\", \"birch_log\", \"spruce_log\", \"acacia_log\", \"dark_oak_log\", \"mangrove_log\"];\n\n  // try each log type until we succeed\n  for (const name of logNames) {\n    const success = await tryMineLog(name);\n    if (success) {\n      await bot.chat(`Mined one ${name.replace('_log', '')} log!`);\n      return;\n    }\n  }\n\n  // If we reach here, none of the nearby logs were found.\n  // Wander randomly until a log appears, then mine it.\n  await bot.chat(\"Couldn't find a log nearby, exploring...\");\n\n  // random direction vectors limited to -1,0,1 for each axis\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  const randomDir = directions[Math.floor(Math.random() * directions.length)];\n\n  // explore until we find any log block\n  const foundBlock = await exploreUntil(bot, randomDir, 60, () => {\n    for (const name of logNames) {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName[name].id,\n        maxDistance: 32\n      });\n      if (block) return block;\n    }\n    return null;\n  });\n  if (foundBlock) {\n    // Determine which log we found and mine it\n    const logName = Object.keys(mcData.blocksByName).find(key => mcData.blocksByName[key].id === foundBlock.type);\n    await mineBlock(bot, logName, 1);\n    await bot.chat(`Mined one ${logName.replace('_log', '')} log after exploring!`);\n  } else {\n    await bot.chat(\"Failed to find any log within the exploration time.\");\n  }\n}", "description": "async function mineOneWoodLog(bot) {\n    // The routine attempts to obtain a single wood log by sequentially trying each allowed log type and verifying the inventory after each mining attempt; if none are found nearby, it selects a random horizontal direction and explores for up to a minute, continuously searching for any log block within range, and upon locating one it mines exactly one log of the discovered type.\n}"}, "obtainFourOakLogs": {"code": "// main function to obtain 4 oak logs\nasync function obtainFourOakLogs(bot) {\n  // announce start\n  await bot.chat(\"Task: obtain 4 oak logs.\");\n\n  // helper to count oak logs in inventory\n  const countOakLogs = () => {\n    const item = mcData.itemsByName[\"oak_log\"];\n    const invItem = bot.inventory.findInventoryItem(item.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // possible direction vectors (each component is -1, 0, or 1)\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n  // keep mining until we have 4 logs or we give up\n  while (countOakLogs() < 4) {\n    // try to find a log nearby\n    let logBlock = bot.findBlock({\n      matching: mcData.blocksByName[\"oak_log\"].id,\n      maxDistance: 32\n    });\n\n    // if not found, explore randomly until we locate one\n    if (!logBlock) {\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat(\"Searching for oak logs...\");\n      logBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName[\"oak_log\"].id,\n          maxDistance: 32\n        });\n      });\n      if (!logBlock) {\n        await bot.chat(\"Couldn't find any oak logs after exploring.\");\n        break; // exit the loop; task failed\n      }\n    }\n\n    // mine one oak log\n    await bot.chat(\"Mining an oak log...\");\n    await mineBlock(bot, \"oak_log\", 1);\n\n    // small pause to let the inventory update\n    await bot.waitForTicks(5);\n  }\n\n  // final check\n  if (countOakLogs() >= 4) {\n    await bot.chat(\"Success! I now have at least 4 oak logs.\");\n  } else {\n    await bot.chat(`Task incomplete: only ${countOakLogs()} oak log(s) in inventory.`);\n  }\n}", "description": "async function obtainFourOakLogs(bot) {\n    // The routine searches the surroundings for oak log blocks, explores random directions when none are initially found, mines individual oak logs repeatedly until the inventory contains at least four, includes brief pauses to allow inventory updates, and finally verifies whether the target quantity was achieved, reporting success or the shortfall.\n}"}, "craftFourSticks": {"code": "// main function to ensure the bot has at least 4 sticks\nasync function craftFourSticks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // helper: count items in inventory\n  const countItem = name => {\n    const item = mcData.itemsByName[name];\n    const inv = bot.inventory.findInventoryItem(item.id);\n    return inv ? inv.count : 0;\n  };\n\n  // 1. Make sure we have enough planks (need at least 2)\n  const neededPlanks = 2;\n  let plankCount = countItem('oak_planks');\n  if (plankCount < neededPlanks) {\n    // we need more planks \u2192 craft from oak logs\n    const logsNeeded = Math.ceil((neededPlanks - plankCount) / 4);\n    const logCount = countItem('oak_log');\n    if (logCount < logsNeeded) {\n      await bot.chat(`I don't have enough oak logs to make planks (need ${logsNeeded}, have ${logCount}).`);\n      return;\n    }\n\n    // craft the planks using the 2\u00d72 inventory grid\n    await bot.chat(`Crafting ${logsNeeded * 4} oak planks from ${logsNeeded} oak logs...`);\n    const plankItem = mcData.itemsByName['oak_planks'];\n    const logItem = mcData.itemsByName['oak_log'];\n\n    // ensure the logs are in the hotbar (required for bot.craft)\n    const logInv = bot.inventory.findInventoryItem(logItem.id);\n    await bot.equip(logInv, 'hand');\n\n    // recipe: 1 oak log \u2192 4 oak planks (no table needed)\n    await bot.craft(bot.recipesFor(plankItem.id, null, 1, null)[0], logsNeeded, null);\n    plankCount = countItem('oak_planks');\n    await bot.chat(`Now have ${plankCount} oak planks.`);\n  }\n\n  // 2. Make sure we have at least 4 sticks\n  const neededSticks = 4;\n  let stickCount = countItem('stick');\n  if (stickCount < neededSticks) {\n    // each craft gives 4 sticks from 2 planks\n    const craftsNeeded = Math.ceil((neededSticks - stickCount) / 4);\n    const planksNeeded = craftsNeeded * 2;\n    if (plankCount < planksNeeded) {\n      await bot.chat(`Not enough planks to craft sticks (need ${planksNeeded}, have ${plankCount}).`);\n      return;\n    }\n    await bot.chat(`Crafting ${craftsNeeded * 4} sticks from ${planksNeeded} planks...`);\n    const stickItem = mcData.itemsByName['stick'];\n    const plankItem = mcData.itemsByName['oak_planks'];\n\n    // ensure planks are in the hotbar\n    const plankInv = bot.inventory.findInventoryItem(plankItem.id);\n    await bot.equip(plankInv, 'hand');\n\n    // recipe: 2 planks \u2192 4 sticks (no table needed)\n    await bot.craft(bot.recipesFor(stickItem.id, null, 1, null)[0], craftsNeeded, null);\n    stickCount = countItem('stick');\n    await bot.chat(`Now have ${stickCount} sticks.`);\n  }\n\n  // final report\n  if (stickCount >= neededSticks) {\n    await bot.chat('\u2705 Successfully crafted at least 4 sticks!');\n  } else {\n    await bot.chat(`\u274c Failed to craft enough sticks. I have ${stickCount}.`);\n  }\n}", "description": "async function craftFourSticks(bot) {\n    // The routine checks the inventory for oak planks and logs, crafts missing planks from logs, then crafts sticks from planks until at least four sticks are present, and finally verifies if the stick count meets the requirement.\n}"}, "ensureOneOakPlank": {"code": "// Main function to ensure the bot has at least one oak plank\nasync function ensureOneOakPlank(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // Helper: count items of a given name in inventory\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // 1. Check if we already have oak planks\n  if (countItem('oak_planks') >= 1) {\n    await bot.chat('\u2705 I already have oak planks in my inventory.');\n    return;\n  }\n\n  // 2. Need to obtain a plank \u2013 first make sure we have an oak log\n  if (countItem('oak_log') < 1) {\n    // Try to find a log nearby\n    let logBlock = bot.findBlock({\n      matching: mcData.blocksByName['oak_log'].id,\n      maxDistance: 32\n    });\n\n    // If not found, explore randomly until we locate one\n    if (!logBlock) {\n      const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat('Searching for an oak log...');\n      logBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName['oak_log'].id,\n          maxDistance: 32\n        });\n      });\n    }\n    if (!logBlock) {\n      await bot.chat('\u274c Could not find any oak log to craft planks.');\n      return;\n    }\n\n    // Mine one oak log\n    await bot.chat('Mining an oak log...');\n    await mineBlock(bot, 'oak_log', 1);\n    await bot.waitForTicks(5); // let inventory update\n  }\n\n  // 3. Ensure we have a crafting table\n  if (countItem('crafting_table') < 1) {\n    // Try to craft a crafting table from planks (needs a table, so we skip if impossible)\n    await bot.chat('\u274c No crafting table in inventory and cannot craft one without a table.');\n    return;\n  }\n\n  // 4. Place the crafting table near the bot (if not already placed)\n  const tablePos = bot.entity.position.offset(1, 0, 0);\n  await placeItem(bot, 'crafting_table', tablePos);\n\n  // 5. Craft one oak plank (the recipe yields 4 planks, but we request 1)\n  await bot.chat('Crafting oak planks...');\n  await craftItem(bot, 'oak_planks', 1);\n\n  // 6. Final check\n  if (countItem('oak_planks') >= 1) {\n    await bot.chat('\u2705 Successfully crafted at least one oak plank.');\n  } else {\n    await bot.chat('\u274c Failed to craft oak planks.');\n  }\n}", "description": "async function ensureOneOakPlank(bot) {\n    // The routine guarantees the bot possesses at least one oak plank; it first checks the inventory for existing planks, then ensures an oak log is available by searching nearby or exploring until one is found and mining it if necessary, verifies a crafting table is present and places one nearby if needed, crafts oak planks using the table, and finally confirms that the inventory now contains at least one oak plank.\n}"}, "craftFourOakPlanks": {"code": "// ------------------------------------------------------------------\n// Helper: count how many items of a given name the bot has\nfunction countItem(bot, name) {\n  const mcData = require('minecraft-data')(bot.version);\n  const itemInfo = mcData.itemsByName[name];\n  if (!itemInfo) return 0;\n  const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n  return invItem ? invItem.count : 0;\n}\n\n// Helper: make sure we have at least one oak log\n\n// Helper: make sure we have at least one oak log\nasync function ensureOakLog(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  if (countItem(bot, 'oak_log') >= 1) return true;\n\n  // try to find a log nearby\n  let logBlock = bot.findBlock({\n    matching: mcData.blocksByName['oak_log'].id,\n    maxDistance: 32\n  });\n\n  // if not found, explore randomly until we locate one\n  if (!logBlock) {\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    await bot.chat('Looking for an oak log...');\n    logBlock = await exploreUntil(bot, randomDir, 60, () => {\n      return bot.findBlock({\n        matching: mcData.blocksByName['oak_log'].id,\n        maxDistance: 32\n      });\n    });\n  }\n  if (!logBlock) {\n    await bot.chat('\u274c Could not find any oak log.');\n    return false;\n  }\n\n  // mine one oak log\n  await bot.chat('Mining an oak log...');\n  await mineBlock(bot, 'oak_log', 1);\n  await bot.waitForTicks(5); // let inventory update\n  return countItem(bot, 'oak_log') >= 1;\n}\n\n// Helper: ensure a crafting table is reachable (placed or in inventory)\n\n// Helper: ensure a crafting table is reachable (placed or in inventory)\nasync function ensureCraftingTable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // 1) Look for a placed crafting table nearby\n  const tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (tableBlock) return true; // already have one\n\n  // 2) Do we have a crafting table item in inventory?\n  const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n  if (!tableItem) {\n    await bot.chat('\u274c No crafting table item and none placed.');\n    return false;\n  }\n\n  // 3) Place it next to the bot\n  const placePos = bot.entity.position.offset(1, 0, 0);\n  await bot.chat('Placing a crafting table...');\n  await placeItem(bot, 'crafting_table', placePos);\n  // give a tiny pause for the block to appear\n  await bot.waitForTicks(5);\n  return true;\n}\n\n// ------------------------------------------------------------------\n// Main function: craft at least four oak planks\n\n// ------------------------------------------------------------------\n// Main function: craft at least four oak planks\nasync function craftFourOakPlanks(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  await bot.chat('\ud83e\udeb5 Starting task: craft 4 oak planks.');\n\n  // 1) Quick win: already have enough planks?\n  if (countItem(bot, 'oak_planks') >= 4) {\n    await bot.chat('\u2705 Already have 4+ oak planks.');\n    return;\n  }\n\n  // 2) Ensure we have at least one oak log to turn into planks\n  const haveLog = await ensureOakLog(bot);\n  if (!haveLog) {\n    await bot.chat('\u274c Cannot continue without an oak log.');\n    return;\n  }\n\n  // 3) Try to use the helper craftItem (needs a crafting table)\n  const tableReady = await ensureCraftingTable(bot);\n  if (tableReady) {\n    // Use the provided helper \u2013 it will place us near the table and craft\n    await bot.chat('Crafting oak planks using the crafting table...');\n    await craftItem(bot, 'oak_planks', 1); // 1 recipe = 4 planks\n  } else {\n    // 4) Fallback: use the 2\u00d72 inventory grid directly\n    await bot.chat('No crafting table available \u2013 using inventory grid.');\n    const plankItem = mcData.itemsByName['oak_planks'];\n    const logItem = mcData.itemsByName['oak_log'];\n    // Ensure the log is in the hotbar (required for bot.craft)\n    const logInv = bot.inventory.findInventoryItem(logItem.id);\n    if (logInv) await bot.equip(logInv, 'hand');\n    const recipe = bot.recipesFor(plankItem.id, null, 1, null)[0];\n    if (!recipe) {\n      await bot.chat('\u274c No recipe found for oak planks.');\n      return;\n    }\n    await bot.craft(recipe, 1, null); // one craft = 4 planks\n  }\n\n  // 5) Final verification\n  if (countItem(bot, 'oak_planks') >= 4) {\n    await bot.chat('\u2705 Success! I now have at least 4 oak planks.');\n  } else {\n    await bot.chat(`\u274c Task failed \u2013 only ${countItem(bot, 'oak_planks')} planks present.`);\n  }\n}", "description": "async function craftFourOakPlanks(bot) {\n    // The routine ensures the bot ends up with at least four oak planks by first checking the inventory, then guaranteeing an oak log is available, confirming a crafting table is reachable, using it to craft planks if possible, otherwise crafting directly from the inventory grid, and finally verifying the plank count.\n}"}, "craftWoodenPickaxe": {"code": "// main function: craft one wooden pickaxe using a crafting table\nasync function craftWoodenPickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const inv = bot.inventory.findInventoryItem(info.id);\n    return inv ? inv.count : 0;\n  };\n\n  // Find a solid block (not air, not leaves) within 32 blocks\n  const findSolidBlock = () => {\n    return bot.findBlock({\n      matching: block => {\n        if (!block) return false;\n        // ignore air and leaves\n        if (block.name === 'air') return false;\n        if (block.name.includes('leaves')) return false;\n        // solid blocks have a boundingBox of \"block\"\n        return block.boundingBox === 'block';\n      },\n      maxDistance: 32\n    });\n  };\n\n  // ---------- 1. ensure a crafting table is placed ----------\n  // we already have a crafting_table item in inventory (see critique)\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('Placing a crafting table...');\n    // find a solid reference block\n    const refBlock = findSolidBlock();\n    if (!refBlock) {\n      await bot.chat('\u274c No suitable block found to place the crafting table.');\n      return;\n    }\n    // choose an adjacent air position (simple +1 on X)\n    const placePos = refBlock.position.offset(1, 0, 0);\n    // make sure the target position is air\n    const targetBlock = bot.blockAt(placePos);\n    if (targetBlock && targetBlock.name !== 'air') {\n      // try a different offset if occupied\n      const alternatives = [new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      let placed = false;\n      for (const off of alternatives) {\n        const pos = refBlock.position.offset(off.x, off.y, off.z);\n        const blk = bot.blockAt(pos);\n        if (blk && blk.name === 'air') {\n          await placeItem(bot, 'crafting_table', pos);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) {\n        await bot.chat('\u274c Could not find a free spot next to the reference block.');\n        return;\n      }\n    } else {\n      await placeItem(bot, 'crafting_table', placePos);\n    }\n    await bot.waitForTicks(5); // let the block appear\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // ---------- 2. ensure we have at least 3 oak planks ----------\n  const neededPlanks = 3;\n  if (countItem('oak_planks') < neededPlanks) {\n    const missingPlanks = neededPlanks - countItem('oak_planks');\n    const logsNeeded = Math.ceil(missingPlanks / 4);\n    await bot.chat(`Mining ${logsNeeded} oak log(s) to obtain planks...`);\n    await mineBlock(bot, 'oak_log', logsNeeded);\n    await bot.waitForTicks(5);\n\n    // craft the missing planks (requires the table we just placed)\n    const planksToCraft = Math.ceil(missingPlanks / 4);\n    await bot.chat(`Crafting ${planksToCraft * 4} oak planks...`);\n    await craftItem(bot, 'oak_planks', planksToCraft);\n    await bot.waitForTicks(5);\n  }\n\n  // ---------- 3. ensure we have at least 2 sticks ----------\n  const neededSticks = 2;\n  if (countItem('stick') < neededSticks) {\n    await bot.chat('Crafting sticks...');\n    // one recipe gives 4 sticks\n    await craftItem(bot, 'stick', 1);\n    await bot.waitForTicks(5);\n  }\n\n  // ---------- 4. craft the wooden pickaxe ----------\n  await bot.chat('Crafting a wooden pickaxe...');\n  await craftItem(bot, 'wooden_pickaxe', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 5. final verification ----------\n  if (countItem('wooden_pickaxe') >= 1) {\n    await bot.chat('\u2705 Successfully crafted a wooden pickaxe!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 wooden pickaxe not found in inventory.');\n  }\n}", "description": "async function craftWoodenPickaxe(bot) {\n    // The function first makes sure a crafting table is placed nearby, positioning it next to a solid block if none is found; it then checks that the inventory contains at least three oak planks, mining logs and crafting additional planks when needed; next it ensures there are at least two sticks, crafting them if missing; with the required materials available it crafts a wooden pickaxe; finally it verifies that the wooden pickaxe was successfully added to the inventory.\n}"}, "mineThreeCobblestoneReliable": {"code": "// main function: mine at least three cobblestone reliably\nasync function mineThreeCobblestoneReliable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const Vec3 = require('vec3').Vec3;\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n  const hasPickaxe = () => {\n    return bot.inventory.items().some(item => {\n      const name = mcData.items[item.type]?.name;\n      return name && name.endsWith('_pickaxe');\n    });\n  };\n  const equipPickaxe = async () => {\n    const pick = bot.inventory.items().find(item => {\n      const name = mcData.items[item.type]?.name;\n      return name && name.endsWith('_pickaxe');\n    });\n    if (pick) await bot.equip(pick, 'hand');\n  };\n  const ensurePickaxe = async () => {\n    if (hasPickaxe()) {\n      await equipPickaxe();\n      return true;\n    }\n    await bot.chat('\ud83d\udd28 I need a pickaxe. Crafting a wooden pickaxe...');\n    // --- ensure planks ---\n    if (countItem('oak_planks') < 3) {\n      if (countItem('oak_log') > 0) {\n        const needed = Math.ceil((3 - countItem('oak_planks')) / 4);\n        await bot.chat(`Crafting ${needed * 4} oak planks...`);\n        await craftItem(bot, 'oak_planks', needed);\n      } else {\n        await bot.chat('\u274c No oak logs to make planks.');\n        return false;\n      }\n    }\n    // --- ensure sticks ---\n    if (countItem('stick') < 2) {\n      const needed = Math.ceil((2 - countItem('stick')) / 4);\n      await bot.chat(`Crafting ${needed * 4} sticks...`);\n      await craftItem(bot, 'stick', needed);\n    }\n    // --- ensure crafting table ---\n    let tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n      if (!tableItem) {\n        await bot.chat('\u274c No crafting table item available.');\n        return false;\n      }\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      await bot.chat('Placing a crafting table...');\n      await placeItem(bot, 'crafting_table', placePos);\n      await bot.waitForTicks(5);\n    }\n    // --- craft pickaxe ---\n    await bot.chat('Crafting a wooden pickaxe...');\n    await craftItem(bot, 'wooden_pickaxe', 1);\n    await bot.waitForTicks(5);\n    await equipPickaxe();\n    return true;\n  };\n  const randomDirection = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n  // --------------------------------\n\n  // 1) Already have enough cobblestone?\n  if (countItem('cobblestone') >= 3) {\n    await bot.chat('\u2705 I already have at least 3 cobblestone.');\n    return;\n  }\n\n  // 2) Ensure we have a pickaxe equipped\n  const canPick = await ensurePickaxe();\n  if (!canPick) {\n    await bot.chat('\u274c Cannot obtain a pickaxe, aborting task.');\n    return;\n  }\n\n  // 3) Mine stone until we have 3 cobblestone\n  let attempts = 0;\n  const maxAttempts = 10; // safety limit\n  while (countItem('cobblestone') < 3 && attempts < maxAttempts) {\n    attempts++;\n\n    // find a stone block\n    let stoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32\n    });\n\n    // if none, explore\n    if (!stoneBlock) {\n      const dir = randomDirection();\n      await bot.chat('\ud83d\udd0e Exploring for stone...');\n      stoneBlock = await exploreUntil(bot, dir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.stone.id,\n          maxDistance: 32\n        });\n      });\n      if (!stoneBlock) {\n        await bot.chat('\u274c Could not locate any stone this round.');\n        continue; // try next attempt\n      }\n    }\n\n    // mine ONE stone block\n    await bot.chat('\u26cf\ufe0f Mining a stone block...');\n    await mineBlock(bot, 'stone', 1);\n    await bot.waitForTicks(5); // let the drop be collected\n\n    // re\u2011count cobblestone\n    const cur = countItem('cobblestone');\n    await bot.chat(`\ud83d\udce6 I now have ${cur} cobblestone.`);\n  }\n\n  // 4) Final verification\n  const finalCount = countItem('cobblestone');\n  if (finalCount >= 3) {\n    await bot.chat(`\u2705 Success! I now have ${finalCount} cobblestone.`);\n  } else {\n    await bot.chat(`\u274c Task incomplete. Only ${finalCount} cobblestone collected.`);\n  }\n}", "description": "async function mineThreeCobblestoneReliable(bot) {\n    // The routine first checks if the inventory already holds at least three cobblestone, then ensures a pickaxe is equipped by crafting planks, sticks, a crafting table, and a wooden pickaxe when needed; it repeatedly searches for stone blocks, explores in random directions if none are nearby, mines one stone block per attempt while updating the cobblestone count until three are obtained or a safety limit of attempts is reached, and finally verifies the final count to determine whether the task succeeded.\n}"}, "craftStonePickaxe": {"code": "// main function to craft a stone pickaxe\nasync function craftStonePickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory by name\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // 1) Already have a stone pickaxe?\n  if (countItem('stone_pickaxe') >= 1) {\n    await bot.chat('\u2705 I already have a stone pickaxe.');\n    return;\n  }\n\n  // 2) Ensure we have the raw materials (cobblestone & sticks)\n  if (countItem('cobblestone') < 3) {\n    await bot.chat('\u274c Not enough cobblestone (need 3).');\n    return;\n  }\n  if (countItem('stick') < 2) {\n    await bot.chat('\u274c Not enough sticks (need 2).');\n    return;\n  }\n\n  // 3) Ensure a crafting table is placed\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // we have a crafting table item?\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n\n    // Try vertical placement: on top of the block we stand on\n    const belowPos = bot.entity.position.offset(0, -1, 0);\n    const belowBlock = bot.blockAt(belowPos);\n    const targetPos = bot.entity.position; // same X,Z, Y = bot's feet (air)\n\n    if (belowBlock && belowBlock.name !== 'air' && bot.blockAt(targetPos).name === 'air') {\n      await bot.chat('Placing crafting table on top of the block I stand on...');\n      await placeItem(bot, 'crafting_table', targetPos);\n    } else {\n      // fallback: search a horizontal free spot\n      const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n      let placed = false;\n      for (const dir of directions) {\n        const ref = bot.findBlock({\n          matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n          maxDistance: 32\n        });\n        if (!ref) continue;\n        const pos = ref.position.offset(dir.x, dir.y, dir.z);\n        if (bot.blockAt(pos).name === 'air') {\n          await bot.chat('Placing crafting table at a nearby free spot...');\n          await placeItem(bot, 'crafting_table', pos);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) {\n        await bot.chat('\u274c Could not find any free spot to place the crafting table.');\n        return;\n      }\n    }\n\n    // give the world a tick to register the block\n    await bot.waitForTicks(5);\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // 4) Craft the stone pickaxe\n  await bot.chat('Crafting a stone pickaxe...');\n  await craftItem(bot, 'stone_pickaxe', 1);\n  await bot.waitForTicks(5);\n\n  // 5) Verify result\n  if (countItem('stone_pickaxe') >= 1) {\n    await bot.chat('\u2705 Successfully crafted a stone pickaxe!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 stone pickaxe not found in inventory.');\n  }\n}", "description": "async function craftStonePickaxe(bot) {\n    // The routine first checks if a stone pickaxe is already in the inventory; if not, it ensures at least three cobblestone and two sticks are present, then looks for a nearby crafting table (placing one if necessary), crafts a stone pickaxe, and finally verifies that the new pickaxe appears in the inventory.\n}"}, "mineEightCobblestone": {"code": "// main function to mine at least 8 cobblestone\nasync function mineEightCobblestone(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // ----- 1. Check current cobblestone -----\n  const targetAmount = 8;\n  let have = countItem('cobblestone');\n  if (have >= targetAmount) {\n    await bot.chat(`\u2705 I already have ${have} cobblestone.`);\n    return;\n  }\n  await bot.chat(`\ud83d\udd0e I need ${targetAmount - have} more cobblestone.`);\n\n  // ----- 2. Ensure we have a pickaxe (any) -----\n  const hasPickaxe = countItem('wooden_pickaxe') || countItem('stone_pickaxe') || countItem('iron_pickaxe') || countItem('golden_pickaxe') || countItem('diamond_pickaxe') || countItem('netherite_pickaxe');\n  if (!hasPickaxe) {\n    await bot.chat('\u274c I have no pickaxe to mine stone.');\n    return;\n  }\n\n  // ----- 3. Mining loop -----\n  while (have < targetAmount) {\n    const needed = targetAmount - have;\n\n    // try to find stone nearby\n    let stoneBlock = bot.findBlock({\n      matching: mcData.blocksByName.stone.id,\n      maxDistance: 32\n    });\n\n    // if not found, explore in a random direction\n    if (!stoneBlock) {\n      const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f Exploring for stone...');\n      stoneBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.stone.id,\n          maxDistance: 32\n        });\n      });\n      if (!stoneBlock) {\n        await bot.chat('\u274c Could not find any stone after exploring.');\n        return;\n      }\n    }\n\n    // mine the required amount (or as many as we can find)\n    const toMine = Math.min(needed, 8); // mine up to 8 at once; mineBlock will collect up to this count\n    await bot.chat(`\u26cf\ufe0f Mining ${toMine} stone block(s)...`);\n    await mineBlock(bot, 'stone', toMine);\n    // small pause to let inventory update\n    await bot.waitForTicks(5);\n    have = countItem('cobblestone');\n  }\n\n  // ----- 4. Final report -----\n  await bot.chat(`\u2705 Successfully collected ${have} cobblestone!`);\n}", "description": "async function mineEightCobblestone(bot) {\n    // The function ensures the bot acquires at least eight cobblestone by checking the current cobblestone count, confirming a pickaxe is available, locating stone blocks nearby (or exploring in random directions until stone is found), mining the needed amount in batches while updating the inventory count, and finally confirming the target quantity has been collected.\n}"}, "mineFiveCoal": {"code": "async function mineFiveCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // helper: count items of a given name in inventory\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // 1. Check existing coal\n  let coalCount = countItem('coal');\n  if (coalCount >= 5) {\n    await bot.chat('\u2705 I already have at least 5 coal.');\n    return;\n  }\n\n  // 2. Ensure we have a pickaxe that can mine coal (stone or better)\n  const hasPickaxe = countItem('stone_pickaxe') || countItem('iron_pickaxe') || countItem('golden_pickaxe') || countItem('diamond_pickaxe') || countItem('netherite_pickaxe');\n  if (!hasPickaxe) {\n    await bot.chat('\u274c I have no pickaxe capable of mining coal.');\n    return;\n  }\n\n  // 3. Equip a stone pickaxe (or any better one we have)\n  const pickaxeItem = bot.inventory.findInventoryItem(mcData.itemsByName.stone_pickaxe.id) || bot.inventory.findInventoryItem(mcData.itemsByName.iron_pickaxe.id) || bot.inventory.findInventoryItem(mcData.itemsByName.golden_pickaxe.id) || bot.inventory.findInventoryItem(mcData.itemsByName.diamond_pickaxe.id) || bot.inventory.findInventoryItem(mcData.itemsByName.netherite_pickaxe.id);\n  if (!pickaxeItem) {\n    await bot.chat('\u274c Unexpectedly could not locate a pickaxe in inventory.');\n    return;\n  }\n  await bot.equip(pickaxeItem, 'hand');\n\n  // possible direction vectors (components are -1, 0, or 1)\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n  // 4. Mining loop\n  let attempts = 0;\n  const maxAttempts = 10; // safety limit\n  while (coalCount < 5 && attempts < maxAttempts) {\n    const needed = 5 - coalCount;\n\n    // a. Look for coal ore nearby\n    let coalBlock = bot.findBlock({\n      matching: mcData.blocksByName.coal_ore.id,\n      maxDistance: 32\n    });\n\n    // b. If not found, explore randomly until we see one\n    if (!coalBlock) {\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f Exploring for coal ore...');\n      coalBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.coal_ore.id,\n          maxDistance: 32\n        });\n      });\n      if (!coalBlock) {\n        await bot.chat('\u274c Could not locate any coal ore after exploring.');\n        break;\n      }\n    }\n\n    // c. Mine the required amount (or as many as we can find)\n    await bot.chat(`\u26cf\ufe0f Mining ${needed} coal ore block(s)...`);\n    await mineBlock(bot, 'coal_ore', needed);\n    // d. Small pause for inventory update\n    await bot.waitForTicks(5);\n    coalCount = countItem('coal');\n    attempts++;\n  }\n\n  // 5. Final report\n  if (coalCount >= 5) {\n    await bot.chat(`\u2705 Success! I now have ${coalCount} coal.`);\n  } else {\n    await bot.chat(`\u274c Task incomplete: only ${coalCount} coal collected.`);\n  }\n}", "description": "async function mineFiveCoal(bot) {\n    // The function ensures the bot acquires at least five coal by first checking its current coal count, then confirming a stone\u2011or\u2011better pickaxe is available and equipping it, after which it repeatedly searches for nearby coal ore; if none is found it explores in random directions until ore is located, mines the required number of coal ore blocks while respecting a safety attempt limit, updates the coal count after each mining attempt, and finally reports whether the target amount of coal was successfully collected.\n}"}, "mineFiveIronOre": {"code": "async function mineFiveIronOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ensure we have at least `needed` sticks (craft from oak planks if necessary)\n  const ensureSticks = async needed => {\n    if (countItem('stick') >= needed) return true;\n    const missing = needed - countItem('stick');\n    // 2 oak planks \u2192 4 sticks, so calculate planks required\n    const planksNeeded = Math.ceil(missing / 4) * 2;\n    if (countItem('oak_planks') < planksNeeded) {\n      await bot.chat('\u274c Not enough oak planks to craft sticks.');\n      return false;\n    }\n    await bot.chat(`Crafting ${missing} sticks from ${planksNeeded} oak planks...`);\n    await craftItem(bot, 'stick', missing); // craft the exact number of sticks\n    await bot.waitForTicks(5);\n    return countItem('stick') >= needed;\n  };\n\n  // ensure we have a pickaxe that can mine iron ore (stone or better)\n  const ensurePickaxe = async () => {\n    const pickaxeOrder = ['diamond_pickaxe', 'iron_pickaxe', 'gold_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n    for (const name of pickaxeOrder) {\n      const info = mcData.itemsByName[name];\n      const item = bot.inventory.findInventoryItem(info.id);\n      if (item) {\n        await bot.equip(item, 'hand');\n        await bot.chat(`Equipped ${name}.`);\n        // stone pickaxe is sufficient for iron ore\n        if (['stone_pickaxe', 'iron_pickaxe', 'diamond_pickaxe', 'gold_pickaxe'].includes(name)) {\n          return true;\n        }\n      }\n    }\n\n    // No pickaxe found \u2013 craft a stone pickaxe (3 cobblestone + 2 sticks)\n    await bot.chat('No pickaxe found, crafting a stone pickaxe...');\n    if (countItem('cobblestone') < 3) {\n      await bot.chat('\u274c Not enough cobblestone to craft a stone pickaxe.');\n      return false;\n    }\n    const sticksOk = await ensureSticks(2);\n    if (!sticksOk) return false;\n    await craftItem(bot, 'stone_pickaxe', 1);\n    await bot.waitForTicks(5);\n    const stonePickInfo = mcData.itemsByName['stone_pickaxe'];\n    const stonePick = bot.inventory.findInventoryItem(stonePickInfo.id);\n    if (stonePick) {\n      await bot.equip(stonePick, 'hand');\n      await bot.chat('Equipped newly crafted stone pickaxe.');\n      return true;\n    }\n    await bot.chat('\u274c Failed to craft a stone pickaxe.');\n    return false;\n  };\n\n  // ---------- preparation ----------\n  const hasPickaxe = await ensurePickaxe();\n  if (!hasPickaxe) {\n    await bot.chat('\u274c Cannot continue without a suitable pickaxe.');\n    return;\n  }\n\n  // random horizontal directions for exploration\n  const exploreDirections = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n  // ---------- main mining loop ----------\n  while (countItem('raw_iron') < 5) {\n    const needed = 5 - countItem('raw_iron');\n    await bot.chat(`Need ${needed} more raw iron. Searching for iron ore...`);\n\n    // try to locate iron ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName['iron_ore'].id,\n      maxDistance: 32\n    });\n\n    // if not found, explore in a random direction\n    if (!oreBlock) {\n      const dir = exploreDirections[Math.floor(Math.random() * exploreDirections.length)];\n      await bot.chat('Exploring for iron ore...');\n      oreBlock = await exploreUntil(bot, dir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName['iron_ore'].id,\n          maxDistance: 32\n        });\n      });\n      if (!oreBlock) {\n        await bot.chat('\u274c Could not locate any iron ore after exploring.');\n        return; // give up\n      }\n    }\n\n    // mine the needed amount (or as many as the cluster provides)\n    await bot.chat(`Found iron ore at ${oreBlock.position}. Mining ${needed} block(s)...`);\n    await mineBlock(bot, 'iron_ore', needed);\n    await bot.waitForTicks(5); // let inventory update\n  }\n  await bot.chat('\u2705 Successfully obtained at least 5 raw iron!');\n}", "description": "async function mineFiveIronOre(bot) {\n    // The routine first ensures a stone\u2011or\u2011better pickaxe is equipped, crafting a stone pickaxe and any required sticks if necessary, then repeatedly searches for iron ore within a 32\u2011block radius, exploring random horizontal directions when none is initially found, and mines the needed blocks until the inventory contains at least five raw iron, looping until that goal is reached and finally confirming successful acquisition.\n}"}, "smeltTenRawIron": {"code": "// main function: smelt 10 raw iron using available furnace and fuel\nasync function smeltTenRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalPlaceBlock,\n    GoalLookAtBlock\n  } = require('mineflayer-pathfinder').goals;\n\n  // ----- helper to count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- 1. Verify we have enough raw iron -----\n  const rawIronCount = countItem('raw_iron');\n  if (rawIronCount < 10) {\n    await bot.chat('\u274c I need at least 10 raw iron to smelt, but I only have ' + rawIronCount + '.');\n    return;\n  }\n\n  // ----- 2. Ensure a furnace block is placed -----\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // we have a furnace item in inventory?\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c No furnace block placed and I have no furnace item.');\n      return;\n    }\n    // place the furnace at a free adjacent air block\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await bot.chat('Placing a furnace...');\n    await placeItem(bot, 'furnace', placePos);\n    await bot.waitForTicks(5); // give the world a moment to update\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      await bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n  } else {\n    await bot.chat('\u2705 Furnace already placed.');\n  }\n\n  // ----- 3. Determine fuel distribution -----\n  const fuelInfo = [{\n    name: 'coal',\n    per: 1,\n    count: countItem('coal')\n  }, {\n    name: 'oak_log',\n    per: 10,\n    count: countItem('oak_log')\n  }, {\n    name: 'oak_planks',\n    per: 1,\n    count: countItem('oak_planks')\n  }];\n  const neededSmelts = 10;\n  let remaining = neededSmelts;\n  const fuelPlan = [];\n  for (const fuel of fuelInfo) {\n    if (remaining <= 0) break;\n    if (fuel.count <= 0) continue;\n    const maxSmeltsWithThisFuel = fuel.count * fuel.per;\n    const smeltsNow = Math.min(remaining, maxSmeltsWithThisFuel);\n    // how many fuel items are needed for those smelts?\n    const fuelItemsNeeded = Math.ceil(smeltsNow / fuel.per);\n    fuelPlan.push({\n      fuelName: fuel.name,\n      amount: fuelItemsNeeded\n    });\n    remaining -= smeltsNow;\n  }\n  if (remaining > 0) {\n    await bot.chat('\u274c Not enough fuel to smelt 10 raw iron. I need ' + remaining + ' more smelt operations.');\n    return;\n  }\n\n  // ----- 4. Perform smelting using the plan -----\n  await bot.chat('Starting smelting of 10 raw iron...');\n  for (const step of fuelPlan) {\n    await bot.chat(`Smelting ${step.amount * (step.fuelName === 'oak_log' ? 10 : 1)} raw iron using ${step.amount} ${step.fuelName}(s)...`);\n    await smeltItem(bot, 'raw_iron', step.fuelName, step.amount);\n  }\n\n  // ----- 5. Verify result -----\n  const ironIngotCount = countItem('iron_ingot');\n  if (ironIngotCount >= 10) {\n    await bot.chat(`\u2705 Successfully smelted at least 10 iron ingots! I now have ${ironIngotCount} iron ingot(s).`);\n  } else {\n    await bot.chat(`\u274c Smelting finished but I only have ${ironIngotCount} iron ingot(s).`);\n  }\n}", "description": "async function smeltTenRawIron(bot) {\n    // The function first verifies the inventory contains at least ten raw iron, then ensures a furnace block is available (placing one if necessary), calculates a fuel plan using available coal, oak logs, and oak planks to cover the ten smelts, executes the smelting according to that plan, and finally confirms that ten or more iron ingots were obtained.\n}"}, "craftIronPickaxe": {"code": "// main function to craft an iron pickaxe\nasync function craftIronPickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure enough iron ingots ----------\n  const neededIngots = 3;\n  if (countItem('iron_ingot') < neededIngots) {\n    const missing = neededIngots - countItem('iron_ingot');\n    await bot.chat(`Need ${missing} more iron ingot(s). Smelting raw iron...`);\n\n    // Ensure a furnace block is placed\n    let furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n      if (!furnaceItem) {\n        await bot.chat('\u274c No furnace item available to place.');\n        return;\n      }\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      await bot.chat('Placing furnace...');\n      await placeItem(bot, 'furnace', placePos);\n      await bot.waitForTicks(5);\n      furnaceBlock = bot.findBlock({\n        matching: mcData.blocksByName.furnace.id,\n        maxDistance: 32\n      });\n      if (!furnaceBlock) {\n        await bot.chat('\u274c Failed to place furnace.');\n        return;\n      }\n    }\n\n    // Smelt the required amount (each smelt consumes 1 coal)\n    const coalAvailable = countItem('coal');\n    if (coalAvailable < missing) {\n      await bot.chat('\u274c Not enough coal to smelt the required iron.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', 'coal', missing);\n    await bot.chat(`Smelted ${missing} iron ingot(s).`);\n  }\n\n  // ---------- 2. Ensure enough sticks ----------\n  const neededSticks = 2;\n  if (countItem('stick') < neededSticks) {\n    const missingSticks = neededSticks - countItem('stick');\n    await bot.chat(`Need ${missingSticks} more stick(s). Crafting sticks...`);\n    // Sticks are crafted from oak planks; ensure we have planks\n    if (countItem('oak_planks') < 1) {\n      // Ensure we have at least one oak log to turn into planks\n      if (countItem('oak_log') < 1) {\n        await bot.chat('\u274c No oak log available to make planks for sticks.');\n        return;\n      }\n      await bot.chat('Crafting oak planks from oak log...');\n      await craftItem(bot, 'oak_planks', 1); // 1 recipe = 4 planks\n    }\n    await craftItem(bot, 'stick', 1); // 1 recipe = 4 sticks\n    await bot.chat('Sticks crafted.');\n  }\n\n  // ---------- 3. Ensure a crafting table block is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await bot.chat('Placing crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5);\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place crafting table.');\n      return;\n    }\n  }\n\n  // ---------- 4. Craft the iron pickaxe ----------\n  await bot.chat('Crafting iron pickaxe...');\n  await craftItem(bot, 'iron_pickaxe', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 5. Verify ----------\n  if (countItem('iron_pickaxe') >= 1) {\n    await bot.chat('\u2705 Successfully crafted an iron pickaxe!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 iron pickaxe not found in inventory.');\n  }\n}", "description": "async function craftIronPickaxe(bot) {\n    // The routine gathers the required materials to craft an iron pickaxe: it checks for at least three iron ingots and, if missing, places a furnace and smelts raw iron using available coal; it then ensures two sticks are present, crafting them from oak planks or logs as needed; it also verifies a crafting table is placed nearby, placing one if absent; finally it crafts the iron pickaxe and confirms its presence in the inventory.\n}"}, "smeltExactlyFiveRawIron": {"code": "// Main function: smelt exactly five raw iron and verify the inventory changes\nasync function smeltExactlyFiveRawIron(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper to count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- 1. Verify we have enough raw iron and fuel -----\n  const rawIronBefore = countItem('raw_iron');\n  const coalBefore = countItem('coal');\n  if (rawIronBefore < 5) {\n    await bot.chat(`\u274c I only have ${rawIronBefore} raw iron \u2013 need at least 5.`);\n    return;\n  }\n  if (coalBefore < 1) {\n    await bot.chat('\u274c I need at least one piece of coal as fuel.');\n    return;\n  }\n  await bot.chat('\u2705 Required items are present. Preparing to smelt...');\n\n  // ----- 2. Ensure a furnace block is placed -----\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // We need a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n\n    // Find an adjacent air block to place the furnace\n    const reference = bot.findBlock({\n      matching: b => b && b.name !== 'air',\n      maxDistance: 32\n    });\n    if (!reference) {\n      await bot.chat('\u274c Could not find a solid block to place the furnace next to.');\n      return;\n    }\n\n    // Try a few offsets until we hit air\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = reference.position.offset(off.x, off.y, off.z);\n      const target = bot.blockAt(pos);\n      if (target && target.name === 'air') {\n        await bot.chat(`Placing a furnace at ${pos.x}, ${pos.y}, ${pos.z}...`);\n        await placeItem(bot, 'furnace', pos);\n        await bot.waitForTicks(5);\n        furnaceBlock = bot.findBlock({\n          matching: mcData.blocksByName.furnace.id,\n          maxDistance: 32\n        });\n        placed = true;\n        break;\n      }\n    }\n    if (!placed || !furnaceBlock) {\n      await bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n    await bot.chat('\u2705 Furnace placed.');\n  } else {\n    await bot.chat('\u2705 Furnace already present.');\n  }\n\n  // ----- 3. Record pre\u2011smelt counts -----\n  const ironIngotBefore = countItem('iron_ingot');\n\n  // ----- 4. Smelt exactly 5 raw iron -----\n  await bot.chat('\u26cf\ufe0f Starting smelting of 5 raw iron...');\n  await smeltItem(bot, 'raw_iron', 'coal', 5);\n  await bot.waitForTicks(5); // allow inventory to update\n\n  // ----- 5. Verify result -----\n  const rawIronAfter = countItem('raw_iron');\n  const ironIngotAfter = countItem('iron_ingot');\n  const rawIronConsumed = rawIronBefore - rawIronAfter;\n  const ingotsGained = ironIngotAfter - ironIngotBefore;\n  if (rawIronConsumed === 5 && ingotsGained === 5) {\n    await bot.chat(`\u2705 Smelting complete! Consumed 5 raw iron and produced 5 iron ingots (now ${ironIngotAfter} total).`);\n  } else {\n    await bot.chat(`\u274c Smelting result unexpected. Raw iron consumed: ${rawIronConsumed}, iron ingots gained: ${ingotsGained}.`);\n  }\n}", "description": "async function smeltExactlyFiveRawIron(bot) {\n    // The routine first checks that the inventory contains at least five raw iron and one piece of coal, aborting if not. It then looks for an existing furnace block within range and, if missing, places a furnace next to a suitable solid block. Current counts of iron ingots are recorded before smelting. Exactly five raw iron are smelted using the furnace and coal as fuel. After a short wait for the inventory to update, the function compares pre\u2011 and post\u2011smelt quantities to confirm that five raw iron were consumed and five iron ingots were produced.\n}"}, "mineFiveGoldOre": {"code": "// ------------------------------------------------------------\n// Helper functions (local to this file)\n// ------------------------------------------------------------\nasync function countItem(bot, name) {\n  const mcData = require('minecraft-data')(bot.version);\n  const itemInfo = mcData.itemsByName[name];\n  if (!itemInfo) return 0;\n  const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n  return invItem ? invItem.count : 0;\n}\n\n// Find the iron pickaxe in the inventory\n\n// Find the iron pickaxe in the inventory\nfunction getIronPickaxe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const pickaxeInfo = mcData.itemsByName['iron_pickaxe'];\n  return bot.inventory.findInventoryItem(pickaxeInfo.id);\n}\n\n// Return a random direction vector where each component is -1, 0 or 1 (not all zero)\n\n// Return a random direction vector where each component is -1, 0 or 1 (not all zero)\nfunction randomDirection() {\n  const dirs = [-1, 0, 1];\n  let vec;\n  do {\n    vec = new (require('vec3').Vec3)(dirs[Math.floor(Math.random() * dirs.length)], 0, dirs[Math.floor(Math.random() * dirs.length)]);\n  } while (vec.x === 0 && vec.z === 0);\n  return vec;\n}\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\n\n// ------------------------------------------------------------\n// Main function\n// ------------------------------------------------------------\nasync function mineFiveGoldOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n  const Vec3 = require('vec3').Vec3;\n\n  // 1) Ensure we have an iron pickaxe\n  const ironPickaxe = getIronPickaxe(bot);\n  if (!ironPickaxe) {\n    await bot.chat('\u274c I do not have an iron pickaxe, cannot mine gold ore.');\n    return;\n  }\n\n  // 2) Equip the iron pickaxe\n  await bot.equip(ironPickaxe, 'hand');\n  await bot.chat('\u2705 Iron pickaxe equipped.');\n\n  // 3) Mine until we have 5 gold ore blocks\n  const TARGET = 5;\n  let attempts = 0;\n  const MAX_ATTEMPTS = 5; // safety guard\n\n  while ((await countItem(bot, 'gold_ore')) < TARGET && attempts < MAX_ATTEMPTS) {\n    attempts++;\n\n    // Try to find a gold ore block nearby\n    let goldBlock = bot.findBlock({\n      matching: mcData.blocksByName['gold_ore'].id,\n      maxDistance: 32\n    });\n\n    // If none found, explore in a random direction until we see one\n    if (!goldBlock) {\n      const dir = randomDirection();\n      await bot.chat(`\ud83d\udd0e Exploring for gold ore (attempt ${attempts})...`);\n      goldBlock = await exploreUntil(bot, dir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName['gold_ore'].id,\n          maxDistance: 32\n        });\n      });\n    }\n\n    // After exploration, if we still have no gold ore, give up this attempt\n    if (!goldBlock) {\n      await bot.chat('\u274c Could not locate any gold ore this round.');\n      continue;\n    }\n\n    // Determine how many more we need\n    const have = await countItem(bot, 'gold_ore');\n    const need = TARGET - have;\n\n    // Mine the required amount (mineBlock will collect up to `need` blocks)\n    await bot.chat(`\u26cf\ufe0f Mining ${need} gold ore block(s)...`);\n    await mineBlock(bot, 'gold_ore', need);\n\n    // Small pause for inventory to update\n    await bot.waitForTicks(10);\n  }\n\n  // 4) Final verification\n  const finalCount = await countItem(bot, 'gold_ore');\n  if (finalCount >= TARGET) {\n    await bot.chat(`\u2705 Success! I now have ${finalCount} gold ore blocks.`);\n  } else {\n    await bot.chat(`\u274c Failed to collect ${TARGET} gold ore. I only have ${finalCount}.`);\n  }\n}", "description": "async function mineFiveGoldOre(bot) {\n    // The routine first verifies that an iron pickaxe is present and equips it, then repeatedly searches for nearby gold ore blocks\u2014exploring in random directions when none are initially found\u2014and mines the required number of blocks to reach a target of five gold ore, repeating this process up to a safety\u2011limited number of attempts before finally confirming whether the target amount was successfully collected.\n}"}, "mineThreeCoal": {"code": "// main function to mine at least three coal ore blocks\nasync function mineThreeCoal(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const invItem = bot.inventory.findInventoryItem(itemInfo.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // equip a pickaxe (prefer iron, otherwise stone, then wooden)\n  const equipPickaxe = async () => {\n    const pickaxeNames = ['iron_pickaxe', 'stone_pickaxe', 'gold_pickaxe', 'diamond_pickaxe', 'wooden_pickaxe'];\n    for (const name of pickaxeNames) {\n      const info = mcData.itemsByName[name];\n      const item = bot.inventory.findInventoryItem(info.id);\n      if (item) {\n        await bot.equip(item, 'hand');\n        await bot.chat(`Equipped ${name}.`);\n        return true;\n      }\n    }\n    await bot.chat('\u274c No pickaxe found in inventory.');\n    return false;\n  };\n\n  // ---------- 1. ensure we have a pickaxe ----------\n  const hasPickaxe = await equipPickaxe();\n  if (!hasPickaxe) return; // cannot continue without a pickaxe\n\n  // ---------- 2. mine coal until we have 3 ----------\n  const maxAttempts = 10; // safety limit\n  let attempts = 0;\n  while (countItem('coal') < 3 && attempts < maxAttempts) {\n    attempts++;\n\n    // try to find a coal ore block nearby\n    let coalBlock = bot.findBlock({\n      matching: mcData.blocksByName['coal_ore'].id,\n      maxDistance: 32\n    });\n\n    // if not found, explore in a random direction\n    if (!coalBlock) {\n      const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat('Exploring for coal ore...');\n      coalBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName['coal_ore'].id,\n          maxDistance: 32\n        });\n      });\n    }\n    if (!coalBlock) {\n      await bot.chat('\u274c Could not locate any coal ore after exploring.');\n      break;\n    }\n\n    // mine one coal ore block\n    await bot.chat('Mining a coal ore block...');\n    await mineBlock(bot, 'coal_ore', 1);\n    // give the bot a short pause for inventory update\n    await bot.waitForTicks(5);\n  }\n\n  // ---------- 3. final report ----------\n  const coalCount = countItem('coal');\n  if (coalCount >= 3) {\n    await bot.chat(`\u2705 Success! I now have ${coalCount} coal.`);\n  } else {\n    await bot.chat(`\u274c Task incomplete. Coal in inventory: ${coalCount}.`);\n  }\n}", "description": "async function mineThreeCoal(bot) {\n    // The function first equips the best available pickaxe from the bot\u2019s inventory, then repeatedly searches for coal ore within a 32\u2011block radius, exploring in random directions if none is initially found, and mines ore blocks until the inventory holds at least three coal items or a safety limit of attempts is reached, pausing briefly after each mine for inventory updates, and finally checks the coal count to determine whether the mining goal was successfully met.\n}"}, "craftFurnace": {"code": "// main function to craft a furnace\nasync function craftFurnace(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const stack = bot.inventory.findInventoryItem(itemInfo.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure a crafting table block is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // need to place one\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c I have no crafting table item to place.');\n      return;\n    }\n\n    // pick a nearby air block to place the table\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await bot.chat('Placing a crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5); // give time for the block to appear\n\n    // re\u2011check\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n  }\n\n  // ---------- 2. Ensure enough cobblestone ----------\n  const neededCobble = 8;\n  if (countItem('cobblestone') < neededCobble) {\n    const missing = neededCobble - countItem('cobblestone');\n    await bot.chat(`Need ${missing} more cobblestone, mining now...`);\n    await mineBlock(bot, 'cobblestone', missing);\n    await bot.waitForTicks(5);\n  }\n\n  // ---------- 3. Craft the furnace ----------\n  await bot.chat('Crafting a furnace...');\n  await craftItem(bot, 'furnace', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 4. Verify ----------\n  if (countItem('furnace') >= 1) {\n    await bot.chat('\u2705 Successfully crafted a furnace!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 furnace not found in inventory.');\n  }\n}", "description": "async function craftFurnace(bot) {\n    // The function ensures a crafting table block is present, placing one nearby if none is found; it then verifies the inventory contains at least eight cobblestone, mining more if necessary; with the required resources it crafts a furnace at the table; finally it checks that the furnace was added to the inventory, completing all steps asynchronously.\n}"}, "craftOneBucket": {"code": "// main function to craft one bucket\nasync function craftOneBucket(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory by name\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const stack = bot.inventory.findInventoryItem(itemInfo.id);\n    return stack ? stack.count : 0;\n  };\n\n  // 1. Ensure we have at least 3 iron ingots\n  const neededIron = 3;\n  let ironCount = countItem('iron_ingot');\n  if (ironCount < neededIron) {\n    const missing = neededIron - ironCount;\n    await bot.chat(`I need ${missing} more iron ingot(s), smelting raw iron...`);\n    // make sure we have enough raw iron and coal\n    if (countItem('raw_iron') < missing) {\n      await bot.chat('\u274c Not enough raw iron to smelt the required ingots.');\n      return;\n    }\n    if (countItem('coal') < missing) {\n      await bot.chat('\u274c Not enough coal to smelt the required ingots.');\n      return;\n    }\n    await smeltItem(bot, 'raw_iron', 'coal', missing);\n    await bot.waitForTicks(5);\n    ironCount = countItem('iron_ingot');\n  }\n\n  // 2. Ensure a crafting table block is placed nearby\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // we need to place one\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c I have no crafting table item to place.');\n      return;\n    }\n    // pick a free air block next to the bot\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await bot.chat('Placing a crafting table...');\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5);\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n  }\n\n  // 3. Craft the bucket\n  await bot.chat('Crafting a bucket...');\n  await craftItem(bot, 'bucket', 1);\n  await bot.waitForTicks(5);\n\n  // 4. Verify the bucket is now in inventory\n  if (countItem('bucket') >= 1) {\n    await bot.chat('\u2705 Successfully crafted a bucket!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 bucket not found in inventory.');\n  }\n}", "description": "async function craftOneBucket(bot) {\n    // The function first guarantees the bot possesses at least three iron ingots, smelting raw iron with coal when the count is insufficient; it then searches for a nearby crafting table and places one if none is found; finally, it crafts a bucket and verifies that the bucket now exists in the bot\u2019s inventory.\n}"}, "craftGoldenApple": {"code": "// main function to craft a golden apple\nasync function craftGoldenApple(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure required materials ----------\n  // Need 8 gold ingots and 1 apple\n  const needGold = 8;\n  const needApple = 1;\n\n  // Gold ingots\n  let gold = countItem('gold_ingot');\n  if (gold < needGold) {\n    const missingGold = needGold - gold;\n\n    // Try to smelt raw gold first\n    const rawGold = countItem('raw_gold');\n    const coal = countItem('coal');\n    const smeltCount = Math.min(missingGold, rawGold, coal);\n    if (smeltCount > 0) {\n      await bot.chat(`Smelting ${smeltCount} raw gold into gold ingots...`);\n      await smeltItem(bot, 'raw_gold', 'coal', smeltCount);\n      await bot.waitForTicks(5);\n      gold = countItem('gold_ingot');\n    }\n\n    // If still not enough, mine gold ore\n    if (gold < needGold) {\n      const stillMissing = needGold - gold;\n      await bot.chat(`Mining ${stillMissing} gold ore to get more gold ingots...`);\n      await mineBlock(bot, 'gold_ore', stillMissing);\n      await bot.waitForTicks(5);\n      // Smelt the newly mined ore (requires coal)\n      const newRawGold = countItem('raw_gold');\n      const newCoal = countItem('coal');\n      const toSmelt = Math.min(stillMissing, newRawGold, newCoal);\n      if (toSmelt > 0) {\n        await bot.chat(`Smelting mined raw gold (${toSmelt})...`);\n        await smeltItem(bot, 'raw_gold', 'coal', toSmelt);\n        await bot.waitForTicks(5);\n        gold = countItem('gold_ingot');\n      }\n    }\n  }\n\n  // Apple\n  const apple = countItem('apple');\n  if (apple < needApple) {\n    await bot.chat('\u274c I do not have an apple to craft a golden apple.');\n    return;\n  }\n\n  // ---------- 2. Ensure a crafting table is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // Need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // Find a nearby air block to place the table\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        await bot.chat(`Placing crafting table at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}...`);\n        await placeItem(bot, 'crafting_table', pos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        placed = true;\n        break;\n      }\n    }\n    if (!placed || !tableBlock) {\n      await bot.chat('\u274c Failed to place a crafting table.');\n      return;\n    }\n  }\n\n  // ---------- 3. Craft the golden apple ----------\n  await bot.chat('Crafting a golden apple...');\n  await craftItem(bot, 'golden_apple', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 4. Verify ----------\n  const goldenAppleCount = countItem('golden_apple');\n  if (goldenAppleCount >= 1) {\n    await bot.chat(`\u2705 Successfully crafted ${goldenAppleCount} golden apple(s)!`);\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 no golden apple in inventory.');\n  }\n}", "description": "async function craftGoldenApple(bot) {\n    // The routine gathers the required materials (8 gold ingots and an apple), smelting raw gold or mining gold ore as needed to reach the gold count, ensures a crafting table is present by locating or placing one nearby, then crafts a golden apple using the table and verifies that the item was successfully created.\n}"}, "obtainThreeSugarCane": {"code": "// main function to obtain at least 3 sugar cane\nasync function obtainThreeSugarCane(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count how many items of a given name are in the inventory\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // directions for random exploration (horizontal only)\n  const exploreDirections = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n  // main loop: keep harvesting until we have 3 sugar cane items\n  while (countItem('sugar_cane') < 3) {\n    const needed = 3 - countItem('sugar_cane');\n    await bot.chat(`Need ${needed} more sugar cane. Searching...`);\n\n    // try to find a sugar cane block nearby\n    let caneBlock = bot.findBlock({\n      matching: mcData.blocksByName.sugar_cane.id,\n      maxDistance: 32\n    });\n\n    // if none found, explore in a random direction until one appears\n    if (!caneBlock) {\n      const randomDir = exploreDirections[Math.floor(Math.random() * exploreDirections.length)];\n      await bot.chat('Exploring for sugar cane...');\n      caneBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.sugar_cane.id,\n          maxDistance: 32\n        });\n      });\n      if (!caneBlock) {\n        await bot.chat('\u274c Could not locate any sugar cane after exploring.');\n        return; // give up \u2013 nothing to harvest\n      }\n    }\n\n    // harvest the found sugar cane blocks (up to the amount we still need)\n    await bot.chat(`Found sugar cane at ${caneBlock.position}. Harvesting...`);\n    await mineBlock(bot, 'sugar_cane', needed);\n    // give the bot a moment to update its inventory\n    await bot.waitForTicks(5);\n  }\n  await bot.chat('\u2705 I now have at least 3 sugar cane!');\n}", "description": "async function obtainThreeSugarCane(bot) {\n    // The function repeatedly checks the bot\u2019s inventory for sugar cane and, while fewer than three are present, searches for a sugar\u2011cane block within a 32\u2011block radius; if none is found it explores in a random horizontal direction for up to a minute until one appears, then harvests the needed amount, updates the inventory, and repeats this process until at least three sugar cane are collected.\n}"}, "equipIronHelmet": {"code": "async function equipIronHelmet(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const helmetInfo = mcData.itemsByName['iron_helmet'];\n  if (!helmetInfo) {\n    await bot.chat('\u274c Could not find iron helmet data.');\n    return;\n  }\n\n  // Locate the helmet in the inventory\n  const helmetItem = bot.inventory.findInventoryItem(helmetInfo.id);\n  if (!helmetItem) {\n    await bot.chat('\u274c I do not have an iron helmet in my inventory to equip.');\n    return;\n  }\n\n  // Equip the helmet to the head slot\n  try {\n    await bot.equip(helmetItem, 'head');\n    await bot.chat('\u2705 Iron helmet equipped!');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip iron helmet: ${err.message}`);\n  }\n}", "description": "async function equipIronHelmet(bot) {\n    // The function verifies that iron helmet data exists, searches the bot\u2019s inventory for an iron helmet, and if found, attempts to equip it to the head slot while gracefully handling any errors that occur.\n}"}, "killOneSpider": {"code": "// main function to kill one spider\nasync function killOneSpider(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- 1. Choose or craft a weapon ----------\n  // Prefer swords, otherwise any pickaxe\n  const weaponPriority = ['diamond_sword', 'netherite_sword', 'iron_sword', 'golden_sword', 'stone_sword', 'wooden_sword', 'diamond_pickaxe', 'netherite_pickaxe', 'iron_pickaxe', 'golden_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n  let weaponItem = null;\n  for (const name of weaponPriority) {\n    const info = mcData.itemsByName[name];\n    const stack = bot.inventory.findInventoryItem(info.id);\n    if (stack) {\n      weaponItem = stack;\n      break;\n    }\n  }\n\n  // If we still have no weapon, craft a wooden sword (2 planks + 1 stick)\n  if (!weaponItem) {\n    const plankInfo = mcData.itemsByName.oak_planks;\n    const stickInfo = mcData.itemsByName.stick;\n    const plankStack = bot.inventory.findInventoryItem(plankInfo.id);\n    const stickStack = bot.inventory.findInventoryItem(stickInfo.id);\n    if (plankStack && plankStack.count >= 2 && stickStack && stickStack.count >= 1) {\n      // Need a crafting table \u2013 we have one in inventory\n      let tableBlock = bot.findBlock({\n        matching: mcData.blocksByName.crafting_table.id,\n        maxDistance: 32\n      });\n      if (!tableBlock) {\n        const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n        if (!tableItem) {\n          await bot.chat('\u274c No crafting table to craft a sword.');\n          return;\n        }\n        const placePos = bot.entity.position.offset(1, 0, 0);\n        await bot.chat('Placing crafting table for sword...');\n        await placeItem(bot, 'crafting_table', placePos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (!tableBlock) {\n          await bot.chat('\u274c Failed to place crafting table.');\n          return;\n        }\n      }\n      await bot.chat('Crafting a wooden sword...');\n      await craftItem(bot, 'wooden_sword', 1);\n      await bot.waitForTicks(5);\n      weaponItem = bot.inventory.findInventoryItem(mcData.itemsByName.wooden_sword.id);\n      if (!weaponItem) {\n        await bot.chat('\u274c Could not craft a wooden sword.');\n        return;\n      }\n    } else {\n      await bot.chat('\u274c Not enough materials to craft a weapon.');\n      return;\n    }\n  }\n\n  // Equip the weapon\n  await bot.equip(weaponItem, 'hand');\n  await bot.chat(`Equipped ${weaponItem.name} for combat.`);\n\n  // ---------- 2. Locate a spider ----------\n  const findSpider = () => {\n    return bot.nearestEntity(e => e.name === 'spider' && e.position.distanceTo(bot.entity.position) < 32);\n  };\n  let spider = findSpider();\n  if (!spider) {\n    // random exploration directions (horizontal only)\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    const randomDir = directions[Math.floor(Math.random() * directions.length)];\n    await bot.chat('Exploring for a spider...');\n    spider = await exploreUntil(bot, randomDir, 60, () => findSpider());\n    if (!spider) {\n      await bot.chat('\u274c No spider found after exploring.');\n      return;\n    }\n  }\n\n  // ---------- 3. Kill the spider ----------\n  await bot.chat(`Spider located at ${spider.position}. Attacking...`);\n  await killMob(bot, 'spider', 300);\n  await bot.waitForTicks(10); // give a short pause for the combat to finish\n\n  // ---------- 4. Verify ----------\n  const remaining = findSpider();\n  if (!remaining) {\n    await bot.chat('\u2705 Successfully killed the spider!');\n  } else {\n    await bot.chat('\u274c Spider still alive or another one appeared.');\n  }\n}", "description": "async function killOneSpider(bot) {\n    // The function first ensures the bot has an appropriate weapon, preferring swords and falling back to pickaxes, and crafts a wooden sword if none is available, then equips it; it searches for a spider within a set distance and, if none is found, explores randomly until a spider appears; once a spider is located, the bot attacks and kills it; finally, it verifies that no spider remains nearby to confirm the kill.\n}"}, "craftIronSwordSafe": {"code": "// main function to craft one iron sword safely\nasync function craftIronSwordSafe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory by name\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // 1. Ensure we have at least 2 iron ingots\n  const neededIron = 2;\n  let ironCount = countItem('iron_ingot');\n  if (ironCount < neededIron) {\n    const missing = neededIron - ironCount;\n    const rawIron = countItem('raw_iron');\n    const coal = countItem('coal');\n    const smeltable = Math.min(missing, rawIron, coal);\n    if (smeltable > 0) {\n      await bot.chat(`Smelting ${smeltable} raw iron into ingots...`);\n      await smeltItem(bot, 'raw_iron', 'coal', smeltable);\n      await bot.waitForTicks(5);\n      ironCount = countItem('iron_ingot');\n    }\n    if (ironCount < neededIron) {\n      await bot.chat('\u274c Not enough iron ingots after smelting.');\n      return;\n    }\n  }\n\n  // 2. Ensure we have at least 1 stick\n  if (countItem('stick') < 1) {\n    await bot.chat('\u274c Not enough sticks to craft an iron sword.');\n    return;\n  }\n\n  // 3. Locate or place a crafting table\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // candidate offsets around the bot (randomized order each attempt)\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    // shuffle offsets\n    for (let i = offsets.length - 1; i > 0; i--) {\n      const j = Math.floor(Math.random() * (i + 1));\n      [offsets[i], offsets[j]] = [offsets[j], offsets[i]];\n    }\n    let placed = false;\n    for (const off of offsets) {\n      const targetPos = bot.entity.position.offset(off.x, off.y, off.z);\n      const targetBlock = bot.blockAt(targetPos);\n      const belowBlock = bot.blockAt(targetPos.offset(0, -1, 0));\n\n      // target must be air; block below must be solid (not air, water, lava)\n      if (targetBlock && targetBlock.name === 'air' && belowBlock && !['air', 'water', 'lava'].includes(belowBlock.name)) {\n        await bot.chat(`Placing crafting table at ${targetPos.toString().replace('Vec3', '')}...`);\n        await placeItem(bot, 'crafting_table', targetPos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (tableBlock) {\n          placed = true;\n          break;\n        }\n      }\n    }\n    if (!placed) {\n      await bot.chat('\u274c Failed to find a suitable spot to place a crafting table.');\n      return;\n    }\n  }\n\n  // 4. Craft the iron sword\n  await bot.chat('Crafting an iron sword...');\n  await craftItem(bot, 'iron_sword', 1);\n  await bot.waitForTicks(5);\n\n  // 5. Verify result\n  if (countItem('iron_sword') >= 1) {\n    await bot.chat('\u2705 Successfully crafted an iron sword!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 iron sword not found in inventory.');\n  }\n}", "description": "async function craftIronSwordSafe(bot) {\n    // The routine first checks the inventory for at least two iron ingots, smelting raw iron with coal if necessary, and aborts if insufficient; it then verifies that a stick is present; it searches for a nearby crafting table and, if none is found, attempts to place one on a suitable solid block adjacent to the bot; once a crafting table is available, it crafts an iron sword using the required materials; finally, it confirms that the iron sword appears in the inventory.\n}"}, "craftFishingRod": {"code": "// main function to craft a fishing rod (robust version)\nasync function craftFishingRod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- helper: ensure we have at least `n` sticks -----\n  const ensureSticks = async n => {\n    const have = countItem('stick');\n    if (have >= n) return true;\n    const need = n - have;\n    const table = await ensureCraftingTable();\n    if (!table) return false;\n    const craftTimes = Math.ceil(need / 4); // 4 sticks per recipe\n    await bot.chat(`Crafting ${craftTimes * 4} sticks (need ${need})`);\n    await craftItem(bot, 'stick', craftTimes);\n    await bot.waitForTicks(5);\n    return countItem('stick') >= n;\n  };\n\n  // ----- helper: ensure a crafting table is placed nearby -----\n  const ensureCraftingTable = async () => {\n    // 1. Look for an existing table\n    let tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (tableBlock) return tableBlock;\n\n    // 2. Need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return null;\n    }\n\n    // 3. Search for a valid placement position\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    for (const off of offsets) {\n      // candidate position is one block above the offset (so we place on top of a solid block)\n      const pos = bot.entity.position.offset(off.x, off.y + 1, off.z);\n      const blockHere = bot.blockAt(pos);\n      const blockBelow = bot.blockAt(pos.offset(0, -1, 0));\n\n      // need air at the target and a non\u2011air block below to support the table\n      if (blockHere && blockHere.name === 'air' && blockBelow && blockBelow.name !== 'air') {\n        await bot.chat(`Placing crafting table at ${pos.x.toFixed(1)} ${pos.y.toFixed(1)} ${pos.z.toFixed(1)}`);\n        await placeItem(bot, 'crafting_table', pos);\n        await bot.waitForTicks(5);\n        // re\u2011search for the placed table\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (tableBlock) return tableBlock;\n      }\n    }\n    await bot.chat('\u274c Failed to find a suitable spot for a crafting table.');\n    return null;\n  };\n\n  // ----- 1. Ensure we have sticks and strings -----\n  if (!(await ensureSticks(3))) {\n    await bot.chat('\u274c Could not obtain enough sticks.');\n    return;\n  }\n  const neededStrings = Math.max(0, 2 - countItem('string'));\n  if (neededStrings > 0) {\n    await bot.chat('\u274c Not enough strings and we have no routine to obtain them here.');\n    return;\n  }\n\n  // ----- 2. Ensure a crafting table is present -----\n  const tableBlock = await ensureCraftingTable();\n  if (!tableBlock) return; // already reported the problem inside helper\n\n  // ----- 3. Craft the fishing rod -----\n  await bot.chat('Crafting a fishing rod...');\n  await craftItem(bot, 'fishing_rod', 1);\n  await bot.waitForTicks(5);\n\n  // ----- 4. Verify -----\n  const rodCount = countItem('fishing_rod');\n  if (rodCount >= 1) {\n    await bot.chat(`\u2705 Successfully crafted a fishing rod! (${rodCount} in inventory)`);\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 no fishing rod found.');\n  }\n}", "description": "async function craftFishingRod(bot) {\n    // The function first guarantees the bot possesses at least three sticks and the required strings, then ensures a crafting table is present nearby (placing one if needed), proceeds to craft a fishing rod using that table, waits briefly for the crafting to complete, and finally verifies the inventory to confirm the fishing rod was successfully created.\n}"}, "mineFiveCopperOre": {"code": "// main function to mine at least five copper ore (i.e., obtain 5 raw_copper)\nasync function mineFiveCopperOre(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- 1. Ensure a stone\u2011or\u2011better pickaxe is equipped -----\n  const pickaxePriority = ['diamond_pickaxe', 'netherite_pickaxe', 'iron_pickaxe', 'gold_pickaxe', 'stone_pickaxe', 'wooden_pickaxe'];\n  let equipped = false;\n  for (const name of pickaxePriority) {\n    const itemInfo = mcData.itemsByName[name];\n    const item = bot.inventory.findInventoryItem(itemInfo.id);\n    if (item) {\n      await bot.equip(item, 'hand');\n      await bot.chat(`Equipped ${name}.`);\n      equipped = true;\n      break;\n    }\n  }\n  if (!equipped) {\n    await bot.chat('\u274c No pickaxe found in inventory \u2013 cannot mine copper ore.');\n    return;\n  }\n\n  // ----- 2. Mining loop -----\n  const neededTotal = 5; // we need 5 raw_copper\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n  while (countItem('raw_copper') < neededTotal) {\n    const stillNeeded = neededTotal - countItem('raw_copper');\n    await bot.chat(`Need ${stillNeeded} more copper ore (raw copper). Searching...`);\n\n    // Try to locate a copper ore block nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName.copper_ore.id,\n      maxDistance: 32\n    });\n\n    // If not found, explore in a random direction\n    if (!oreBlock) {\n      const randomDir = directions[Math.floor(Math.random() * directions.length)];\n      await bot.chat('Exploring for copper ore...');\n      oreBlock = await exploreUntil(bot, randomDir, 60, () => {\n        return bot.findBlock({\n          matching: mcData.blocksByName.copper_ore.id,\n          maxDistance: 32\n        });\n      });\n    }\n\n    // If still not found, give up\n    if (!oreBlock) {\n      await bot.chat('\u274c Could not locate any copper ore after exploring.');\n      break;\n    }\n\n    // Mine the required amount (or as many as we can in one go)\n    await bot.chat(`Found copper ore at ${oreBlock.position}. Mining ${stillNeeded} block(s)...`);\n    await mineBlock(bot, 'copper_ore', stillNeeded);\n    // Short pause for inventory to update\n    await bot.waitForTicks(5);\n  }\n\n  // ----- 3. Final report -----\n  const finalCount = countItem('raw_copper');\n  if (finalCount >= neededTotal) {\n    await bot.chat(`\u2705 Success! I now have ${finalCount} raw copper (\u2265\u202f${neededTotal}).`);\n  } else {\n    await bot.chat(`\u26a0\ufe0f Task incomplete. Raw copper in inventory: ${finalCount}.`);\n  }\n}", "description": "async function mineFiveCopperOre(bot) {\n    // The function first checks the inventory for the best available pickaxe (diamond down to wooden) and equips it, then repeatedly searches for copper ore blocks within a set distance, exploring in random directions if none are initially found; when ore is located it mines enough blocks to reach at least five raw copper, pausing briefly for inventory updates, and continues this loop until the target count is met or no more ore can be found, after which it evaluates the final raw copper amount to determine if the goal was achieved.\n}"}, "craftIronChestplate": {"code": "// main function to craft one iron chestplate\nasync function craftIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure we have 5 iron ingots ----------\n  const neededIron = 5;\n  let ironCount = countItem('iron_ingot');\n  if (ironCount < neededIron) {\n    const missing = neededIron - ironCount;\n    // try to smelt raw iron (requires coal)\n    const rawIron = countItem('raw_iron');\n    const coal = countItem('coal');\n    const smeltable = Math.min(missing, rawIron, coal);\n    if (smeltable > 0) {\n      await bot.chat(`Smelting ${smeltable} raw iron into iron ingots...`);\n      await smeltItem(bot, 'raw_iron', 'coal', smeltable);\n      await bot.waitForTicks(5);\n      ironCount = countItem('iron_ingot');\n    }\n    if (ironCount < neededIron) {\n      await bot.chat('\u274c Not enough iron ingots to craft a chestplate.');\n      return;\n    }\n  }\n\n  // ---------- 2. Ensure a crafting table is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // find a nearby air block to place the table\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        await bot.chat(`Placing crafting table at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}...`);\n        await placeItem(bot, 'crafting_table', pos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (tableBlock) placed = true;\n        break;\n      }\n    }\n    if (!placed || !tableBlock) {\n      await bot.chat('\u274c Failed to place a crafting table.');\n      return;\n    }\n  }\n\n  // ---------- 3. Craft the iron chestplate ----------\n  await bot.chat('Crafting an iron chestplate...');\n  await craftItem(bot, 'iron_chestplate', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 4. Verify ----------\n  const chestplateCount = countItem('iron_chestplate');\n  if (chestplateCount >= 1) {\n    await bot.chat(`\u2705 Successfully crafted ${chestplateCount} iron chestplate(s)!`);\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 iron chestplate not found in inventory.');\n  }\n}", "description": "async function craftIronChestplate(bot) {\n    // The function gathers at least five iron ingots (smelting raw iron with coal if needed), ensures a crafting table is available (locating one nearby or placing it from inventory), crafts an iron chestplate, and then verifies the chestplate appears in the inventory.\n}"}, "equipIronChestplate": {"code": "// Main function to equip an iron chestplate\nasync function equipIronChestplate(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const ironChestplateInfo = mcData.itemsByName.iron_chestplate;\n\n  // Helper to send a chat message\n  const say = msg => bot.chat(msg);\n\n  // 1. Look for iron chestplate in inventory\n  let chestplateItem = bot.inventory.findInventoryItem(ironChestplateInfo.id);\n  if (!chestplateItem) {\n    // Optional: try to get it from the nearest chest (fallback)\n    say('Iron chestplate not in inventory, searching nearby chest...');\n    // Find the closest chest block within 32 blocks\n    const chestBlock = bot.findBlock({\n      matching: mcData.blocksByName.chest.id,\n      maxDistance: 32\n    });\n    if (!chestBlock) {\n      say('\u274c No chest found nearby to retrieve iron chestplate.');\n      return;\n    }\n\n    // Move to the chest and open it\n    await bot.pathfinder.goto(new GoalLookAtBlock(chestBlock.position, bot.world));\n    const chest = await bot.openContainer(chestBlock);\n    const stack = chest.findContainerItem(ironChestplateInfo.id);\n    if (!stack) {\n      await chest.close();\n      say('\u274c Chest does not contain an iron chestplate.');\n      return;\n    }\n\n    // Withdraw one chestplate\n    await chest.withdraw(stack.type, null, 1);\n    await chest.close();\n    // Refresh reference after withdrawal\n    chestplateItem = bot.inventory.findInventoryItem(ironChestplateInfo.id);\n    if (!chestplateItem) {\n      say('\u274c Failed to retrieve iron chestplate from chest.');\n      return;\n    }\n    say('\u2705 Retrieved iron chestplate from chest.');\n  }\n\n  // 2. Equip the chestplate\n  try {\n    await bot.equip(chestplateItem, 'torso');\n    say('\u2705 Iron chestplate equipped!');\n  } catch (err) {\n    say(`\u274c Failed to equip iron chestplate: ${err.message}`);\n  }\n}", "description": "async function equipIronChestplate(bot) {\n    // The function ensures the bot wears an iron chestplate by first looking for the item in its inventory; if absent it searches for the nearest chest within 32 blocks, navigates to it, opens the container, and withdraws one iron chestplate, then attempts to equip it on the torso slot and reports whether the operation succeeded or failed.\n}"}, "smeltTenRawCopper": {"code": "// main function to smelt 10 raw copper\nasync function smeltTenRawCopper(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure we have at least 10 raw copper ----------\n  const neededCopper = 10;\n  let rawCopper = countItem('raw_copper');\n  if (rawCopper < neededCopper) {\n    const missing = neededCopper - rawCopper;\n    await bot.chat(`Need ${missing} more raw copper, mining now...`);\n    await mineBlock(bot, 'raw_copper', missing);\n    await bot.waitForTicks(5);\n    rawCopper = countItem('raw_copper');\n    if (rawCopper < neededCopper) {\n      await bot.chat('\u274c Still not enough raw copper after mining.');\n      return;\n    }\n  }\n\n  // ---------- 2. Ensure we have enough coal (one per item for smeltItem) ----------\n  const neededCoal = neededCopper; // smeltItem consumes 1 coal per item\n  let coal = countItem('coal');\n  if (coal < neededCoal) {\n    const missing = neededCoal - coal;\n    await bot.chat(`Need ${missing} more coal, mining coal ore...`);\n    await mineBlock(bot, 'coal_ore', missing);\n    await bot.waitForTicks(5);\n    // smelt the newly mined raw coal (if any) \u2013 here we just assume we got coal directly\n    coal = countItem('coal');\n    if (coal < neededCoal) {\n      await bot.chat('\u274c Not enough coal after mining.');\n      return;\n    }\n  }\n\n  // ---------- 3. Ensure a furnace block is placed ----------\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // need to place one from inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n\n    // pick a nearby air block (simple offsets around the bot)\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        await bot.chat(`Placing furnace at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}...`);\n        await placeItem(bot, 'furnace', pos);\n        await bot.waitForTicks(5);\n        furnaceBlock = bot.findBlock({\n          matching: mcData.blocksByName.furnace.id,\n          maxDistance: 32\n        });\n        if (furnaceBlock) placed = true;\n        break;\n      }\n    }\n    if (!placed || !furnaceBlock) {\n      await bot.chat('\u274c Failed to place a furnace.');\n      return;\n    }\n  }\n\n  // ---------- 4. Smelt the raw copper ----------\n  await bot.chat(`Smelting ${neededCopper} raw copper using ${neededCoal} coal...`);\n  await smeltItem(bot, 'raw_copper', 'coal', neededCopper);\n  await bot.waitForTicks(5);\n\n  // ---------- 5. Verify result ----------\n  const copperIngots = countItem('copper_ingot');\n  if (copperIngots >= neededCopper) {\n    await bot.chat(`\u2705 Successfully smelted ${neededCopper} copper ingots!`);\n  } else {\n    await bot.chat(`\u274c Smelting incomplete. Copper ingots in inventory: ${copperIngots}`);\n  }\n}", "description": "async function smeltTenRawCopper(bot) {\n    // The routine first verifies that at least ten raw copper are present and mines any shortfall, then checks for an equal amount of coal and mines more if necessary, locates a furnace within range or places one from the inventory on a nearby air block, uses the furnace to smelt the raw copper with the coal, waits for the process to finish, and finally confirms that the expected number of copper ingots were obtained.\n}"}, "craftLightningRod": {"code": "// main function to craft one lightning rod\nasync function craftLightningRod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helper to count items ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ---------- 1. Ensure we have at least 3 copper ingots ----------\n  const neededCopper = 3;\n  let copper = countItem('copper_ingot');\n  if (copper < neededCopper) {\n    const missing = neededCopper - copper;\n\n    // Check we have enough raw copper and coal\n    const rawCopper = countItem('raw_copper');\n    const coal = countItem('coal');\n    const canSmelt = Math.min(missing, rawCopper, coal);\n    if (canSmelt <= 0) {\n      await bot.chat('\u274c Not enough raw copper or coal to obtain copper ingots.');\n      return;\n    }\n    await bot.chat(`Smelting ${canSmelt} raw copper into copper ingots...`);\n    await smeltItem(bot, 'raw_copper', 'coal', canSmelt);\n    await bot.waitForTicks(5);\n    copper = countItem('copper_ingot');\n    if (copper < neededCopper) {\n      await bot.chat('\u274c Still not enough copper ingots after smelting.');\n      return;\n    }\n  }\n\n  // ---------- 2. Ensure a crafting table is placed ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // Need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // Find a free air block next to the bot\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        await bot.chat(`Placing crafting table at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}...`);\n        await placeItem(bot, 'crafting_table', pos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (tableBlock) {\n          placed = true;\n          break;\n        }\n      }\n    }\n    if (!placed) {\n      await bot.chat('\u274c Failed to place a crafting table nearby.');\n      return;\n    }\n  }\n\n  // ---------- 3. Craft the lightning rod ----------\n  await bot.chat('Crafting a lightning rod...');\n  await craftItem(bot, 'lightning_rod', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 4. Verify ----------\n  const lightningRodCount = countItem('lightning_rod');\n  if (lightningRodCount >= 1) {\n    await bot.chat(`\u2705 Successfully crafted ${lightningRodCount} lightning rod(s)!`);\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 no lightning rod in inventory.');\n  }\n}", "description": "async function craftLightningRod(bot) {\n    // The function ensures the bot has at least three copper ingots, smelting raw copper with coal when needed. It then searches for a nearby crafting table and places one on an adjacent air block if none is found. With a crafting table available, it crafts a lightning rod and verifies that the item now exists in the inventory.\n}"}, "craftIronLeggings": {"code": "// Main function to craft iron leggings\nasync function craftIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count items in inventory by name\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // 1. Ensure we have enough iron ingots (7 needed)\n  const neededIron = 7;\n  let ironCount = countItem('iron_ingot');\n  if (ironCount < neededIron) {\n    const missing = neededIron - ironCount;\n    await bot.chat(`I need ${missing} more iron ingots, trying to smelt raw iron...`);\n    // smelt as many as possible from raw_iron using coal\n    const rawIron = countItem('raw_iron');\n    const coal = countItem('coal');\n    const toSmelt = Math.min(missing, rawIron, coal);\n    if (toSmelt > 0) {\n      await smeltItem(bot, 'raw_iron', 'coal', toSmelt);\n      await bot.waitForTicks(5);\n      ironCount = countItem('iron_ingot');\n    }\n    if (ironCount < neededIron) {\n      await bot.chat('\u274c Not enough iron ingots after smelting. Cannot craft leggings.');\n      return;\n    }\n  }\n\n  // 2. Ensure a crafting table block is placed nearby\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    // Need to place one from inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory to place.');\n      return;\n    }\n\n    // Find a nearby air block to place the table\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    let placed = false;\n    for (const off of offsets) {\n      const pos = bot.entity.position.offset(off.x, off.y, off.z);\n      const block = bot.blockAt(pos);\n      if (block && block.name === 'air') {\n        await bot.chat(`Placing crafting table at ${pos.x.toFixed(1)}, ${pos.y.toFixed(1)}, ${pos.z.toFixed(1)}...`);\n        await placeItem(bot, 'crafting_table', pos);\n        await bot.waitForTicks(5);\n        tableBlock = bot.findBlock({\n          matching: mcData.blocksByName.crafting_table.id,\n          maxDistance: 32\n        });\n        if (tableBlock) {\n          placed = true;\n          break;\n        }\n      }\n    }\n    if (!placed) {\n      await bot.chat('\u274c Failed to place a crafting table nearby.');\n      return;\n    }\n  }\n\n  // 3. Craft the iron leggings\n  await bot.chat('Crafting iron leggings...');\n  await craftItem(bot, 'iron_leggings', 1);\n  await bot.waitForTicks(5);\n\n  // 4. Verify result\n  const leggingsCount = countItem('iron_leggings');\n  if (leggingsCount >= 1) {\n    await bot.chat(`\u2705 Successfully crafted ${leggingsCount} iron leggings!`);\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 iron leggings not found in inventory.');\n  }\n}", "description": "async function craftIronLeggings(bot) {\n    // The routine first checks the inventory for at least seven iron ingots, and if insufficient, smelts raw iron using available coal to reach the required amount. It then searches for a nearby crafting table and, if none is found, places one on an adjacent air block. After a crafting table is available, it crafts one set of iron leggings. Finally, it confirms that the leggings appear in the inventory, stopping the process if any step fails.\n}"}, "smeltNineRawCopper": {"code": "// main function to smelt exactly 9 raw copper\nasync function smeltNineRawCopper(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- 1. Check we have enough raw copper -----\n  const neededCopper = 9;\n  const haveCopper = countItem('raw_copper');\n  if (haveCopper < neededCopper) {\n    await bot.chat(`\u274c Not enough raw copper (have ${haveCopper}, need ${neededCopper}).`);\n    return;\n  }\n\n  // ----- 2. Check we have enough fuel (coal) -----\n  const neededCoal = neededCopper; // smeltItem uses 1 coal per item\n  const haveCoal = countItem('coal');\n  if (haveCoal < neededCoal) {\n    await bot.chat(`\u274c Not enough coal (have ${haveCoal}, need ${neededCoal}).`);\n    return;\n  }\n\n  // ----- 3. Ensure a furnace is placed -----\n  let furnaceBlock = bot.findBlock({\n    matching: mcData.blocksByName.furnace.id,\n    maxDistance: 32\n  });\n  if (!furnaceBlock) {\n    // we need a furnace item in inventory\n    const furnaceItem = bot.inventory.findInventoryItem(mcData.itemsByName.furnace.id);\n    if (!furnaceItem) {\n      await bot.chat('\u274c No furnace item in inventory to place.');\n      return;\n    }\n\n    // find a suitable air block with a solid neighbour\n    const findPlace = () => {\n      const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n      const radius = 2;\n      const base = bot.entity.position.floored(); // integer block position\n      for (let dx = -radius; dx <= radius; dx++) {\n        for (let dy = 0; dy <= 1; dy++) {\n          // only ground level and one above\n          for (let dz = -radius; dz <= radius; dz++) {\n            const pos = base.offset(dx, dy, dz);\n            const block = bot.blockAt(pos);\n            if (!block || block.name !== 'air') continue;\n            // check for at least one solid neighbour\n            for (const off of offsets) {\n              const nb = bot.blockAt(pos.minus(off));\n              if (nb && nb.name !== 'air') {\n                return pos; // good spot\n              }\n            }\n          }\n        }\n      }\n      return null;\n    };\n\n    // try a few random directions if the first scan fails\n    let targetPos = null;\n    const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    for (let attempt = 0; attempt < 5 && !targetPos; attempt++) {\n      const dir = directions[Math.floor(Math.random() * directions.length)];\n      // move a bit in that direction before scanning\n      await bot.pathfinder.goto(new GoalNear(bot.entity.position.x + dir.x * 5, bot.entity.position.y, bot.entity.position.z + dir.z * 5, 2));\n      targetPos = findPlace();\n    }\n    if (!targetPos) {\n      await bot.chat('\u274c Could not find a suitable place to put a furnace.');\n      return;\n    }\n    await bot.chat(`\ud83d\udd27 Placing furnace at ${targetPos.x}, ${targetPos.y}, ${targetPos.z}...`);\n    await placeItem(bot, 'furnace', targetPos);\n    await bot.waitForTicks(5);\n\n    // re\u2011search for the placed furnace\n    furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      await bot.chat('\u274c Failed to place the furnace.');\n      return;\n    }\n  }\n\n  // ----- 4. Smelt the copper -----\n  const beforeIngots = countItem('copper_ingot');\n  await bot.chat(`\ud83d\udd25 Smelting ${neededCopper} raw copper using ${neededCoal} coal...`);\n  await smeltItem(bot, 'raw_copper', 'coal', neededCopper);\n  // give the furnace a moment to finish\n  await bot.waitForTicks(12 * 20); // 12 seconds per item \u2248 9*12s, but smeltItem already waits internally; extra wait for safety\n  await bot.waitForTicks(5);\n\n  // ----- 5. Verify result -----\n  const afterIngots = countItem('copper_ingot');\n  const gained = afterIngots - beforeIngots;\n  if (gained >= neededCopper) {\n    await bot.chat(`\u2705 Smelting complete! Gained ${gained} copper ingot(s). Total copper ingots: ${afterIngots}.`);\n  } else {\n    await bot.chat(`\u274c Smelting finished but only gained ${gained} ingot(s).`);\n  }\n}", "description": "async function smeltNineRawCopper(bot) {\n    // It first verifies the inventory contains at least nine raw copper and an equal amount of coal, then searches for a furnace nearby and places one on a suitable air block if none is found, proceeds to smelt the nine raw copper using the furnace, waits for the smelting process to finish, and finally confirms that the expected number of copper ingots were added to the inventory.\n}"}, "craftOneIronBoots": {"code": "// main function to craft one iron boot pair\nasync function craftOneIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // helper: count how many items of a given name are in the inventory\n  const countItem = name => {\n    const itemInfo = mcData.itemsByName[name];\n    if (!itemInfo) return 0;\n    const stack = bot.inventory.findInventoryItem(itemInfo.id);\n    return stack ? stack.count : 0;\n  };\n\n  // 1. Ensure we have enough iron ingots (4 needed)\n  if (countItem('iron_ingot') < 4) {\n    await bot.chat('\u274c Not enough iron ingots to craft boots (need 4).');\n    return;\n  }\n\n  // 2. Find a placed crafting table nearby\n  let craftingTableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n\n  // 3. If none found, place one from inventory\n  if (!craftingTableBlock) {\n    await bot.chat('Placing a crafting table...');\n    // find a free spot next to the bot (offset by 1 block on X axis)\n    const placePos = bot.entity.position.offset(1, 0, 0);\n    await placeItem(bot, 'crafting_table', placePos);\n    // after placing, locate the newly placed table\n    craftingTableBlock = bot.blockAt(placePos);\n    if (!craftingTableBlock || craftingTableBlock.name !== 'crafting_table') {\n      await bot.chat('\u274c Failed to place a crafting table.');\n      return;\n    }\n  }\n\n  // 4. Craft the iron boots\n  await bot.chat('Crafting iron boots...');\n  try {\n    await craftItem(bot, 'iron_boots', 1);\n  } catch (err) {\n    await bot.chat(`\u274c Crafting failed: ${err.message}`);\n    return;\n  }\n\n  // 5. Verify the boots are now in inventory\n  if (countItem('iron_boots') >= 1) {\n    await bot.chat('\u2705 Successfully crafted 1 iron boot pair!');\n  } else {\n    await bot.chat('\u274c Crafting completed but boots not found in inventory.');\n  }\n}", "description": "async function craftOneIronBoots(bot) {\n    // The function ensures the bot has at least four iron ingots, locates a crafting table within range or places one nearby, uses the table to craft a single pair of iron boots, and then verifies that the boots appear in the inventory.\n}"}, "equipIronLeggings": {"code": "// Main function to ensure iron leggings are equipped\nasync function equipIronLeggings(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n\n  // Helper to count items in inventory\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const invItem = bot.inventory.findInventoryItem(info.id);\n    return invItem ? invItem.count : 0;\n  };\n\n  // 1. Look for iron leggings in inventory\n  let leggingsItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_leggings.id);\n\n  // 2. If not found, try to craft them\n  if (!leggingsItem) {\n    await bot.chat('\ud83d\udd28 I have no iron leggings, attempting to craft them...');\n\n    // a. Need at least 8 iron ingots\n    if (countItem('iron_ingot') < 8) {\n      await bot.chat('\u274c Not enough iron ingots (need 8) to craft leggings.');\n      return;\n    }\n\n    // b. Ensure we have a crafting table (either placed or in inventory)\n    let tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      // No placed table, check inventory\n      const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n      if (!tableItem) {\n        await bot.chat('\u274c No crafting table available to craft leggings.');\n        return;\n      }\n      // Place the crafting table next to the bot\n      const placePos = bot.entity.position.offset(1, 0, 0);\n      await bot.chat('\ud83d\udce6 Placing a crafting table...');\n      await placeItem(bot, 'crafting_table', placePos);\n      // Small pause for the block to appear\n      await bot.waitForTicks(5);\n    }\n\n    // c. Craft the leggings\n    await bot.chat('\ud83e\ude9a Crafting iron leggings...');\n    await craftItem(bot, 'iron_leggings', 1);\n\n    // d. Refresh reference to the newly crafted item\n    leggingsItem = bot.inventory.findInventoryItem(mcData.itemsByName.iron_leggings.id);\n    if (!leggingsItem) {\n      await bot.chat('\u274c Crafting failed \u2013 iron leggings still missing.');\n      return;\n    }\n  }\n\n  // 3. Equip the leggings to the legs slot\n  try {\n    await bot.equip(leggingsItem, 'legs');\n    await bot.chat('\u2705 Iron leggings equipped successfully!');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip leggings: ${err.message}`);\n  }\n}", "description": "async function equipIronLeggings(bot) {\n    // The function makes sure the bot is wearing iron leggings. It first searches the inventory for iron leggings, and if none are found it verifies that at least eight iron ingots are available. It then ensures a crafting table is present, placing one if necessary, and crafts the iron leggings. After crafting, it retrieves the newly created item and attempts to equip it in the leg slot. Any errors during equipping are caught and reported.\n}"}, "equipIronBoots": {"code": "// Main function to equip iron boots\nasync function equipIronBoots(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const bootsInfo = mcData.itemsByName['iron_boots'];\n  if (!bootsInfo) {\n    await bot.chat('\u274c Could not find item data for iron boots.');\n    return;\n  }\n\n  // Check if boots are already equipped\n  // Mineflayer stores armor in bot.inventory.slots[5] (boots slot) \u2013 but we can just try to equip anyway\n  const equippedBoots = bot.inventory.slots[5];\n  if (equippedBoots && equippedBoots.type === bootsInfo.id) {\n    await bot.chat('\u2705 Iron boots are already equipped.');\n    return;\n  }\n\n  // Find iron boots in inventory\n  const bootsItem = bot.inventory.findInventoryItem(bootsInfo.id);\n  if (!bootsItem) {\n    await bot.chat('\u274c I have no iron boots in my inventory to equip.');\n    return;\n  }\n\n  // Equip the boots\n  try {\n    await bot.equip(bootsItem, 'feet');\n    await bot.chat('\u2705 Iron boots equipped successfully.');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to equip iron boots: ${err.message}`);\n  }\n}", "description": "async function equipIronBoots(bot) {\n    // The function verifies that iron boot data exists, checks whether iron boots are already equipped, searches the inventory for iron boots, and if found attempts to equip them on the feet slot while handling any errors that may occur.\n}"}, "catchFiveFish": {"code": "// main function: catch at least five fish\nasync function catchFiveFish(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  const {\n    GoalNear\n  } = require('mineflayer-pathfinder').goals;\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const item = bot.inventory.findInventoryItem(info.id);\n    return item ? item.count : 0;\n  };\n  const totalFish = () => {\n    return countItem('cod') + countItem('salmon') + countItem('tropical_fish') + countItem('pufferfish');\n  };\n  const hasFishingRod = () => {\n    const rodInfo = mcData.itemsByName.fishing_rod;\n    return !!bot.inventory.findInventoryItem(rodInfo.id);\n  };\n\n  // Find a water block (still or flowing) within 32 blocks\n  const findWaterBlock = () => {\n    return bot.findBlock({\n      matching: b => b && (b.name === 'water' || b.name === 'flowing_water'),\n      maxDistance: 32\n    });\n  };\n\n  // Choose a random cardinal/diagonal direction vector\n  const randomDirection = () => {\n    const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n    return dirs[Math.floor(Math.random() * dirs.length)];\n  };\n\n  // ---------- 1. Ensure we have a fishing rod ----------\n  if (!hasFishingRod()) {\n    await bot.chat('\u274c I have no fishing rod, cannot fish.');\n    return;\n  }\n\n  // ---------- 2. Locate water ----------\n  let waterBlock = findWaterBlock();\n  if (!waterBlock) {\n    await bot.chat('\ud83d\udd0e Searching for water...');\n    const dir = randomDirection();\n    waterBlock = await exploreUntil(bot, dir, 60, () => findWaterBlock());\n  }\n  if (!waterBlock) {\n    await bot.chat('\u274c Could not find any water within 32 blocks.');\n    return;\n  }\n\n  // ---------- 3. Move next to water ----------\n  await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f Moving next to water...');\n  await bot.pathfinder.goto(new GoalNear(waterBlock.position.x, waterBlock.position.y, waterBlock.position.z, 1));\n\n  // ---------- 4. Equip fishing rod ----------\n  const rodInfo = mcData.itemsByName.fishing_rod;\n  const rodItem = bot.inventory.findInventoryItem(rodInfo.id);\n  await bot.equip(rodItem, 'hand');\n\n  // ---------- 5. Fish until we have 5 ----------\n  await bot.chat('\ud83c\udfa3 Starting to fish...');\n  while (totalFish() < 5) {\n    try {\n      await bot.fish(); // resolves when a catch occurs\n      // short pause for inventory to update\n      await bot.waitForTicks(5);\n    } catch (err) {\n      await bot.chat('\u26a0\ufe0f Fishing attempt failed, retrying...');\n    }\n  }\n\n  // ---------- 6. Final report ----------\n  await bot.chat(`\u2705 I have caught ${totalFish()} fish!`);\n}", "description": "async function catchFiveFish(bot) {\n    // The routine verifies a fishing rod is present, locates a water block within 32\u202fblocks (searching randomly if needed), moves the bot next to the water, equips the rod, repeatedly casts and catches fish until the total of cod, salmon, tropical fish, and pufferfish reaches at least five, then concludes.\n}"}, "craftOneCopperBlock": {"code": "// main function: craft one copper block (robust placement of crafting table)\nasync function craftOneCopperBlock(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // Find a solid block (not air) within 32 blocks\n  const findSolidBlock = () => {\n    return bot.findBlock({\n      matching: b => b && b.boundingBox === 'block',\n      maxDistance: 32\n    });\n  };\n\n  // Try to place a block of given name next to a solid reference block\n  const tryPlaceBlock = async itemName => {\n    const item = bot.inventory.findInventoryItem(mcData.itemsByName[itemName].id);\n    if (!item) {\n      await bot.chat(`\u274c No ${itemName} item in inventory.`);\n      return false;\n    }\n    const reference = findSolidBlock();\n    if (!reference) {\n      await bot.chat('\u274c No solid block nearby to use as reference for placement.');\n      return false;\n    }\n\n    // directions to test for a free air spot around the reference block\n    const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0),\n    // above\n    new Vec3(0, -1, 0) // below (rarely useful)\n    ];\n    for (const off of offsets) {\n      const targetPos = reference.position.offset(off.x, off.y, off.z);\n      const targetBlock = bot.blockAt(targetPos);\n      if (targetBlock && targetBlock.name === 'air') {\n        await bot.chat(`Placing ${itemName} at ${targetPos}`);\n        await placeItem(bot, itemName, targetPos);\n        await bot.waitForTicks(5);\n        // verify placement\n        const placed = bot.blockAt(targetPos);\n        if (placed && placed.name === itemName) return true;\n      }\n    }\n    await bot.chat(`\u274c Could not find a free spot next to a solid block to place ${itemName}.`);\n    return false;\n  };\n\n  // ---------- 1. Ensure enough copper ingots ----------\n  const requiredIngots = 9;\n  let copperIngotCount = countItem('copper_ingot');\n  if (copperIngotCount < requiredIngots) {\n    const need = requiredIngots - copperIngotCount;\n    const rawCount = countItem('raw_copper');\n    if (rawCount < need) {\n      await bot.chat(`\u274c Not enough raw copper to smelt (${rawCount}/${need}).`);\n      return;\n    }\n\n    // Ensure furnace exists (place if necessary)\n    let furnaceBlock = bot.findBlock({\n      matching: mcData.blocksByName.furnace.id,\n      maxDistance: 32\n    });\n    if (!furnaceBlock) {\n      const placed = await tryPlaceBlock('furnace');\n      if (!placed) return;\n      furnaceBlock = bot.findBlock({\n        matching: mcData.blocksByName.furnace.id,\n        maxDistance: 32\n      });\n      if (!furnaceBlock) {\n        await bot.chat('\u274c Failed to place furnace.');\n        return;\n      }\n    }\n    await bot.chat(`Smelting ${need} raw copper into ingots...`);\n    await smeltItem(bot, 'raw_copper', 'coal', need);\n    copperIngotCount = countItem('copper_ingot');\n  }\n\n  // ---------- 2. Ensure a crafting table ----------\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    const placed = await tryPlaceBlock('crafting_table');\n    if (!placed) return;\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place crafting table after attempt.');\n      return;\n    }\n  }\n\n  // ---------- 3. Craft the copper block ----------\n  await bot.chat('Crafting 1 copper block...');\n  await craftItem(bot, 'copper_block', 1);\n  await bot.waitForTicks(5);\n\n  // ---------- 4. Verify ----------\n  if (countItem('copper_block') >= 1) {\n    await bot.chat('\u2705 Successfully crafted a copper block!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 no copper block in inventory.');\n  }\n}", "description": "async function craftOneCopperBlock(bot) {\n    // The routine checks the inventory for at least nine copper ingots, smelts raw copper into ingots using a furnace if needed (placing a furnace when none is found), ensures a crafting table is present by placing one if absent, then crafts a single copper block and verifies that the block now exists in the inventory.\n}"}, "eatOneCod": {"code": "// main function to eat one cod\nasync function eatOneCod(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Item\n  } = require('prismarine-item')(bot.version); // not strictly needed but kept for completeness\n\n  // helper: count items by name in inventory\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n  await bot.chat('\ud83d\udd0e Checking for cod in inventory...');\n  const codInfo = mcData.itemsByName['cod'];\n  if (!codInfo) {\n    await bot.chat('\u274c Could not find cod item data.');\n    return;\n  }\n\n  // Do we have at least one cod?\n  if (countItem('cod') < 1) {\n    await bot.chat('\u274c No cod in inventory, cannot eat.');\n    return;\n  }\n\n  // Get the cod stack\n  const codStack = bot.inventory.findInventoryItem(codInfo.id);\n  if (!codStack) {\n    await bot.chat('\u274c Unexpected error: cod stack not found.');\n    return;\n  }\n\n  // Equip cod to hand\n  await bot.chat('\ud83c\udf74 Equipping cod to hand...');\n  await bot.equip(codStack, 'hand');\n\n  // Eat the cod\n  await bot.chat('\ud83e\udd63 Eating one cod...');\n  try {\n    await bot.consume(); // consumes the item in hand\n    await bot.chat('\u2705 Successfully ate one cod.');\n  } catch (err) {\n    await bot.chat(`\u274c Failed to eat cod: ${err.message}`);\n  }\n}", "description": "async function eatOneCod(bot) {\n    // It loads the Minecraft data for the bot\u2019s version to locate the cod item ID, checks the inventory to ensure at least one cod is present, retrieves the cod stack, equips it to the hand, and then calls the consume method to eat it, handling any errors that may occur during consumption.\n}"}, "craftBow": {"code": "// main function: craft a single bow, placing a crafting table if needed\nasync function craftBow(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- helper: count items in inventory -----\n  const countItem = name => {\n    const info = mcData.itemsByName[name];\n    if (!info) return 0;\n    const stack = bot.inventory.findInventoryItem(info.id);\n    return stack ? stack.count : 0;\n  };\n\n  // ----- helper: find any solid block (not air, not leaves) -----\n  const findSolidBlock = () => {\n    return bot.findBlock({\n      matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n      maxDistance: 32\n    });\n  };\n\n  // ----- 1. Material check -----\n  const neededSticks = 3;\n  const neededStrings = 3;\n  if (countItem('stick') < neededSticks) {\n    await bot.chat(`\u274c Not enough sticks (need ${neededSticks}, have ${countItem('stick')}).`);\n    return;\n  }\n  if (countItem('string') < neededStrings) {\n    await bot.chat(`\u274c Not enough strings (need ${neededStrings}, have ${countItem('string')}).`);\n    return;\n  }\n  await bot.chat('\u2705 Materials check passed (sticks & strings).');\n\n  // ----- 2. Ensure a crafting table is placed -----\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83d\udee0\ufe0f No crafting table nearby \u2013 attempting to place one...');\n    // we must have a crafting table item in inventory\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n\n    // try up to three different positions (move a bit if needed)\n    const maxPlacementAttempts = 3;\n    let placed = false;\n    for (let attempt = 0; attempt < maxPlacementAttempts && !placed; attempt++) {\n      // find a solid reference block near us\n      const reference = findSolidBlock();\n      if (!reference) {\n        await bot.chat('\u274c Could not find a solid block to anchor the table.');\n        return;\n      }\n\n      // all six possible neighbour offsets\n      const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      for (const off of offsets) {\n        const targetPos = reference.position.offset(off.x, off.y, off.z);\n        const targetBlock = bot.blockAt(targetPos);\n        if (targetBlock && targetBlock.name === 'air') {\n          await bot.chat(`\ud83d\udccd Placing crafting table at ${targetPos}`);\n          await placeItem(bot, 'crafting_table', targetPos);\n          placed = true;\n          break;\n        }\n      }\n      if (!placed) {\n        // move a short random distance and try again\n        const dirs = [new Vec3(5, 0, 0), new Vec3(-5, 0, 0), new Vec3(0, 0, 5), new Vec3(0, 0, -5)];\n        const randDir = dirs[Math.floor(Math.random() * dirs.length)];\n        const newPos = bot.entity.position.plus(randDir);\n        await bot.chat('\ud83d\udeb6\u200d\u2642\ufe0f Exploring a bit to find space for the table...');\n        await bot.pathfinder.goto(new GoalNear(newPos.x, newPos.y, newPos.z, 2));\n        await bot.waitForTicks(10);\n      }\n    }\n    if (!placed) {\n      await bot.chat('\u274c Failed to find a free spot to place the crafting table.');\n      return;\n    }\n\n    // give the world a moment to register the new block\n    await bot.waitForTicks(5);\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Unexpected: crafting table still not detected.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed successfully.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // ----- 3. Craft the bow -----\n  await bot.chat('\ud83e\ude93 Crafting a bow...');\n  await craftItem(bot, 'bow', 1);\n  await bot.waitForTicks(5); // let inventory update\n\n  // ----- 4. Verify result -----\n  if (countItem('bow') >= 1) {\n    await bot.chat('\u2705 Bow successfully crafted! You can now use it (don\u2019t forget arrows).');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 bow not found in inventory.');\n  }\n}", "description": "async function craftBow(bot) {\n    // The function first verifies the inventory contains at least three sticks and three strings, aborting if any are missing. It then searches for a nearby crafting table and, if none is found, attempts to place one by locating a solid block and trying several adjacent positions, moving around if necessary. After a crafting table is confirmed, it crafts a bow using the required materials. Finally, it checks the inventory to confirm that a bow was created.\n}"}, "killThreeChickensReliable": {"code": "// main function to kill three chickens reliably\nasync function killThreeChickensReliable(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ---------- helpers ----------\n  // Return a random horizontal direction (X or Z non\u2011zero, Y = 0)\n  const randomHorizontalDirection = () => {\n    const vals = [-1, 0, 1];\n    let x = 0,\n      z = 0;\n    // keep looping until we get a non\u2011zero vector\n    while (x === 0 && z === 0) {\n      x = vals[Math.floor(Math.random() * vals.length)];\n      z = vals[Math.floor(Math.random() * vals.length)];\n    }\n    return new Vec3(x, 0, z);\n  };\n\n  // Equip any pickaxe or sword we have; return true if successful\n  const ensureWeaponEquipped = async () => {\n    const weapon = bot.inventory.items().find(item => {\n      const name = mcData.items[item.type]?.name;\n      return name && (name.endsWith('_pickaxe') || name.endsWith('_sword'));\n    });\n    if (!weapon) {\n      await bot.chat('\u274c No weapon (pickaxe or sword) in inventory \u2013 cannot fight.');\n      return false;\n    }\n    await bot.equip(weapon, 'hand');\n    await bot.chat('\ud83d\udd28 Equipped a weapon for combat.');\n    return true;\n  };\n\n  // Find the nearest chicken within 32 blocks, or null\n  const findChicken = () => {\n    return bot.nearestEntity(e => e.name === 'chicken' && e.position.distanceTo(bot.entity.position) < 32);\n  };\n\n  // Explore in random directions until a chicken is found or attempts run out\n  const searchForChicken = async (maxAttempts = 8) => {\n    let chicken = findChicken();\n    let attempts = 0;\n    while (!chicken && attempts < maxAttempts) {\n      const dir = randomHorizontalDirection();\n      await bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring in direction ${dir} (attempt ${attempts + 1})...`);\n      // explore up to 120 seconds per attempt\n      chicken = await exploreUntil(bot, dir, 120, () => findChicken());\n      attempts++;\n    }\n    return chicken;\n  };\n\n  // ---------- start ----------\n  const canFight = await ensureWeaponEquipped();\n  if (!canFight) return;\n  for (let i = 0; i < 3; i++) {\n    await bot.chat(`\ud83d\udc14 Searching for chicken #${i + 1}...`);\n    const chicken = await searchForChicken();\n    if (!chicken) {\n      await bot.chat('\u274c Could not locate any chickens after several explorations. Stopping.');\n      return;\n    }\n    await bot.chat(`\u2694\ufe0f Attacking chicken #${i + 1}...`);\n    // killMob attacks the nearest entity of the given name (within 32 blocks)\n    await killMob(bot, 'chicken', 300);\n\n    // short pause to let drops be collected\n    await bot.waitForTicks(20);\n  }\n  await bot.chat('\u2705 Successfully killed three chickens!');\n}", "description": "async function killThreeChickensReliable(bot) {\n    // The routine equips any available pickaxe or sword, then repeatedly searches the surroundings in random horizontal directions for a chicken within 32 blocks, attempting up to eight explorations per target; for each of three iterations it locates a chicken, attacks it until it dies, and waits briefly to collect drops, aborting if a chicken cannot be found after the allotted attempts, and finishes after successfully eliminating three chickens.\n}"}, "craftCompass": {"code": "// -----------------------------------------------------------------------------\n// Helper: find a free air block that has at least one solid neighbour\nasync function findFreePlacement(bot) {\n  const {\n    Vec3\n  } = require('vec3');\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(1, 0, 1), new Vec3(-1, 0, -1), new Vec3(1, 0, -1), new Vec3(-1, 0, 1)];\n\n  // 1\ufe0f\u20e3 try immediate surroundings of the bot\n  const reference = bot.findBlock({\n    matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n    maxDistance: 32\n  });\n  if (reference) {\n    for (const off of directions) {\n      const pos = reference.position.offset(off.x, off.y, off.z);\n      if (bot.blockAt(pos).name === 'air') return pos; // solid neighbour is `reference`\n    }\n  }\n\n  // 2\ufe0f\u20e3 if not found, explore randomly until we locate a suitable spot\n  const exploreDirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n  for (let attempt = 0; attempt < 5; attempt++) {\n    const dir = exploreDirs[Math.floor(Math.random() * exploreDirs.length)];\n    const found = await exploreUntil(bot, dir, 60, () => {\n      const solid = bot.findBlock({\n        matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n        maxDistance: 32\n      });\n      if (!solid) return null;\n      for (const off of directions) {\n        const p = solid.position.offset(off.x, off.y, off.z);\n        if (bot.blockAt(p).name === 'air') return p;\n      }\n      return null;\n    });\n    if (found) return found;\n  }\n  return null; // nothing suitable found\n}\n\n// -----------------------------------------------------------------------------\n// Main function: craft a single compass\n\n// -----------------------------------------------------------------------------\n// Main function: craft a single compass\nasync function craftCompass(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // ----- 1. Verify materials -----\n  const ironInfo = mcData.itemsByName['iron_ingot'];\n  const redstoneInfo = mcData.itemsByName['redstone'];\n  const ironStack = bot.inventory.findInventoryItem(ironInfo.id);\n  const redstoneStack = bot.inventory.findInventoryItem(redstoneInfo.id);\n  const ironCount = ironStack ? ironStack.count : 0;\n  const redstoneCount = redstoneStack ? redstoneStack.count : 0;\n  if (ironCount < 4) {\n    await bot.chat(`\u274c Need 4 iron ingots (have ${ironCount}).`);\n    return;\n  }\n  if (redstoneCount < 1) {\n    await bot.chat(`\u274c Need redstone dust (have ${redstoneCount}).`);\n    return;\n  }\n  await bot.chat('\u2705 Required materials are present.');\n\n  // ----- 2. Ensure a crafting table is placed -----\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83d\udee0\ufe0f No crafting table nearby \u2013 attempting to place one...');\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n    const placePos = await findFreePlacement(bot);\n    if (!placePos) {\n      await bot.chat('\u274c Could not find a free spot to place the crafting table.');\n      return;\n    }\n    await bot.chat(`\ud83d\udccd Placing crafting table at ${placePos}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5); // let the world update\n\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Unexpected: crafting table still not detected after placement.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed successfully.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // ----- 3. Craft the compass -----\n  await bot.chat('\ud83e\udded Crafting a compass...');\n  await craftItem(bot, 'compass', 1);\n  await bot.waitForTicks(5); // inventory update\n\n  // ----- 4. Verify result -----\n  const compassInfo = mcData.itemsByName['compass'];\n  const compassStack = bot.inventory.findInventoryItem(compassInfo.id);\n  if (compassStack && compassStack.count >= 1) {\n    await bot.chat('\u2705 Compass crafted successfully!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 compass not found in inventory.');\n  }\n}", "description": "async function craftCompass(bot) {\n    // The routine checks that the inventory holds at least four iron ingots and one redstone dust, ensures a crafting table is present nearby (placing one in a free spot if needed), crafts a compass using that table, and then verifies that the compass appears in the inventory.\n}"}, "placeChestNearby": {"code": "// main function: place a chest near the bot\nasync function placeChestNearby(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3 Check if a chest is already placed nearby\n  const nearbyChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 5\n  });\n  if (nearbyChest) {\n    await bot.chat('\u2705 Chest is already placed nearby.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Make sure we have a chest item in inventory\n  const chestItemInfo = mcData.itemsByName['chest'];\n  const chestStack = bot.inventory.findInventoryItem(chestItemInfo.id);\n  if (!chestStack) {\n    await bot.chat('\u274c No chest item in inventory \u2013 cannot place a chest.');\n    return;\n  }\n\n  // helper: offsets to the six adjacent blocks\n  const offsets = [new Vec3(1, 0, 0),\n  // east\n  new Vec3(-1, 0, 0),\n  // west\n  new Vec3(0, 1, 0),\n  // above\n  new Vec3(0, -1, 0),\n  // below\n  new Vec3(0, 0, 1),\n  // south\n  new Vec3(0, 0, -1) // north\n  ];\n\n  // 3\ufe0f\u20e3 Try a few times to find a solid block with a free neighbour\n  let placePos = null;\n  const maxAttempts = 5;\n  for (let attempt = 0; attempt < maxAttempts && !placePos; attempt++) {\n    // find a solid reference block near the bot\n    let reference = bot.findBlock({\n      matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n      maxDistance: 32\n    });\n\n    // if we couldn't find one, explore a random direction first\n    if (!reference) {\n      const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n      const randDir = dirs[Math.floor(Math.random() * dirs.length)];\n      await bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring a bit to locate a solid block (attempt ${attempt + 1})...`);\n      await exploreUntil(bot, randDir, 60, () => {\n        const blk = bot.findBlock({\n          matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n          maxDistance: 32\n        });\n        return blk ? true : null;\n      });\n      reference = bot.findBlock({\n        matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n        maxDistance: 32\n      });\n    }\n    if (!reference) {\n      await bot.chat('\u274c Still could not find a solid block to anchor the chest.');\n      break;\n    }\n\n    // look for an adjacent air block\n    for (const off of offsets) {\n      const candidate = reference.position.offset(off.x, off.y, off.z);\n      if (bot.blockAt(candidate).name === 'air') {\n        placePos = candidate;\n        break;\n      }\n    }\n\n    // if not found, move a short distance and try again\n    if (!placePos) {\n      const move = new Vec3((Math.random() - 0.5) * 6, 0, (Math.random() - 0.5) * 6);\n      await bot.pathfinder.goto(new GoalNear(bot.entity.position.x + move.x, bot.entity.position.y, bot.entity.position.z + move.z, 2));\n      await bot.waitForTicks(10);\n    }\n  }\n  if (!placePos) {\n    await bot.chat('\u274c Failed to find a free spot to place the chest.');\n    return;\n  }\n\n  // 4\ufe0f\u20e3 Place the chest\n  await bot.chat(`\ud83d\udce6 Placing chest at ${placePos.x}, ${placePos.y}, ${placePos.z}...`);\n  await placeItem(bot, 'chest', placePos);\n  await bot.waitForTicks(5); // give the world a moment to update\n\n  // 5\ufe0f\u20e3 Verify placement\n  const placedChest = bot.findBlock({\n    matching: mcData.blocksByName.chest.id,\n    maxDistance: 5\n  });\n  if (placedChest) {\n    await bot.chat('\u2705 Chest placed successfully!');\n  } else {\n    await bot.chat('\u274c Chest placement failed.');\n  }\n}", "description": "async function placeChestNearby(bot) {\n    // The routine first looks for an already placed chest within a short radius and aborts if one is found. It then verifies that the inventory contains a chest item before proceeding. It searches for a solid block nearby and examines the six adjacent positions to locate an empty air block, moving or exploring further if necessary, up to several attempts. Once a suitable free spot is identified, it places the chest item at that location. Finally, it confirms that the chest now exists within the vicinity.\n}"}, "gatherFiveCocoaBeans": {"code": "// -----------------------------------------------------------------------------\n// Helper: count how many cocoa beans are in the bot's inventory\nfunction countCocoaBeans(bot, mcData) {\n  const beanInfo = mcData.itemsByName['cocoa_beans'];\n  if (!beanInfo) return 0;\n  const stack = bot.inventory.findInventoryItem(beanInfo.id);\n  return stack ? stack.count : 0;\n}\n\n// Helper: generate a random horizontal direction (X or Z = \u00b11, Y = 0)\n\n// Helper: generate a random horizontal direction (X or Z = \u00b11, Y = 0)\nfunction randomHorizontalDirection() {\n  const vals = [-1, 0, 1];\n  let x = 0,\n    z = 0;\n  while (x === 0 && z === 0) {\n    x = vals[Math.floor(Math.random() * vals.length)];\n    z = vals[Math.floor(Math.random() * vals.length)];\n  }\n  return new Vec3(x, 0, z);\n}\n\n// -----------------------------------------------------------------------------\n// Main function: gather at least 5 cocoa beans\n\n// -----------------------------------------------------------------------------\n// Main function: gather at least 5 cocoa beans\nasync function gatherFiveCocoaBeans(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  await bot.chat('\ud83d\udd0e Starting cocoa bean gathering (target: 5 beans).');\n\n  // Loop until we have 5 or more beans\n  while (countCocoaBeans(bot, mcData) < 5) {\n    // 1\ufe0f\u20e3 Try to locate a cocoa block nearby\n    let cocoaBlock = bot.findBlock({\n      matching: mcData.blocksByName.cocoa.id,\n      maxDistance: 32\n    });\n\n    // 2\ufe0f\u20e3 If not found, explore in a random direction\n    if (!cocoaBlock) {\n      const dir = randomHorizontalDirection();\n      await bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring direction ${dir} to find cocoa pods...`);\n      cocoaBlock = await exploreUntil(bot, dir, 120, () => bot.findBlock({\n        matching: mcData.blocksByName.cocoa.id,\n        maxDistance: 32\n      }));\n      if (!cocoaBlock) {\n        await bot.chat('\u274c Could not locate any cocoa pods after exploring. Trying a new direction...');\n        continue; // go to next iteration to pick a new direction\n      }\n    }\n\n    // 3\ufe0f\u20e3 Mine the found cocoa block (break the pod)\n    await bot.chat(`\ud83c\udf31 Found cocoa pod at ${cocoaBlock.position}. Harvesting...`);\n    // mineBlock will collect the block and the dropped beans\n    await mineBlock(bot, 'cocoa', 1);\n    // give the game a short tick to register drops\n    await bot.waitForTicks(10);\n\n    // 4\ufe0f\u20e3 Report current bean count\n    const beans = countCocoaBeans(bot, mcData);\n    await bot.chat(`\ud83d\udce6 Currently have ${beans} cocoa bean(s).`);\n  }\n  await bot.chat('\u2705 Collected at least 5 cocoa beans! Task complete.');\n}", "description": "async function gatherFiveCocoaBeans(bot) {\n    // The function repeatedly searches for cocoa pods, explores random horizontal directions when none are nearby, harvests each found pod, pauses briefly to register drops, and continues looping until the inventory contains at least five cocoa beans.\n}"}, "mineFiveRedstoneDust": {"code": "// ------------------------------------------------------------\n// Helper: count how many redstone dust items are in inventory\nfunction countRedstoneDust(bot, mcData) {\n  const redstoneInfo = mcData.itemsByName['redstone'];\n  if (!redstoneInfo) return 0;\n  const stack = bot.inventory.findInventoryItem(redstoneInfo.id);\n  return stack ? stack.count : 0;\n}\n\n// Helper: pick a random direction (including down)\n\n// Helper: pick a random direction (including down)\nfunction randomDirection() {\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, -1, 0) // downwards\n  ];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n// ------------------------------------------------------------\n// Main function: mine at least 5 redstone dust\n\n// ------------------------------------------------------------\n// Main function: mine at least 5 redstone dust\nasync function mineFiveRedstoneDust(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  await bot.chat('\ud83d\udd0e Starting task: collect 5 redstone dust.');\n\n  // 1\ufe0f\u20e3 Ensure we have an iron (or better) pickaxe equipped\n  const pickaxe = bot.inventory.items().find(item => {\n    const name = mcData.items[item.type]?.name;\n    return name && name.endsWith('_pickaxe') && (name.startsWith('iron') || name.startsWith('diamond') || name.startsWith('netherite'));\n  });\n  if (!pickaxe) {\n    await bot.chat('\u274c No iron or better pickaxe in inventory \u2013 cannot mine redstone ore.');\n    return;\n  }\n  await bot.equip(pickaxe, 'hand');\n  await bot.chat('\ud83e\ude93 Equipped iron pickaxe for mining.');\n\n  // 2\ufe0f\u20e3 Loop until we have 5 redstone dust\n  while (countRedstoneDust(bot, mcData) < 5) {\n    // Try to find redstone ore nearby\n    let oreBlock = bot.findBlock({\n      matching: mcData.blocksByName.redstone_ore.id,\n      maxDistance: 32\n    });\n\n    // If not found, explore in a random direction (including down)\n    if (!oreBlock) {\n      const dir = randomDirection();\n      await bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring ${dir} to locate redstone ore...`);\n      oreBlock = await exploreUntil(bot, dir, 120,\n      // seconds\n      () => bot.findBlock({\n        matching: mcData.blocksByName.redstone_ore.id,\n        maxDistance: 32\n      }));\n      if (!oreBlock) {\n        await bot.chat('\u274c No redstone ore found in this direction. Trying another direction...');\n        continue; // try another iteration with a new random direction\n      }\n    }\n\n    // Mine the found ore block\n    await bot.chat(`\u26cf\ufe0f Found redstone ore at ${oreBlock.position}. Mining...`);\n    await mineBlock(bot, 'redstone_ore', 1);\n    // Give the game a moment to drop the dust\n    await bot.waitForTicks(10);\n\n    // Report current count\n    const current = countRedstoneDust(bot, mcData);\n    await bot.chat(`\ud83d\udce6 Collected ${current} redstone dust so far.`);\n  }\n  await bot.chat('\u2705 Task complete \u2013 you now have at least 5 redstone dust!');\n}", "description": "async function mineFiveRedstoneDust(bot) {\n    // The routine ensures an iron\u2011or\u2011better pickaxe is equipped, then repeatedly searches for redstone ore within a 32\u2011block radius, exploring in random directions (including down) when none is located, mines each ore block found, pauses briefly for the dust to drop, and repeats this process until the inventory holds at least five redstone dust items.\n}"}, "obtainFlint": {"code": "// -----------------------------------------------------------------------------\n// Helper: count how many flint items are in the bot's inventory\nfunction countFlint(bot, mcData) {\n  const flintInfo = mcData.itemsByName['flint'];\n  if (!flintInfo) return 0;\n  const stack = bot.inventory.findInventoryItem(flintInfo.id);\n  return stack ? stack.count : 0;\n}\n\n// Helper: return a random horizontal direction (X or Z non\u2011zero, Y = 0)\n\n// Helper: return a random horizontal direction (X or Z non\u2011zero, Y = 0)\nfunction randomHorizontalDirection() {\n  const vals = [-1, 0, 1];\n  let x = 0,\n    z = 0;\n  while (x === 0 && z === 0) {\n    x = vals[Math.floor(Math.random() * vals.length)];\n    z = vals[Math.floor(Math.random() * vals.length)];\n  }\n  return new (require('vec3').Vec3)(x, 0, z);\n}\n\n// -----------------------------------------------------------------------------\n// Main function: obtain at least 1 flint\n\n// -----------------------------------------------------------------------------\n// Main function: obtain at least 1 flint\nasync function obtainFlint(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  await bot.chat('\ud83d\udd0e Starting task: obtain 1 flint.');\n\n  // 1\ufe0f\u20e3 Already have flint?\n  if (countFlint(bot, mcData) >= 1) {\n    await bot.chat('\u2705 Flint already in inventory.');\n    return;\n  }\n\n  // 2\ufe0f\u20e3 Loop until we have at least one flint\n  while (countFlint(bot, mcData) < 1) {\n    // a) Find a gravel block nearby\n    let gravelBlock = bot.findBlock({\n      matching: mcData.blocksByName.gravel.id,\n      maxDistance: 32\n    });\n\n    // b) If not found, explore in a random direction\n    if (!gravelBlock) {\n      const dir = randomHorizontalDirection();\n      await bot.chat(`\ud83d\udeb6\u200d\u2642\ufe0f Exploring ${dir} to locate gravel...`);\n      gravelBlock = await exploreUntil(bot, dir, 120, () => bot.findBlock({\n        matching: mcData.blocksByName.gravel.id,\n        maxDistance: 32\n      }));\n      if (!gravelBlock) {\n        await bot.chat('\u274c No gravel found this direction, trying another...');\n        continue; // retry with a new random direction\n      }\n    }\n\n    // c) (Optional) equip a shovel if we have one \u2013 improves speed\n    const shovel = bot.inventory.items().find(item => {\n      const name = mcData.items[item.type]?.name;\n      return name && name.endsWith('_shovel');\n    });\n    if (shovel) await bot.equip(shovel, 'hand');\n\n    // d) Mine the gravel block\n    await bot.chat(`\u26cf\ufe0f Mining gravel at ${gravelBlock.position}...`);\n    await mineBlock(bot, 'gravel', 1);\n    // give the game a moment to register the drop\n    await bot.waitForTicks(10);\n\n    // e) Report current flint count\n    const current = countFlint(bot, mcData);\n    await bot.chat(`\ud83d\udce6 Flint count now: ${current}`);\n  }\n  await bot.chat('\u2705 Obtained at least 1 flint! Task complete.');\n}", "description": "async function obtainFlint(bot) {\n    // The function ensures the bot acquires at least one flint by first checking the inventory, then repeatedly locating a gravel block within a set distance, exploring in random horizontal directions when none are found, optionally equipping a shovel to speed up mining, mining the gravel and waiting briefly for drops, and rechecking the flint count until the requirement is satisfied.\n}"}, "craftClock": {"code": "// ------------------------------------------------------------\n// Helper: count items in inventory\nfunction countItem(bot, mcData, name) {\n  const info = mcData.itemsByName[name];\n  if (!info) return 0;\n  const stack = bot.inventory.findInventoryItem(info.id);\n  return stack ? stack.count : 0;\n}\n\n// Helper: find a free air block that has a solid neighbour\n\n// Helper: find a free air block that has a solid neighbour\nasync function findFreePlacement(bot) {\n  const {\n    Vec3\n  } = require('vec3');\n  const directions = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1), new Vec3(0, 1, 0), new Vec3(0, -1, 0)];\n\n  // try blocks around the bot first\n  const reference = bot.findBlock({\n    matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n    maxDistance: 32\n  });\n  if (reference) {\n    for (const off of directions) {\n      const pos = reference.position.offset(off.x, off.y, off.z);\n      if (bot.blockAt(pos).name === 'air') return pos;\n    }\n  }\n\n  // fallback: explore a bit until we locate a suitable spot\n  const exploreDirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n  for (let i = 0; i < 5; i++) {\n    const dir = exploreDirs[Math.floor(Math.random() * exploreDirs.length)];\n    const found = await exploreUntil(bot, dir, 60, () => {\n      const solid = bot.findBlock({\n        matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n        maxDistance: 32\n      });\n      if (!solid) return null;\n      for (const off of directions) {\n        const p = solid.position.offset(off.x, off.y, off.z);\n        if (bot.blockAt(p).name === 'air') return p;\n      }\n      return null;\n    });\n    if (found) return found;\n  }\n  return null; // none found\n}\n\n// ------------------------------------------------------------\n// Main function: craft a single clock\n\n// ------------------------------------------------------------\n// Main function: craft a single clock\nasync function craftClock(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3 Verify materials\n  const goldNeeded = 4;\n  const redstoneNeeded = 1;\n  const goldCount = countItem(bot, mcData, 'gold_ingot');\n  const redstoneCount = countItem(bot, mcData, 'redstone');\n  if (goldCount < goldNeeded) {\n    await bot.chat(`\u274c Need ${goldNeeded} gold ingots (have ${goldCount}).`);\n    return;\n  }\n  if (redstoneCount < redstoneNeeded) {\n    await bot.chat(`\u274c Need ${redstoneNeeded} redstone dust (have ${redstoneCount}).`);\n    return;\n  }\n  await bot.chat('\u2705 Required materials are present.');\n\n  // 2\ufe0f\u20e3 Ensure a crafting table is placed nearby\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83d\udee0\ufe0f No crafting table nearby \u2013 fetching one from a chest...');\n    // Chest that we know contains crafting tables\n    const chestPos = new Vec3(-46, 62, -604);\n    await getItemFromChest(bot, chestPos, {\n      crafting_table: 1\n    });\n    await bot.waitForTicks(5); // let inventory update\n\n    // Find a free spot to place it\n    const placePos = await findFreePlacement(bot);\n    if (!placePos) {\n      await bot.chat('\u274c Could not find a free spot to place the crafting table.');\n      return;\n    }\n    await bot.chat(`\ud83d\udccd Placing crafting table at ${placePos.x}, ${placePos.y}, ${placePos.z}`);\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5); // world update\n\n    // Verify placement\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to place the crafting table.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed successfully.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // 3\ufe0f\u20e3 Craft the clock\n  await bot.chat('\ud83d\udd52 Crafting a clock...');\n  await craftItem(bot, 'clock', 1);\n  await bot.waitForTicks(5); // inventory refresh\n\n  // 4\ufe0f\u20e3 Verify result\n  const clockInfo = mcData.itemsByName['clock'];\n  const clockStack = bot.inventory.findInventoryItem(clockInfo.id);\n  if (clockStack && clockStack.count >= 1) {\n    await bot.chat('\u2705 Clock crafted successfully!');\n  } else {\n    await bot.chat('\u274c Crafting failed \u2013 no clock in inventory.');\n  }\n}", "description": "async function craftClock(bot) {\n    // The routine checks that the inventory contains at least four gold ingots and one redstone dust, then looks for a nearby crafting table; if none is found it retrieves one from a known chest, finds an empty adjacent air block, and places the table there, confirming its placement before proceeding to craft a single clock using the crafting grid, refreshing the inventory, and finally verifying that the clock item now exists in the inventory.\n}"}, "craftFourArrowsSafe": {"code": "// -----------------------------------------------------------------------------\n// Helper utilities (reuse existing ones when possible)\n// -----------------------------------------------------------------------------\nasync function countItem(bot, name) {\n  const mcData = require('minecraft-data')(bot.version);\n  const info = mcData.itemsByName[name];\n  if (!info) return 0;\n  const stack = bot.inventory.findInventoryItem(info.id);\n  return stack ? stack.count : 0;\n}\n\n// Returns a random horizontal direction vector\n\n// Returns a random horizontal direction vector\nfunction randomDirection(bot) {\n  const {\n    Vec3\n  } = require('vec3');\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n// Find a free air block that has at least one solid neighbour\n\n// Find a free air block that has at least one solid neighbour\nasync function findFreePlacement(bot) {\n  const {\n    Vec3\n  } = require('vec3');\n  const solid = bot.findBlock({\n    matching: b => b && b.boundingBox === 'block' && b.name !== 'air',\n    maxDistance: 32\n  });\n  if (!solid) return null;\n  const offsets = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 1, 0), new Vec3(0, -1, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n  for (const off of offsets) {\n    const pos = solid.position.offset(off.x, off.y, off.z);\n    if (bot.blockAt(pos).name === 'air') return pos;\n  }\n  return null;\n}\n\n// -----------------------------------------------------------------------------\n// Main function: safely craft 4 arrows\n// -----------------------------------------------------------------------------\n\n// -----------------------------------------------------------------------------\n// Main function: safely craft 4 arrows\n// -----------------------------------------------------------------------------\nasync function craftFourArrowsSafe(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n\n  // 1\ufe0f\u20e3 Heal if health is low\n  while (bot.health < 10 && countItem(bot, 'cod') > 0) {\n    await bot.chat('\ud83c\udf63 Eating cod to heal...');\n    const codStack = bot.inventory.findInventoryItem(mcData.itemsByName.cod.id);\n    await bot.equip(codStack, 'hand');\n    await bot.consume();\n    await bot.waitForTicks(20); // give a moment for health to update\n  }\n\n  // 2\ufe0f\u20e3 Ensure a crafting table is present\n  let tableBlock = bot.findBlock({\n    matching: mcData.blocksByName.crafting_table.id,\n    maxDistance: 32\n  });\n  if (!tableBlock) {\n    await bot.chat('\ud83d\udee0\ufe0f No crafting table nearby \u2013 placing one...');\n    const tableItem = bot.inventory.findInventoryItem(mcData.itemsByName.crafting_table.id);\n    if (!tableItem) {\n      await bot.chat('\u274c No crafting table item in inventory.');\n      return;\n    }\n    const placePos = await findFreePlacement(bot);\n    if (!placePos) {\n      await bot.chat('\u274c Could not locate a free spot to place the crafting table.');\n      return;\n    }\n    await placeItem(bot, 'crafting_table', placePos);\n    await bot.waitForTicks(5);\n    tableBlock = bot.findBlock({\n      matching: mcData.blocksByName.crafting_table.id,\n      maxDistance: 32\n    });\n    if (!tableBlock) {\n      await bot.chat('\u274c Failed to detect the placed crafting table.');\n      return;\n    }\n    await bot.chat('\u2705 Crafting table placed.');\n  } else {\n    await bot.chat('\u2705 Crafting table already present.');\n  }\n\n  // 3\ufe0f\u20e3 Gather materials ----------------------------------------------------\n  // ---- Flint --------------------------------------------------------------\n  while ((await countItem(bot, 'flint')) < 1) {\n    await bot.chat('\u26cf\ufe0f Searching for gravel to obtain flint...');\n    // Try to find gravel first\n    let gravelBlock = bot.findBlock({\n      matching: mcData.blocksByName.gravel.id,\n      maxDistance: 32\n    });\n    if (!gravelBlock) {\n      // Explore a bit until we see gravel\n      await exploreUntil(bot, randomDirection(bot), 32, () => {\n        const g = bot.findBlock({\n          matching: mcData.blocksByName.gravel.id,\n          maxDistance: 32\n        });\n        return g;\n      });\n      gravelBlock = bot.findBlock({\n        matching: mcData.blocksByName.gravel.id,\n        maxDistance: 32\n      });\n    }\n    if (gravelBlock) {\n      await mineBlock(bot, 'gravel', 5); // mine up to 5 gravel blocks\n      await bot.waitForTicks(20);\n    } else {\n      await bot.chat('\u26a0\ufe0f No gravel found, cannot get flint.');\n      break;\n    }\n  }\n  await bot.chat(`\u2705 Flint count: ${await countItem(bot, 'flint')}`);\n\n  // ---- Stick ---------------------------------------------------------------\n  if ((await countItem(bot, 'stick')) < 1) {\n    // Need planks first\n    const totalPlanks = (await countItem(bot, 'oak_planks')) + (await countItem(bot, 'birch_planks')) + (await countItem(bot, 'spruce_planks')) + (await countItem(bot, 'jungle_planks')) + (await countItem(bot, 'acacia_planks')) + (await countItem(bot, 'dark_oak_planks'));\n    if (totalPlanks < 2) {\n      // Find any log we have\n      const logNames = Object.keys(mcData.itemsByName).filter(n => n.endsWith('_log'));\n      let logInfo = null;\n      for (const n of logNames) {\n        const info = mcData.itemsByName[n];\n        if (bot.inventory.findInventoryItem(info.id)) {\n          logInfo = info;\n          break;\n        }\n      }\n      if (!logInfo) {\n        await bot.chat('\u274c No logs available to craft planks.');\n        return;\n      }\n      await bot.chat(`\ud83e\udeb5 Crafting planks from ${logInfo.name}...`);\n      await craftItem(bot, logInfo.name.replace('_log', '_planks'), 1); // 1 log \u2192 4 planks\n      await bot.waitForTicks(5);\n    }\n    // Now craft sticks (2 planks \u2192 4 sticks)\n    await bot.chat('\ud83e\ude93 Crafting sticks...');\n    await craftItem(bot, 'stick', 1);\n    await bot.waitForTicks(5);\n  }\n  await bot.chat(`\u2705 Stick count: ${await countItem(bot, 'stick')}`);\n\n  // ---- Feather --------------------------------------------------------------\n  if ((await countItem(bot, 'feather')) < 1) {\n    await bot.chat('\u274c Not enough feathers to craft arrows.');\n    return;\n  }\n  await bot.chat(`\u2705 Feather count: ${await countItem(bot, 'feather')}`);\n\n  // 4\ufe0f\u20e3 Craft arrows if needed -----------------------------------------------\n  const currentArrows = await countItem(bot, 'arrow');\n  if (currentArrows >= 4) {\n    await bot.chat(`\u2705 Already have ${currentArrows} arrows \u2013 task complete.`);\n    return;\n  }\n\n  // Determine how many recipes we need (each recipe gives 4 arrows)\n  const neededRecipes = Math.ceil((4 - currentArrows) / 4);\n  await bot.chat(`\ud83c\udff9 Crafting ${neededRecipes * 4} arrows (${neededRecipes} recipe(s))...`);\n  await craftItem(bot, 'arrow', neededRecipes);\n  await bot.waitForTicks(5);\n\n  // 5\ufe0f\u20e3 Final report ---------------------------------------------------------\n  const finalCount = await countItem(bot, 'arrow');\n  if (finalCount >= 4) {\n    await bot.chat(`\u2705 Success! Bot now has ${finalCount} arrows.`);\n  } else {\n    await bot.chat('\u26a0\ufe0f Crafting arrows failed or produced fewer than expected.');\n  }\n}", "description": "async function craftFourArrowsSafe(bot) {\n    // The routine first restores health by eating cod when below a threshold, then ensures a crafting table is available, placing one on a free nearby block if needed; it next gathers required materials by mining gravel for flint, crafting planks from any log and then sticks, and confirming feather availability; after confirming sufficient resources it crafts the needed number of arrows to reach at least four, using the appropriate recipe count; finally it verifies the arrow count to confirm success.\n}"}, "obtainThreeJungleLogs": {"code": "// -----------------------------------------------------------------------------\n// Helper: count items of a given name in the bot's inventory\nfunction countItem(bot, name) {\n  const mcData = require('minecraft-data')(bot.version);\n  const info = mcData.itemsByName[name];\n  if (!info) return 0;\n  const stack = bot.inventory.findInventoryItem(info.id);\n  return stack ? stack.count : 0;\n}\n\n// Helper: ensure we have a tool (pickaxe or axe) equipped in the hand\n\n// Helper: ensure we have a tool (pickaxe or axe) equipped in the hand\nasync function ensureTool(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const tool = bot.inventory.items().find(item => {\n    const n = mcData.items[item.type]?.name;\n    return n && (n.endsWith('_pickaxe') || n.endsWith('_axe'));\n  });\n  if (!tool) {\n    // try to craft a wooden axe (3 planks + 2 sticks)\n    const plankInfo = mcData.itemsByName['oak_planks']; // any plank works\n    const stickInfo = mcData.itemsByName['stick'];\n    const plankCount = countItem(bot, 'oak_planks') + countItem(bot, 'jungle_planks');\n    const stickCount = countItem(bot, 'stick');\n    if (plankCount >= 3 && stickCount >= 2) {\n      await bot.chat('\ud83d\udd28 Crafting a wooden axe for faster log collection...');\n      await craftItem(bot, 'wooden_axe', 1);\n    } else {\n      await bot.chat('\u274c No suitable tool (pickaxe/axe) and not enough materials to craft one.');\n      return false;\n    }\n  }\n  // equip the first found tool\n  const finalTool = bot.inventory.items().find(item => {\n    const n = mcData.items[item.type]?.name;\n    return n && (n.endsWith('_pickaxe') || n.endsWith('_axe'));\n  });\n  if (finalTool) {\n    await bot.equip(finalTool, 'hand');\n    await bot.chat(`\ud83d\udee1\ufe0f Equipped ${mcData.items[finalTool.type].name} for mining.`);\n    return true;\n  }\n  return false;\n}\n\n// Helper: pick a random horizontal direction (X or Z non\u2011zero, Y = 0)\n\n// Helper: pick a random horizontal direction (X or Z non\u2011zero, Y = 0)\nfunction randomHorizontalDirection() {\n  const dirs = [new Vec3(1, 0, 0), new Vec3(-1, 0, 0), new Vec3(0, 0, 1), new Vec3(0, 0, -1)];\n  return dirs[Math.floor(Math.random() * dirs.length)];\n}\n\n// -----------------------------------------------------------------------------\n// Main function: obtain three jungle logs\n\n// -----------------------------------------------------------------------------\n// Main function: obtain three jungle logs\nasync function obtainThreeJungleLogs(bot) {\n  const mcData = require('minecraft-data')(bot.version);\n  const {\n    Vec3\n  } = require('vec3');\n  await bot.chat('\ud83d\ude80 Starting task: obtain 3 jungle logs.');\n\n  // 1) Current amount\n  let have = countItem(bot, 'jungle_log');\n  if (have >= 3) {\n    await bot.chat(`\u2705 Already have ${have} jungle logs. Task complete.`);\n    return;\n  }\n\n  // 2) Ensure we have a tool\n  const toolOk = await ensureTool(bot);\n  if (!toolOk) {\n    await bot.chat('\u274c Cannot continue without a tool.');\n    return;\n  }\n\n  // 3) Repeatedly mine / explore until we have 3 logs\n  const maxAttempts = 10; // safety guard\n  let attempts = 0;\n  while (have < 3 && attempts < maxAttempts) {\n    const needed = 3 - have;\n    await bot.chat(`\ud83d\udd0e Trying to mine ${needed} jungle log(s) nearby...`);\n    // mineBlock will look for up to `needed` logs within 32 blocks\n    await mineBlock(bot, 'jungle_log', needed);\n    // recount\n    have = countItem(bot, 'jungle_log');\n    if (have >= 3) break;\n\n    // not enough yet \u2192 explore in a random direction\n    const dir = randomHorizontalDirection();\n    await bot.chat(`\ud83d\uddfa\ufe0f Not enough logs, exploring in direction ${dir} (attempt ${attempts + 1})...`);\n    await exploreUntil(bot, dir, 60, () => {\n      const block = bot.findBlock({\n        matching: mcData.blocksByName.jungle_log.id,\n        maxDistance: 32\n      });\n      return block ? true : null;\n    });\n    attempts++;\n  }\n\n  // 4) Final report\n  have = countItem(bot, 'jungle_log');\n  if (have >= 3) {\n    await bot.chat(`\u2705 Task complete! Collected ${have} jungle logs.`);\n  } else {\n    await bot.chat(`\u26a0\ufe0f Task ended with only ${have} jungle logs after ${attempts} attempts.`);\n  }\n}", "description": "async function obtainThreeJungleLogs(bot) {\n    // The routine gathers three jungle logs for the bot, first checking the inventory and exiting early if enough are already present; it then ensures a suitable tool (pickaxe or axe) is equipped, crafting a wooden axe if needed; using the tool it repeatedly attempts to mine the required logs, and if insufficient logs are found it explores in a random horizontal direction and retries, up to a safety\u2011limited number of attempts; after each mining or exploration cycle it updates the log count; finally it reports whether the goal was achieved or how many logs were collected after the attempts.\n}"}}